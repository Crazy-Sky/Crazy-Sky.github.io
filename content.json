{"pages":[{"title":"关于","text":"Crazy-Sky软件工程专业学生一枚本博客专注于学习记录以及技术分享","link":"/about/index.html"}],"posts":[{"title":"121. 买卖股票的最佳时机","text":"leetcode 121. 买卖股票的最佳时机 题目：121. 买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意: 你不能在买入股票前卖出股票。 示例1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法：贪心思路：记录前面的最小股票价格，遍历数组以当前股价为出售价格，记录比较得出当前最大利润，遍历完的最大利润即为结果 运行数据：执行用时：1 ms，内存消耗：39.7 MB 12345678910111213141516171819// LeetCode指定调用方法public int maxProfit(int[] prices) { int len = prices.length; if (len == 0 || len == 1) return 0; int maxProfit = 0;; // 记录最大利润 int minPrice = prices[0]; // 记录最小股票价格 for (int i = 1; i &lt; len; i++) { if (minPrice == prices[i]) continue; // 如果当前股票价格与当前最小股票价格相等则跳过 if (minPrice &gt; prices[i]) { // 如果当前的股票价格比当前最小股票价格还小，更新当前最小股票价格 minPrice = prices[i]; } else { // 如果当前的股票价格比当前最小股票价格大，比较此时利润是否大于当前最大利润，更新当前最大利润 maxProfit = Math.max(maxProfit, prices[i] - minPrice); } } return maxProfit;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/19/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"},{"title":"122. 买卖股票的最佳时机 II","text":"leetcode 122. 买卖股票的最佳时机 II 题目：122. 买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示: 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 方法：贪心思路：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。 运行数据：执行用时：1 ms，内存消耗：39.9 MB 123456789101112131415// LeetCode指定调用方法public int maxProfit(int[] prices) { int len = prices.length; if (len == 0 || len == 1) return 0; int profit = 0; for (int i = 1; i &lt; len; i++) { if (prices[i] &gt; prices[i - 1]) { profit += (prices[i] - prices[i - 1]); } } return profit;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/21/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"},{"title":"141. 环形链表","text":"leetcode 141. 环形链表 题目：141. 环形链表 给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例1: 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2: 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3: 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶:你能用 O(1)（即，常量）内存解决此问题吗？ 方法一：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 1234567891011121314151617181920212223// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化快慢指针 ListNode fast = head; ListNode slow = head.next; // 双指针（快慢指针）算法 while (slow != null &amp;&amp; slow.next != null) { if (fast == slow) { return true; } fast = fast.next; slow = slow.next.next; } return false;} 方法二：标记法思路：标记法，通过遍历链表，将已遍历的链表结点赋值为Integer.MAX_VALUE，当遍历到链表结点为null时说明链表不成环，当链表结点的值为Integer.MAX_VALUE时说明链表成环。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 12345678910111213141516171819202122// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化遍历指针 ListNode node = head; // 标记算法 while (node != null) { if (node.val == Integer.MAX_VALUE) { return true; } node.val = Integer.MAX_VALUE; node = node.next; } return false;} 方法三：hash表思路：hash表，遍历链表，将遍历结点放入hash表中，当遍历到链表结点为null时说明链表不成环，当链表结点已经在hash表中时说明链表成环。 运行数据：执行用时：5 ms，内存消耗：40.8 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化遍历指针 ListNode node = head; // 初始化hash表 Set&lt;ListNode&gt; set = new LinkedHashSet&lt;&gt;(); // hash算法 while (node != null) { if (set.contains(node)) { return true; } set.add(node); node = node.next; } return false;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/24/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"347. 前 K 个高频元素","text":"leetcode 347. 前 K 个高频元素 题目：347. 前 K 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2: 输入: nums = [1], k = 1输出: [1] 说明: 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 方法一：sort排序思路：使用HashMap + ArrayList + sort，根据出现频率排序，返回频率最大的k个元素 运行数据：执行用时：16 ms，内存消耗：42.7 MB 123456789101112131415161718192021222324252627// LeetCode指定调用方法public int[] topKFrequent(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 使用sort方法排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer,Integer&gt;&gt;(map.entrySet()); list.sort(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() { @Override public int compare(Entry&lt;Integer, Integer&gt; o1, Entry&lt;Integer, Integer&gt; o2) { return o2.getValue().compareTo(o1.getValue()); } }); // 记录频率最大的k个元素 int[] result = new int[k]; for (int i = 0; i &lt; k; i++) { result[i] = list.get(i).getKey(); } return result;} 方法二：堆排序（大顶堆）思路：使用PriorityQueue,维护大顶堆，返回k个堆顶元素 运行数据：执行用时：16 ms，内存消耗：42.4 MB 123456789101112131415161718192021// LeetCode指定调用方法public int[] topKFrequent(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 优先队列 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; (map.get(o2) - map.get(o1))); queue.addAll(map.keySet()); // 记录k个堆顶元素 int[] result = new int[k]; for (int i = 0;!queue.isEmpty() &amp;&amp; i &lt; k; i++) { result[i] = queue.poll(); } return result;} 方法三：桶排序思路：桶排序，将出现频率相同的放到一个桶中 运行数据：执行用时：12 ms，内存消耗：42.5 MB 1234567891011121314151617181920212223242526272829303132// LeetCode指定调用方法public int[] topKFrequent3(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 将每个元素放到对应的桶中 List&lt;Integer&gt;[] arr = new ArrayList[nums.length + 1]; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { int value = entry.getValue(); if (arr[value] == null) { arr[value] = new ArrayList&lt;&gt;(); } arr[value].add(entry.getKey()); } // 频率最大的k个元素 int[] result = new int[k]; int t = 0; for (int i = arr.length - 1; t &lt; k &amp;&amp; i &gt; 0; i--) { if (arr[i] == null) continue; for (int item : arr[i]) { result[t++] = item; if (t == k) break; } } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/05/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"title":"215. 数组中的第K个最大元素","text":"leetcode 215. 数组中的第K个最大元素 题目：215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 方法一：java.util.Arrays的sort方法思路：使用java.util.Arrays的sort方法排序 运行数据：执行用时：2 ms，内存消耗：40.4 MB 12345// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length - k];} 方法二：堆排序（大顶堆）思路：使用堆排序（大顶堆） 运行数据：执行用时：2 ms，内存消耗：39.9 MB 12345678910111213141516171819202122232425262728293031323334353637383940// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { int len = nums.length; createBigHeap(nums, len); // 通过大顶堆排序，找出第 k个最大的元素 for (int i = 1; i &lt;= k; i++) { int temp = nums[len - i]; nums[len - i] = nums[0]; nums[0] = temp; adjustBigHeap(nums, 0, len - i); } return nums[len - k];}// 创建大顶堆public void createBigHeap(int[] nums, int len) { for (int i = len / 2 - 1; i &gt;= 0; i--) { //从第一个非叶子结点从下至上，从右至左调整结构 adjustBigHeap(nums, i, len); }}// 调整大顶堆public void adjustBigHeap(int[] nums, int i, int len) { int temp = nums[i]; for(int j = i * 2 + 1; j &lt; len; j = j * 2 + 1){ // 遍历从i开始的左子节点，左子节点的左子节点 if(j + 1 &lt; len &amp;&amp; nums[j] &lt; nums[j + 1]){ // 如果左子结点小于右子结点，则将子节点指针j指向右子结点 j++; } if(nums[j] &gt; temp){ // 如果子节点大于父节点，将子节点值赋给父节点，并将父节点指针i指向该子节点 nums[i] = nums[j]; i = j; }else{ break; } } nums[i] = temp;} 方法三：快速排序（快速选择）思路：使用快速排序，并结合题目要求对其进行优化。（通过随机数确定枢轴，降低有序数据对快速排序的影响，当确定了第 k个最大的元素时，结束快速排序，直接返回结果） 运行数据：执行用时：2 ms，内存消耗：39.9 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { int len = nums.length; int low = 0; int high = len - 1; // 将第 k个最大的元素的下标赋值给k（从小到大排序） k = len - k; // 枢轴位置 int pos; // 结合题目需求，优化后的快速排序 while (low &lt; high) { pos = partition(nums, low, high); if (pos == k) { break; } else if (pos &gt; k) { high = pos - 1; } else { low = pos + 1; } } return nums[k];}// 进行一次快速排序，确定枢轴位置public int partition(int[] nums, int low, int high) { // 通过随机数确定枢轴，降低有序数据对快速排序的影响 Random random = new Random(); int random_index = low + random.nextInt(high - low); // 枢轴 int temp = nums[random_index]; nums[random_index] = nums[low]; nums[low] = temp; while (low &lt; high) { while (low &lt; high &amp;&amp; nums[high] &gt;= temp) { // 从右往左找小于枢轴的元素 high--; } nums[low] = nums[high]; while (low &lt; high &amp;&amp; nums[low] &lt;= temp) { // 从左往右找大于枢轴的元素 low++; } nums[high] = nums[low]; } nums[low] = temp; return low; // 返回枢轴位置} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/01/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"167. 两数之和 II - 输入有序数组","text":"leetcode 167. 两数之和 II - 输入有序数组 题目：167. 两数之和 II - 输入有序数组 给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9。因此 index1 = 1, index2 = 2 。 方法一：数学组合思路：数学组合 C(numbers.length,2)，遍历所有组合，找出符合条件的组合。 运行数据：执行用时：376 ms，内存消耗：40MB 123456789101112131415161718// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // 用于存储结果 int result[] = new int[2]; // 遍历所有组合 for (int i = 0; i &lt; numbers.length - 1; i++) { for (int j = i + 1; j &lt; numbers.length; j++) { if (numbers[i] + numbers[j] == target) { result[0] = i + 1; result[1] = j + 1; } } } return result;} 方法二：双指针 （对撞指针）思路：输入数组为有序数组，从题中可以看出数组是从小到大排列，所以使用双指针（对撞指针），一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。如果两元素之和等于target，则得出结果。如果两元素之和大于target，则指向较小元素的指针右移；否则相反。 运行数据：执行用时：1 ms，内存消耗：40MB 1234567891011121314151617181920// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = numbers.length - 1; // 双指针（对撞指针）算法 while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[] { i + 1, j + 1 }; } else if (sum &lt; target) { i++; } else { j--; } } return null;} 方法三：双指针（对撞指针）+折半查找思路：在思路二的基础上，判断最小数组元素是否为非负整数，是则说明数组全为非负整数，此时可用折半查找确定双指针（对撞指针）遍历的右侧指针的初始位置，从而减少遍历次数。另外判断数组最大值是否大于target，否则没必要使用折半查找。 运行数据：执行用时：0 ms，内存消耗：39.4MB 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = numbers.length - 1; // 判断数组是否全为非负整数，判断数组最大值是否大于目标数，都满足则进行折半查找 if (numbers[i] &gt;= 0 &amp;&amp; numbers[j] &gt; target) { int left = 0, mid = 0, right = j; while (left &lt;= right) { mid = (left + right) &gt;&gt; 1; if (target == numbers[mid]) { break; } else if (target &lt; numbers[mid]) { right = mid - 1; } else { left = mid + 1; } } j = mid; } // 双指针（对撞指针）算法 while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[] { i + 1, j + 1 }; } else if (sum &lt; target) { i++; } else { j--; } } return null;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/12/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"345. 反转字符串中的元音字母","text":"leetcode 345. 反转字符串中的元音字母 题目：345. 反转字符串中的元音字母 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例1: 输入: “hello”输出: “holle” 示例2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 方法：双指针 （对撞指针）思路：双指针（对撞指针） ，一个从头向尾遍历，一个指针从尾向头遍历，找到一对元音字母交换一次 运行数据：执行用时：2 ms，内存消耗：39.8 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// LeetCode指定调用方法public String reverseVowels(String s) { // 如果字符串长度小于2，无需反转字符串中的元音字母 ，直接原样返回 if (s.length() &lt; 2) { return s; } // 将字符串转换成字符数组 char schar[] = s.toCharArray(); // i标识头指针位置，j标识尾指针位置 int i = 0, j = schar.length - 1; // flagI标识头端是否找到元音字母，flagJ标识尾端是否找到元音字母， boolean flagI = false, flagJ = false; // 反正字符串中的元音字母 while (i &lt; j) { // 判断是否找到了头端的元音字母 if (!flagI) { if (isVowel(schar[i])) { flagI = true; } else { i++; } } // 判断是否找到了尾端的元音字母 if (!flagJ) { if (isVowel(schar[j])) { flagJ = true; } else { j--; } } // 判断是否两端都找到了元音字母，都找到了将交换元音字母 if (flagI &amp;&amp; flagJ) { char temp = schar[i]; schar[i] = schar[j]; schar[j] = temp; i++; j--; flagI = false; flagJ = false; } } return new String(schar);}// 判断字符是否为元音字母public boolean isVowel(char ch) { return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||ch=='A'|| ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/18/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"},{"title":"451. 根据字符出现频率排序","text":"leetcode 451. 根据字符出现频率排序 题目：451. 根据字符出现频率排序 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。。 示例1: 输入: “tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。 因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例2: 输入: “cccaaa”输出: “cccaaa”解释: ‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。 注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例3: 输入: “Aabb”输出: “bbAa”解释: 此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。 注意’A’和’a’被认为是两种不同的字符。 方法一：堆排序（大顶堆）思路：使用PriorityQueue,维护大顶堆。通过HashMap记录每个字符的出现次数，通过维护大顶堆将出现频率按从大到小的顺序遍历字符，在遍历过程中将字符（出现次数个字符）追加到记录结果的StringBuilder里面。 运行数据：执行用时：15 ms，内存消耗：40.7 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (char ch : s.toCharArray()) { map.put(ch, map.getOrDefault(ch, 0) + 1); } // 优先队列 PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;((o1,o2)-&gt;(map.get(o2) - map.get(o1))); queue.addAll(map.keySet()); // 拼接字符串 StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { char key = queue.poll(); int count = map.get(key); while (count-- &gt; 0) { builder.append(key); } } return builder.toString();} 方法二：堆排序（大顶堆），数组替换HashMap思路：使用PriorityQueue,维护大顶堆，在方法一的基础上进行优化，使用数组替换HashMap记录字符出现的次数。 运行数据：执行用时：5 ms，内存消耗：40.6 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 int[] freq = new int[256]; for (char ch : s.toCharArray()) { freq[ch]++; } // 优先队列 PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;((o1,o2)-&gt;(freq[o2] - freq[o1])); for (int i = 0; i &lt; freq.length; i++) { if (freq[i] == 0) continue; queue.offer((char)i); } // 拼接字符串 StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { char key = queue.poll(); int count = freq[key]; while (count-- &gt; 0) { builder.append(key); } } return builder.toString();} 方法三：桶排序思路：桶排序，将出现频率相同的放到一个桶中。通过数组记录每个字符的出现次数，在进行分桶之后，依次按出现频率从大到小遍历桶，遍历桶中的元素，在遍历桶中元素的过程中将字符（出现次数个字符）追加到记录结果的StringBuilder里面。 运行数据：执行用时：10 ms，内存消耗：41.4 MB 123456789101112131415161718192021222324252627282930313233// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 int[] freq = new int[256]; for (char ch : s.toCharArray()) { freq[ch]++; } // 将每个元素放到对应的桶中 List&lt;Character&gt;[] arr = new ArrayList[s.length() + 1]; for (int i = 0; i &lt; freq.length; i++) { if (freq[i] == 0) continue; if (arr[freq[i]] == null) { arr[freq[i]] = new ArrayList&lt;&gt;(); } arr[freq[i]].add((char)i); } // 拼接字符串 StringBuilder builder = new StringBuilder(); for (int i = arr.length - 1; i &gt; 0; i--) { if (arr[i] == null) continue; for (Character item : arr[i]) { int t = i; while (t-- &gt; 0) { builder.append(item); } } } return builder.toString();} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/07/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"},{"title":"406. 根据身高重建队列","text":"leetcode 406. 根据身高重建队列 题目：406. 根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意: 总人数少于1100人。 示例: 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 方法：贪心思路：先按身高 h 降序、个数 k 值升序排列，然后将其按顺序插入到k的位置上，如果k位置上已有数据，则将原有数据后移一位再插入，由于之前排好了序，插入时会先插入身高较高的，所以后面如果k位置上有数据需要后移一位，对后移的数据也不会有影响，因为新插入的数据身高一定会比后移的低。 运行数据：执行用时：8 ms，内存消耗：40.8 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public int[][] reconstructQueue(int[][] people) { // 判断输入数据是否为空，为空则返回空结果 if (people == null || people.length == 0 || people[0].length == 0) { return new int[0][0]; } // 身高 h 降序、个数 k 值升序排列 Arrays.sort(people, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]; } }); // 插入到k的位置上，如果k位置上已有数据，则将原有数据后移一位再插入，此时使用list，它会自动后移数据 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int[] p : people) { list.add(p[1], p); } // 将结果list转为数组结果返回 return list.toArray(new int[list.size()][]);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/17/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"},{"title":"435. 无重叠区间","text":"leetcode 435. 无重叠区间 题目：435. 无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 1.可以认为区间的终点总是大于它的起点。 2.区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 方法一：贪心思路：先使用贪心计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次不重叠区间的选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 运行数据：执行用时：4 ms，内存消耗：39.5 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public int eraseOverlapIntervals(int[][] intervals) { // 如果区间为空，则直接返回0 int count = intervals.length; if (count == 0) return 0; // 根据区间结尾排序从小到大排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 选择结尾最小，并且和前一个区间不重叠的区间 int number = 1; int index = 0; for (int i = 1; i &lt; count; i++) { if (intervals[index][1] &lt;= intervals[i][0]) { number++; index = i; } } // 总个数减去最大不重叠区间的个数 return count - number;} 方法二：动态规划思路：使用动态规划计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。对区间按区间结尾从小到大排序，方便使用动态规划时判断是否重叠， 动态转移方程为：dp[i]=max(dp[i], dp[j] + 1) 其中dp[i]表示从第0个区间到第i个区间的最大不重叠区间的个数，dp[j]表示从第0个区间到第j个区间的最大不重叠区间的个数，0 &lt;= j &lt; i。 运行数据：执行用时：224 ms，内存消耗：40 MB 1234567891011121314151617181920212223242526272829303132333435// LeetCode指定调用方法public int eraseOverlapIntervals(int[][] intervals) { // 如果区间为空，则直接返回0 int count = intervals.length; if (count == 0) return 0; // 根据区间结尾排序从小到大排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 动态规划 int[] dp = new int[count]; int number = 1; dp[0] = 1; // 求出dp for (int i = 1; i &lt; count; i++) { // 遍历第个i区间前的dp，判断是否能与第i个区间不重叠，通过遍历得出能与第i个区间不重叠的拥有最大不重叠区间个数的dp，将其加上第i个区间，则为dp[i] for (int j = i - 1; j &gt;= 0; j--) { // 判断第i个区间是否与第j个区间重叠 if (intervals[i][0] &gt;= intervals[j][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } // 记录当前的最大不重叠区间的个数 number = Math.max(number, dp[i]); } // 总个数减去最大不重叠区间的个数 return count - number;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/13/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"},{"title":"392. 判断子序列","text":"leetcode 392. 判断子序列 题目：392. 判断子序列 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例1: s = “abc”, t = “ahbgdc”返回 true. 示例2: s = “axc”, t = “ahbgdc”返回 false. 方法：贪心思路：遍历字符串s，判断s的所有字符是否都在字符串t里的相对位置（相对于字符在s的位置），判断完在一个字符之后，如果不在字符串t里则直接返回false，如果在则继续判断下一个字符，且从上一个字符被在字符串t中找到的位置继续往后找，以保证相对位置正确，当s的全部字符都在t里，且符合相对位置时，返回true。 运行数据：执行用时：0 ms，内存消耗：37.8 MB 123456789101112131415161718192021// LeetCode指定调用方法public boolean isSubsequence(String s, String t) { // 标识t的当前位置 int index = -1; // 遍历字符串s for (char c : s.toCharArray()) { // 判断字符串s的字符c是否在t的里，且满足相对位置（相对于字符在s的位置） index = t.indexOf(c, index + 1); // 如果字符串s的字符c不在字符串t里则直接返回false if (index == -1) { return false; } } // 当s的全部字符都在t里，且符合相对位置时，返回true return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/25/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"452. 用最少数量的箭引爆气球","text":"leetcode 452. 用最少数量的箭引爆气球 题目：452. 用最少数量的箭引爆气球 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend，且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 示例: 输入: [[10,16], [2,8], [1,6], [7,12]]输出: 2解释: 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 方法：贪心思路：本题主要是实现用最少的弓箭把所有的气球射爆，弓箭一次性可以射爆叠加处的所有气球，因此我们只需使用贪心找出最多的不重叠区间数即可，最多不重叠区间数即为所需的最小弓箭数，因为其他区间必然是与不重叠区间中的一个或者多个相重叠于一处的（其他区间必定会重叠于不重叠区间的开始或者结尾处），所以只需要射击不重叠区间处即可把所有气球射爆。 在每次不重叠区间的选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 运行数据：执行用时：21 ms，内存消耗：47.4 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public int findMinArrowShots(int[][] points) { // 如果区间为空，则直接返回0 int count = points.length; if (count == 0) return 0; // 根据区间结尾排序 Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 选择结尾最小，并且和前一个区间不重叠的区间 int number = 1; int index = 0; for (int i = 1; i &lt; count; i++) { if (points[i][0] &gt; points[index][1]) { number++; index = i; } } //返回不重叠区间数 return number;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/15/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"},{"title":"455. 分发饼干","text":"leetcode 455. 分发饼干 题目：455. 分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意: 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例1: 输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例2: 输入: [1,2], [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2。 方法：贪心 + 双指针（快慢指针）思路： 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子.因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。 首先将孩子的胃口数组和饼干尺寸数组按从小到大排序，然后使用双指针（快慢指针）的方式遍历判断当前最小尺寸的饼干是否满足当前最小胃口的孩子，若不满足，则将遍历至能够满足这个孩子的胃口的饼干尺寸处，，接着继续遍历下一个孩子的胃口和下一个饼干的尺寸，依此遍历，当孩子胃口遍历完了，或者饼干尺寸遍历完了，则运行结束。 运行数据：执行用时：7 ms，内存消耗：40.9 MB 1234567891011121314151617181920212223// LeetCode指定调用方法public int findContentChildren(int[] g, int[] s) { // 若没有孩子胃口或者没有饼干尺寸，则说明不会有一个孩子满足 if (g == null || s == null) return 0; // 对孩子胃口和饼干尺寸排序 Arrays.sort(g); Arrays.sort(s); // 分别标识孩子胃口和饼干尺寸数组遍历位置的指针 int gi = 0; int si = 0; // 双指针（快慢指针）遍历 while (gi &lt; g.length &amp;&amp; si &lt; s.length) { if (g[gi] &lt;= s[si]) gi++; si++; } // 孩子为胃口被满足了gi才会加，所以gi其实就是被满足的孩子数 return gi;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/11/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"},{"title":"524. 通过删除字母匹配到字典里最长单词","text":"leetcode 524. 通过删除字母匹配到字典里最长单词 题目：524. 通过删除字母匹配到字典里最长单词 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例1: 输入：s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出：”apple” 示例2: 输入：s = “abpcplea”, d = [“a”,”b”,”c”]输出：”a” 示例3: 1.所有输入的字符串只包含小写字母。2.字典的大小不会超过 1000。3.所有输入的字符串长度不会超过 1000。 方法：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针指向字符串s，一个指针指向字典字符串d(i)。 运行数据：执行用时：11 ms，内存消耗：40 MB 123456789101112131415161718192021222324252627282930313233343536373839404142// LeetCode指定调用方法public String findLongestWord(String s, List&lt;String&gt; d) { // 最长字串 String longestWord = \"\"; int len = s.length(); for (String string : d) { int len1 = longestWord.length(), len2 = string.length(); if (len &gt; len2) { if (len1 &lt; len2 || (len1 == len2 &amp;&amp; string.compareTo(longestWord) &lt; 0)) { if (isSubstr(s, len, string, len2)) { longestWord = string; } } } else if (len == len2 &amp;&amp; s.compareTo(string) == 0) { return string; } } return longestWord;}// 双指针（快慢指针）算法，判断是否为子串public boolean isSubstr(String s, int len, String string, int len2) { int i = len - 1, j = len2 - 1; while (i &gt;= j &amp;&amp; i &gt;= 0 &amp;&amp; j &gt;= 0) { if (s.charAt(i) == string.charAt(j)) { j--; } i--; } return j == -1;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/26/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"53. 最大子序和","text":"leetcode 53. 最大子序和 题目：53. 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 方法：贪心思路：遍历数组，对于第i个数，计算以i为终点的最大序列和。如果以 i-1 为终点的最大序列和为正数，则加上它，否则抛弃。 运行数据：执行用时：1 ms，内存消耗：40 MB 123456789101112// LeetCode指定调用方法public int maxSubArray(int[] nums) { int maxValue = nums[0]; int preValue = nums[0]; for (int i = 1; i &lt; nums.length; i++) { preValue = Math.max(nums[i], preValue + nums[i]); maxValue = Math.max(maxValue, preValue); } return maxValue;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/29/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"665. 非递减数列","text":"leetcode 665. 非递减数列 题目：665. 非递减数列 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 示例1: 输入: nums = [4,2,3]输出: true解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例2: 输入: nums = [4,2,1]输出: false解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: 1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 方法：贪心思路：遍历数组，如遇到当前值比后一个值大时，根据当前的值的前后值做相应修改，以保证为非递减数列，当出现两次，当前值比后一个值大时直接返回false，如果遍历完之后只出现一次或者零次当前值比后一个值大的情况则返回true。修改时应尽可能往小了修改，从而保证能够得到非递减数列。 运行数据：执行用时：1 ms，内存消耗：41 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean checkPossibility(int[] nums) { int len = nums.length; int count = 0; for (int i = 0; i &lt; len - 1; i++) { // 当前值比后一个值小时跳过，当前值比后一个值大时做相应修改 if (nums[i] &lt;= nums[i + 1]) continue; // 当出现两次，当前值比后一个值大时直接返回false count++; if (count &gt; 1) return false; // 当前一个值比后一个值大时，此时隐含着当前值比后一个大值（循环中第一个if没进去的隐含条件），前一个值比当前值小（已遍历的数据必会满足这一点），为了尽可能是被修改的值小且满足非递减数组，应将当前值赋值给后一个值 // 否则时，此时隐含着前一个值比后一个值小或者相等（否则时的条件），当前值比后一个大值，前一个值比当前值小，为了尽可能是被修改的值小且满足非递减数组，应将后一个值赋值给当前值 if (i != 0 &amp;&amp; nums[i - 1] &gt; nums[i + 1]) { nums[i + 1] = nums[i]; } else { nums[i] = nums[i + 1]; } } return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/27/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"},{"title":"605. 种花问题","text":"leetcode 605. 种花问题 题目：605. 种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例1: 输入: flowerbed = [1,0,0,0,1], n = 1输出: True 示例2: 输入: flowerbed = [1,0,0,0,1], n = 2输出: False 提示: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 方法：贪心思路：从头开始一个一个判断是否可以种植花卉。 运行数据：执行用时：1 ms，内存消耗：41.5 MB 1234567891011121314151617// LeetCode指定调用方法public boolean canPlaceFlowers(int[] flowerbed, int n) { int len = flowerbed.length; for (int i = 0; i &lt; len; i++) { if (flowerbed[i] == 1) continue; int pre = i == 0 ? 0 : flowerbed[i - 1]; int next = i == len - 1 ? 0 : flowerbed[i + 1]; if (pre == 0 &amp;&amp; next == 0) { flowerbed[i] = 1; n--; } } return n &lt;= 0;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/23/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"},{"title":"633. 平方数之和","text":"leetcode 633. 平方数之和 题目：633. 平方数之和 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1: 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 方法一：双指针（对撞指针）思路：由题意可得a^2、b^2的最小值为0，最大值不能大于c。由于是平方和，且只需判断是否存在，因此负整数对结果没影响 ；由于负整数的平方值跟他对应的正整数的平方值相等，所以只需考虑非负整数即可；综上所述，可使用双指针一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 运行数据：执行用时：2 ms，内存消耗：36.2 MB 123456789101112131415161718192021// LeetCode指定调用方法public boolean judgeSquareSum(int c) { // i标识头指针位置，j标识尾指针位置，通过sqrt确定尾指针最大值，在确定头指针最小值 int i = 0, j = (int)Math.sqrt(c), sum = 0; i = (int)Math.sqrt(c - j * j); // 双指针（对撞指针）算法 while (i &lt;= j) { sum = i * i + j * j; if (sum == c) { return true; }else if (sum &lt; c) { i++; } else { j--; } } return false;} 方法二：直接使用sqrt思路：直接使用sqrt函数确定a的最大值，并对其进行枚举，通过b^2=c-a^2得出b平方的值，最后通过sqrt判断b平方开方取整是否等于b。 运行数据：执行用时：4 ms，内存消耗：36.4 MB 123456789101112// LeetCode指定调用方法public boolean judgeSquareSum(int c) { for (long a = 0; a * a &lt;= c; a++) { double b = Math.sqrt(c - a * a); if (b == (int) b) { return true; } } return false;} 方法三：费马平方和定理思路：根据费马平方和定理得出的：一个非负整数 c 能够表示为两个整数的平方和，当且仅当 c 的所有形如 4k+3 的质因子的幂次均为偶数。证明方法可以见 这里。 运行数据：执行用时：0 ms，内存消耗：36 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean judgeSquareSum(int c) { // 判断因子c是否满足条件，因为c是c自己的因数，幂次是奇数（幂次只能为1），若C为4k+3的形式，将不满足推论 if ((c &amp; 3) == 3) { return false; } // 判断在2到c开平方之间的因子是否满足条件 for (int i = 2; i * i &lt;= c; i++) { int count = 0; if (c % i == 0) { while (c % i == 0) { count++; c /= i; } if ((i &amp; 3) == 3 &amp;&amp; count % 2 != 0){ return false; } } } // 判断1和在c开平方到c之间的因子是否满足条件 return (c &amp; 3) != 3;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/16/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"6675. 度度熊与排列","text":"HDOJ 6675. 度度熊与排列 题目：6675. 度度熊与排列 问题描述： 度熊有一个机器，这个机器有一个 1∼M 的排列 p[1..M] 当作参数，若丢进一个长度为 M 的字符串，此机器会将此字符串重新排列后再输出，重新排列的方式为：原本第 i 个位置的字符会变到第 p[i] 个位置。 举例来说，当 M=3，p[1]=3,p[2]=1,p[3]=2，那么丢 “abc” 进入这个机器后，机器会输出”bca”;若丢进的是 “ded”，那么机器会输出 “edd”。 某天，度熊不小心忘记这个机器的参数了，只记得参数的长度是 M，于是他丢了 N 长度为 M 的字符串进去，并记录下对于每个字符串机器的输出结果，请你根据这些结果，帮度熊找回这个机器的参数。若有多组参数都满足度熊的记录，请输出字典序最小的排列作为参数。若并不存在任何参数满足度熊的记录，请输出 −1。 注：对于两个相异的排列a: a[1..M] 和 b[1..M]，我们称 a 比 b 小当且仅当 存在一个 i，满足对于所有小于 i 的 j 都有 aj=bj 且 ai&lt;bi。 输入： 有多组询问，第一行包含一个正整数 T 代表有几组询问。每组询问的第一行包含两个正整数 N,M，分别代表度熊丢进机器的字符串数目以及参数的长度。接下来还有 2×N 行，每行有一个长度为 M 的字符串，当中的第 2×i−1 行的字符串代表度熊丢进去机器的第 i 个字符串，而第 2×i 行的字符串代表机器对于第 i 个字符串的输出结果。1≤T≤1001≤N≤201≤M≤50字符串由英文小写字母(‘a’ 至 ‘z’) 组成 输出： 对于每一个询问，输出一行，若不存在任何参数满足度熊的记录，这行只包含一个整数 −1。否则这行包含一个排列，代表此机器所有可能的参数中字典序最小的那个。 样本输入： 41 3abcbca2 4aaabbaaacdcccccd3 3aaaaaabbbbbbcccccc1 1az 样本输出： 3 1 22 4 3 11 2 3-1 注意： 第一组询问中， $p[1]=3,p[2]=1,p[3]=2$ 是唯一的机器可能的参数。 第二组询问中， $p=[2,4,3,1]$ 和 $p=[3,4,2,1]$ 都是机器可能的参数，不过 $[2,4,3,1]$ 的字典序比 $[3,4,2,1]$ 还小，故必须输出 2,4,3,1。 方法：枚举思路：先确定第一个字符串的第一个机器参数，再判断其他字符串是否满足该机器参数，满足则继续确定第一个字符串的下一个机器参数，否则将重新确定第一个字符串的第一个机器参数，且从刚刚的位置开始找，若找不到其他的机器参数则认为其没有满足条件的机器参数，直接结束，若找到了，依次类推继续判断其他字符串是否满足这个机器参数。 运行数据：执行用时：343MS，内存消耗：11356K 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); while (t-- &gt; 0) { int n = sc.nextInt(); int m = sc.nextInt(); String instr[] = new String[n]; String outstr[] = new String[n]; for (int i = 0; i &lt; n; i++) { instr[i] = sc.next(); outstr[i] = sc.next(); } fun(instr, outstr, n, m); } } private static void fun(String[] instr, String[] outstr, int n, int m) { // 记录机器参数 int result[] = new int[m]; // 标记第一字符串已确定为机器参数的输出字符串序号 boolean flag[] = new boolean[m]; // 记录第一个输出字符串的位置 int number = 0; // 搜索每个位置的机器参数 for (int i = 0; i &lt; m; i++) { // 搜索第一个字符串的机器参数 boolean searchFlag = false; for (int k = number; k &lt; m; k++) { if (instr[0].charAt(i) == outstr[0].charAt(k) &amp;&amp; !flag[k]) { number = k + 1; searchFlag = true; break; } } // 判断是否有机器参数 if (!searchFlag) { System.out.println(\"-1\"); return ; } // 遍历除第一个字符串外的其他字符串是否都满足第一个字符串的机器参数 boolean tempFlag = false; for (int j = 1; j &lt; n; j++) { if (instr[j].charAt(i) != outstr[j].charAt(number - 1)) { tempFlag = true; break; } } // 满足则继续寻找下一个机器参数，否则重新确定当前位置的机器参数 if (!tempFlag) { result[i] = number; flag[number - 1] = true; number = 0; } else { i--; } } // 输出结果 for (int i = 0; i &lt; m; i++) { System.out.print(result[i]); if (i == m - 1) { System.out.println(); } else { System.out.print(\" \"); } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/30/6675.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E6%8E%92%E5%88%97/"},{"title":"6674. 度度熊与数字","text":"HDOJ 6674. 度度熊与数字 题目：6674. 度度熊与数字 问题描述： 度熊发现，1个， 3 以及 9 这三个数字很神奇，它们的所有的倍数的每位数字的和一定是自己的倍数。 54 是 3 的倍数，同时 5 + 4 = 9 也是 3 的倍数。在另一个例子 666 是 9 的倍数，同时 6 + 6 + 6 = 18 也是 9的倍数。 度熊又发现，除了1个， 3， 9 以外的正整数，虽然不一定满足“所有的倍数的每位数字的和一定是自己的倍数”，但也存在一些数是它们的倍数且各位数字和也是它们的倍数。888 是 12 的倍数，且他的各位数字和 8 + 8 + 8 = 24 也是 12的倍数。 现在度熊想知道，给你一个正整数V，是否存在一个数 X，从而 V 是 X 的倍数，同时它的每位数字的和也是 X 的倍数呢？请寻找所有这样的数 X。 输入： 有多组询问，第一行包含一个正整数 T代表有几组询问，随后每组测试数据占一行，包含一个正整数 V。1 ≤ T≤ 1001 ≤ V≤109 输出： 对于每一个询问，输出两行，第一行包含一个正整数 m，m 代表对于该询问的 V，有几个满足条件的 x。第二行输出 m 个数，把所有满足条件的 x 由小到大输出。 样本输入： 319666666 样本输出： 1131 3 9 6 1 2 3 6 9 18 注意： 第一个询问中，11 的各位数和为 1=1×1，本身等于1×1 都是 1 的倍数，故 1 确实为 V=1 的答案。 第三个询问中，666666 的各位数和为 36=9×4，本身等于9×7474 都是 99 的倍数，故 9 确实为 V=666666的答案，经过仔细计算后能发现，除 9 以外, 1,2,3,6,18 也都是答案。 方法：枚举思路：因为1必为所求X，所以只需从2开始枚举到numberSum(V)满足V%X== 0 &amp;&amp; numberSum(V)%X == 0的即为所求除1外的X。 运行数据：执行用时：249 MS，内存消耗：9400K 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); while (m-- &gt; 0) { int v = sc.nextInt(); StringBuilder result = new StringBuilder(\"1\"); int count = 1; int numberSum = numberSum(v); for (int i = 2; i &lt;= numberSum; i++) { if (v % i == 0 &amp;&amp; numberSum % i == 0) { result.append(\" \" + i); count++; } } System.out.println(count); System.out.println(result); } } // 求number各位数字之和 public static int numberSum(int number) { int sum = 0; while (number != 0) { sum += number % 10; number /= 10; } return sum; } 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/28/6674.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E6%95%B0%E5%AD%97/"},{"title":"6676. 度度熊与运算式 1","text":"HDOJ 6676. 度度熊与运算式 1 题目：6676. 度度熊与运算式 1 问题描述： 某天度熊发现了一个由 n+1 个数字 1 组成的运算式如下： 1 op1 1 op2 1 … 1 opn 1 其中 opi 可能是 ⊕ (按位异或运算) 或是 ? (问号)。 例如当 n=5 时，式子可能长成这样：1⊕1 ? 1⊕1 ? 1 ? 1 现在，度熊想把所有的 ‘?’ 取代为 + 或 ⊕。 (贴心提示： 加法运算的优先级比按位异或运算还高) 请问取代完后此运算式可能的最大运算结果为何？ 输入： 有多组询问，第一行包含一个正整数 T 代表有几组询问，接着每组测试数据占一行，包含一个长度为 n 的字符串，仅由 ‘^’和 ‘?’组成，第 i 个字符若是 ‘^’ 就代表 opi=⊕，否则 opi 就是问号。(n 的值不会在数据中出现，请由字符串长度来判断。)1≤n≤2^21−2 所有询问的 n 的总和不超过 2×10^7 输出： 对于每一个询问输出一行包含一个整数代表答案，也就是该算式的问号被取代后可能的最大运算结果。 样本输入： 4???^^^^^ 样本输出： 2310 注意： 样例的第一组询问算式为：1?1。取代后有 2种可能 1+1和 1^1，其中 1+1=2、1^1=0，所以最大的可能值是 2。 样例的第二组询问算式为：1?1?1。取代后有 4 种可能 1+1+1,1+1^1,1^1+1和 1^1^1， 样例的第三组询问算式为：1^1^1。并不包含问号，只有唯一的运算结果 1。 样例的第四组询问算式为：1^1^1^1。并不包含问号，只有唯一的运算结果 0。 方法：异或原理思路：将字符串按^分成多个小段，把每个小段整理成为2的i次幂（幂次i不能相同， i &gt; 0）的段，从而使得不同幂次间的小段执行^时最大，再处理其他整理之后剩余的不满足2的i次幂（幂次i不能相同， i &gt; 0）的段，这些剩余的小段要么不能分解为2的i次幂（小段的值是1），要么能分解但幂次与之前分解的小段相同(若分解，合并执行^时，会相互抵消，使得最后的值变小，所以这样的小段只能将小段中的？变为^，从而使得小段的值最小，执行^时相互抵消最小) 运行数据：执行用时：1014MS，内存消耗：15832K 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); while (t-- &gt; 0) { String s = sc.next(); // 记录1的个数 int numLen = s.length() + 1; // 用split方法分段 String[] sections = s.split(\"\\\\^\"); // 分段数 int sectionLen = sections.length; // 如果分段数为0，说明源字符串s全为^ if (sectionLen == 0) { System.out.println(numLen % 2); continue; } // 将每一段整理分成多个2的i次幂（幂次i不能相同， i &gt; 0）段并执行^，余下不为2的i次幂（幂次i不能相同， i &gt; 0）的段不处理 int sum = 0; for (String section : sections) { int len = section.length() + 1; for (int i = Integer.toBinaryString(len).length() - 1; i &gt;= 1; i--) { if ((sum &amp; (1 &lt;&lt; i)) &gt; 0 || len &lt; (1 &lt;&lt; i)) continue; len -= (1 &lt;&lt; i); sum ^= (1 &lt;&lt; i); } } // 判断余下不为2的i次幂（幂次i不能相同， i &gt; 0）的段的和是否为奇数 if ((numLen - sum) % 2 &gt; 0) sum ^= 1; System.out.println(sum); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/03/6676.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E8%BF%90%E7%AE%97%E5%BC%8F%201/"},{"title":"680. 验证回文字符串 Ⅱ","text":"leetcode 680. 验证回文字符串 Ⅱ 题目：633. 平方数之和 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例1: 输入: “aba”输出: True 示例2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 方法一：双指针（对撞指针）思路：双指针（对撞指针） ，一个从头向尾遍历，一个指针从尾向头遍历，循环一次头指针向后移一位，尾指针向前一位。若找到头指针指向的字符不等于尾指针指向的字符时，分为两种情况，一种是删除左指针指向字符，然后再次使用双指针（对撞指针）算法进行遍历判断是否是回文字符串，另一种是删除右指针指向字符，然后再次使用双指针（对撞指针）算法进行遍历判断是否是回文字符串，当有一种情况判断出是回文串时，即为回文字符串。若遍历结束还没有找到头指针指向的字符不等于尾指针指向的字符，即为回文字符串。 运行数据：执行用时：7 ms，内存消耗：40.1 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// LeetCode指定调用方法public boolean validPalindrome(String s) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = s.length() - 1; // 双指针（对撞指针）算法 while (i &lt; j) { if (s.charAt(i) != s.charAt(j)) { // 删除左指针处字符 if (s.charAt(i + 1) == s.charAt(j)) { // l标识头指针位置，r标识尾指针位置 int l = i + 1, r = j; // 标识是否为回文字符串 boolean flag = true; // 双指针（对撞指针）算法 while (l &lt; r) { if (s.charAt(l) != s.charAt(r)) { flag = false; break; } else { l++; r--; } } // 如果是回文则直接返回true if (flag) { return true; } } // 删除右指针处字符 if (s.charAt(i) == s.charAt(j - 1)) { // l标识头指针位置，r标识尾指针位置 int l = i, r = j - 1; // 标识是否为回文字符串 boolean flag = true; // 双指针（对撞指针）算法 while (l &lt; r) { if (s.charAt(l) != s.charAt(r)) { flag = false; break; } else { l++; r--; } } // 如果是回文则直接返回true if (flag) { return true; } } // 如果两种情况都没有返回true，则直接返回false return false; } else { i++; j--; } } return true;} 方法二：双指针（对撞指针）简洁版思路：思路一的简洁版，代码简洁，但执行速度有所下降 运行数据：执行用时：9 ms，内存消耗：39.9 MB 123456789101112131415161718// LeetCode指定调用方法public boolean validPalindrome(String s) { for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(i + 1, j, s) || isPalindrome(i, j - 1, s); } } return true;}public boolean isPalindrome(int i, int j, String s) { for (; i &lt; j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return false; } } return true;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/20/680.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/"},{"title":"69. x 的平方根","text":"leetcode 69. x 的平方根 题目：69. x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例1: 输入: 4输出: 2 示例2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 方法：二分查找思路：通过二分查找寻找寻找小于x的平方根的最大正整数。 运行数据：执行用时：2 ms，内存消耗：38.2 MB 12345678910111213141516171819// LeetCode指定调用方法public int mySqrt(int x) { int l = 0; int r = x; int result = 0; while (l &lt;= r) { int mid = (l + r) / 2; if ((long)mid * mid &gt; x) { r = mid - 1; } else { result = mid; l = mid + 1; } } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/01/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"title":"88. 合并两个有序数组","text":"leetcode 88. 合并两个有序数组 题目：88. 合并两个有序数组 给你两个有序整数数组 nums1 和 nums2*，请你将 *nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 方法：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针指向nums1的尾部，一个指针指向nums2的尾部，从尾到头遍历，比较大小之后将大的一方放入到nums1尾部，指针向前移一格。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 123456789101112131415// LeetCode指定调用方法public void merge(int[] nums1, int m, int[] nums2, int n) { // i标识头nums1指针位置，j标识nums2指针位置 int i = m - 1, j = n - 1; // 双指针（快慢指针）算法 while (j &gt;= 0) { if (i &lt; 0 || nums1[i] &lt; nums2[j]) { nums1[i + j + 1] = nums2[j--]; } else { nums1[i + j + 1] = nums1[i--]; } }} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/22/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"75. 颜色分类","text":"leetcode 75. 颜色分类 题目：75. 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶: 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 方法一：模拟、统计思路：统计红色、白色和蓝色各自的数量，然后根据红色、白色和蓝色的顺序和各自对应的数量，重新赋值nums。 运行数据：执行用时：0 ms，内存消耗：38.1 MB 1234567891011121314151617// LeetCode指定调用方法public void sortColors(int[] nums) { // 统计红色、白色和蓝色各自的数量 int[] count = new int[3]; for (int i : nums) { count[i]++; } // 根据红色、白色和蓝色的顺序和各自对应的数量，重新赋值nums int t = 0; for (int i = 0; i &lt; count.length; i++) { while (count[i]-- &gt; 0) { nums[t++] = i; } }} 方法二：荷兰国旗问题思路：将数组视为红色、白色和蓝色（左、中、右）三个区间，使用三个变量标识区间元素位置，一开始认为整个数组都为白色区间，遍历白色区间，找到不满足白色区间的元素 ，将其与该元素对应区间的标识位置的的元素做交换，直至遍历到蓝色区间，即白色区间遍历结束为止。 运行数据：执行用时：0 ms，内存消耗：38.4 MB 123456789101112131415161718192021222324// LeetCode指定调用方法public void sortColors(int[] nums) { // 红色、白色和蓝色三个区间对应的标识指针 int red = -1, white = 0, blue = nums.length; // 遍历白色区间 while (white &lt; blue) { if (nums[white] == 0) { // 找到不满足白色区间的元素，此时该元素应为红色区间 swap(nums, ++red, white++); } else if (nums[white] == 2) { // 找到不满足白色区间的元素，此时该元素应为蓝色区间 swap(nums, white, --blue); } else { white++; } }}// 交换private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/09/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"},{"title":"763. 划分字母区间","text":"leetcode 763. 划分字母区间 题目：763. 划分字母区间 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例: 输入：S = “ababcbacadefegdehijhklij”输出：[9,7,8]解释: 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 提示: S的长度在[1, 500]之间。 S只包含小写字母 ‘a’ 到 ‘z’ 。 方法一：双指针（对撞指针）思路：双指针（对撞指针），将需要划分的字符串装换成字符数组，从左到右遍历数组，假设遍历的第一个字符为’a’，再从右到左遍历数组，找到’a’最后出现的位置，依次类推找每一个字符的最后出现位置，并记录最远的字符位置，直到从左到右遍历到了当前记录的最远位置，此位置即为第一段字符串的结束位置，接着按照此方法继续找下一段字符串的结束位置。 运行数据：执行用时：10 ms，内存消耗：38.4 MB 123456789101112131415161718192021222324252627282930313233343536373839404142// LeetCode指定调用方法public List&lt;Integer&gt; partitionLabels(String S) { // 记录结果 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 将需要划分的字符串转成字符数组 char[] chars = S.toCharArray(); // 记录字符数组chars的长度 int charsLen = chars.length; // 记录当前这一段字符串最远字符位置 int index = 0; // 记录前一段字符串的结束位置长度 int preStringLength = 0; // 从左到右遍历字符数组 for (int i = 0; i &lt; charsLen; i++) { // 从右到左找从左到右遍历的字符最后出现的位置 for (int j = charsLen - 1; j &gt;= index ; j--) { if (chars[i] == chars[j]) { index = j; break; } } // 从左到右遍历到了当前记录的最远位置 if (i == index) { // 将这一段字符串的结束位置长度减去前一段字符串的结束位置长度即为当前字符串的长度 list.add(index + 1 - preStringLength); // 更新前一段字符串的结束位置长度 preStringLength = index + 1; } } return list;} 方法二：贪心思路：由于字符串都是由小写字母组成，所以可以通过一个循环用一个长度为26的字符数组记录每一个字符的最后出现位置，然后遍历需要划分的字符串，更新当前字符串的结束位置，直到遍历需要划分的字符串到当前这一段字符串的结束位置时，此位置即为这一段字符串的最终结束位置，以此类推继续找下一段字符串。 运行数据：执行用时：2 ms，内存消耗：38 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445// LeetCode指定调用方法public List&lt;Integer&gt; partitionLabels(String S) { // 记录结果 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 将需要划分的字符串转成字符数组 char[] chars = S.toCharArray(); // 记录字符数组chars的长度 int charsLen = chars.length; // 记录每个字符出现的最后位置 int[] lastPosition = new int[26]; // 循环统计每个字符出现的最后位置 for (int i = 0; i &lt; charsLen; i++) { lastPosition[chars[i] - 'a'] = i; } // 记录前一段字符串的结束位置长度 int left = 0; // 记录当前这一段字符串的结束位置长度 int right = 0; // 计算结果 for (int i = 0; i &lt; charsLen; i++) { // 更新当前这一段字符串的结束位置 right = Math.max(right, lastPosition[chars[i] - 'a']); // 当遍历到当前这一段字符串结束位置时，此位置即为这一段字符串的最终结束位置 if (i == right) { // 记录这一段字符串长度 list.add(right + 1 - left); // 更新前一段字符串的结束位置长度 left = right + 1; } } return list;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/30/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"},{"title":"双指针","text":"浅谈双指针算法思想 算法思想双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。 （注：这里的指针并非专指c语言中的指针，表达的含义是下标、索引值或者是可进行迭代的对象等） 对撞指针对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。 快慢指针快慢指针是从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等或满足其他条件为止，如fast每次增长两个，slow每次增长一个。 算法总结对撞指针：可以将两重循环O(n^2)的时间复杂度转化为一重循环O(n)的线性复杂度。一般先想一个暴力O(n^2)的做法，然后找i与j之间的单调关系再进行双指针优化。当遇到有序数组时，应该优先想到用双指针来解决问题，因两个指针的同时遍历会减少空间复杂度和时间复杂度。 快慢指针：利用快慢指针创造的差值, 可节省内存空间, 减少计算次数, 常用于链表数据结构和判断循环。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/14/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"HEXO","text":"HEXO的简单使用 欢迎来到Hexo! 这是您的第一篇文章。查看文档 以获取更多信息。如果在使用Hexo时遇到任何问题，可以在故障排除中 找到答案，也可以在GitHub上问我。 快速开始建立新讯息1$ hexo new \"我的新帖子\" 更多信息：写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/02/HEXO/"},{"title":"第一部分 软件工程概述（二）","text":"郑人杰 《软件工程概论》（第2版）第一部分 软件工程概述（二） 课后习题题解 第二章 软件生存期模型1、瀑布模型、快速原型模型、增量模型及螺旋模型都是传统的软件设计过程模型，请给出各个模型的特点。每种模型的优点和缺点是什么？适合于哪些场合？ 瀑布模型： 特点： 阶段间具有顺序性和依赖性； 具有推迟实现的观点； 具有质量保证的观点。优点： 符合软件开发的思维过程，并容易理解和运用; 通过设置里程碑，可以明确每个阶段的任务和目标； 支持结构化软件开发，可为各阶段制定开发计划，进行成本预算。 通过阶段审核，将开发过程纳入正轨； 严格的计划性保证软件产品的按时交付。缺点： 缺乏灵活性，不能适应用户需求的变化； 开始阶段的小错误会被逐级放大，可能最终导致软件产品报废； 缺乏演化性，返回上一级的开发需要十分昂贵的代价； 随着软件规模和复杂性的增加，软件产品成功的几率大幅下降。适用场合： 用户的需求非常清楚全面，且在开发过程中没有或很少变化； 规模较小的软件开发。 快速原型模型： 特点： 不要求需求预先完备定义； 支持需求的渐进式完善和确认； 支持用户参与，能够适应用户需求的变化。优点： 用户参与软件系统的所有阶段，可以得到比较良好的需求定义，容易适应需求的变化； 用户较早的接触和使用未来的系统，有利于系统后期的使用和维护； 开发费用低、开发周期短且对用户更友好。缺点： 客户与开发者对原型理解不同； 准确的原型设计比较困难； 不利于开发人员的创新。适用场合： 对所开发的领域比较熟悉而且有快速的原型开发工具； 项目招投标时，可以以原型模型作为软件的开发模型； 进行产品移植或升级时，或对已有产品原型进行客户化工作时，原型模型是非常适合的。 增量模型： 特点： 软件产品是被增量式地一块块开发的； 允许开发活动并行和重叠。 采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源； 如果核心产品很受欢迎，则可增加人力实现下一个增量； 可先发布部分功能给客户，对客户起到镇静剂的作用。缺点： 并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构； 增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。适用场合： 进行已有产品升级或新版本开发，增量模型是非常适合的； 对完成期限严格要求的产品，可以使用增量模型； 对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。 螺旋模型： 特点：结合瀑布模型、快速原型模型和迭代模型的思想，并引进了风险分析活动。优点： 设计上的灵活性,可以在项目的各个阶段进行变更； 以小的分段来构建大型系统,使成本计算变得简单容易； 客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性； 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。缺点： 采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失； 过多的迭代次数会增加开发成本，延迟提交时间。适用场合：螺旋模型只适合于大规模的软件项目。 2、如果在要求的期限内软件产品的所有功能都能够开发完成，上述四种模型中应选择哪种模型？如果只能完成一部分功能，又应该选择哪种模型？ 瀑布模型。严格的计划性保证软件产品的按时交付。 快速原型模型。用户参与软件系统的所有阶段，可以得到比较良好的需求定义，容易适应需求的变化。 3、可以合用几种模型吗？如果可以，举例说明。 过程模型可以合用，每个模型都有个有点不同的处理流程，但都执行相同的通用框架活动集：沟通，规划，建模，施工和交付/反馈。例如线性顺序模型可以作为一个有用的过程模型，沟通，规划，建模，施工和交付/反馈。例如线性顺序模型可以作为一个有用的过程模型，在被固定的情况下，要求工作以线性的方式继续进行，直至完成。在这情况下，开发者可能无法确定一种算法的效率，一个操作系统的适应性或应采取的人机交互的形式。在这之中，以及许多其他场合原型模型可以提供最好的办法。在其他情况下，以渐进的方式可能是有意义的和螺旋模型的流动可能是有效率，特殊过程模型具有许多的一个或多个传统的特性。 4、解释喷泉模型的特点及其适用的场合。 特点： 各阶段相互重叠，它反映了软件过程并行性的特点； 体现认识事物的往返过程； 强调增量开发，整个过程是一个迭代的逐步提炼的过程； 开发活动之间的无间隙性和循环迭代性； 适用于面向对象的开发过程。 强调无明显的活动阶段划分。适用场景：主要用于面向对象技术的软件开发项目，它克服了瀑布模型不支持软件重用和多项目开发活动集成的局限性，喷泉模型使开发过程具有迭代性和无间隙性。 5、统一过程与UML是同一概念吗？请给出解释。 统一过程与UML不是同一概念。 UML是一种语言，统一过程是用UML进行面向对象软件工程对的框架。 6、统一过程的6个核心过程工作流是什么？ 业务建模工作流； 需求工作流； 分析与设计工作流； 实现工作流； 测试工作流； 部署工作流。 7、给出两个核心支持工作流。 配置与变更管理； 项目管理。 8、统一过程的4个阶段是什么？ 初始阶段； 细化阶段； 构造阶段； 移交阶段。 9、请解释为什么基于构件的软件开发能够极大地提高软件开发的生产率和软件质量。 软件的复用是提高软件生产效率及软件质量的最有效途径，而基于构件的软件开发比面向对象的软件开发实现了更大粒度的软件复用，能够最大限度地减少重复劳动、缩短开发周期、降低开发成本，从而使软件生存率得到提高。由于已有的构件大都经过了很长时间的运行和测试，在质量方面比新开发的软件更有保证，同事软件架构技术有助于软件设计的标准化和设计风格的改进和统一，进而提高系统间的互操作性，软件可靠性和可维护性可以得到增强。 10、敏捷软件开发的特点是什么？ 迭代式开发。整个开发过程被分为几个迭代周期，每个迭代期是一个定长或不定长的时间块，每个迭代周期持续的时间一般较短，通常为1~6周。 增量交付。产品在每个迭代周期结束时被逐步交付使用，而不是在整个开发过程结束时一次性交付。每次交付的都是可被部署到用户应用环境中的、能给用户带来即时效益和价值的产品。 开发团队和用户反馈推动产品开发。敏捷开发方法主张用户能够全程参与整个开发过程。这使需求变化和用户反馈能动态管理并及时集成到产品中。同时，团队也能及时对用户的需求提供反馈意见。 持续集成。新的功能或需求变化总是尽可能频繁地被整合到产品中。一些项目是在每个迭代周期结束的时候集成，有些项目则每天都在集成。 开发团队自我管理。拥有一个积极的、自我管理的、具备自由交流风格的开发团队，是每个敏捷项目的必要条件。敏捷开发总是以人为中心建立开发的过程和机制，而非把过程和机制强加给人。 11、简述敏捷软件开发的原则。 持续、尽早交付有价值的软件以满足用户，是我们优先要做的首要任务。 拥抱需求变更，甚至是在开发的后期。敏捷过程利用变更为客户带来竞争优势。 频繁交付可执行的软件，从几周到几个月，交付时间越短越好。 在整个项目过程中，业务人员和开发人员必须每天一起工作。 激发每个团队成员的积极性来打造项目。为他们提供环境与支持，并且信任他们可以完成工作。 在一个开发团队内部最有效的传递信息的方式是面对面交流。 可执行的软件是进度的首要检验对象。 敏捷过程倡导可持续发展。赞助商、开发人员和用户用该尽可能保持一致的步伐。 不断地关注优秀技能和好的设计会增强敏捷能力。 尽量用艺术化来简单阐述未完成的工作是很有必要的。 最好的架构、需求和设计出自于自我组织管理的团队。 每隔一段时间，回顾反思如何让团队变得更高效，并相应地调整其行为。 12、用自己的语言描述XP的重构和结对编程的概念。 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。这是一种净化代码以尽可能减少引入错误的严格方法。实质上，重构就是在编码完成之后改进代码设计。 结对编程是这样一种程序设计实践：两名程序员并肩同坐在同一台计算机前，共同探讨设计方案、共同设计算法、共同编写程序代码、共同完成各种测试。 13、你认为本书所讲的哪种过程模型适合互联网软件的开发及维护？还是都不合适？ 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/04/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"第一章 Java语言概述","text":"Java语言概述 1、基础常识 软件，及一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 人机交互方式 图形化界面 命令行方式 常用Dos命令 dir ：列出当前目录下的文件以及文件夹md ：创建目录rd ：删除目录cd ：进入指定目录cd.. ：退回到上一级目录cd\\ ：退回到根目录del ：删除文件exit ：退出dos命令行 2、Java语言概述 计算机语言：人与计算机交流的方式。 第一代语言 打孔机–纯机器语言 第二代语言 汇编 第三代语言平台 C、Pascal、Fortran面向过程的语言 C++面向过程/面向对象 Java跨平台的纯面向对象的语言 .NET跨语言的 面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 Java语言的诞生、特点 java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了 C++语言面向对象技术的核心。Java舍弃了C语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承（以接口取代）等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程（Generic Programming）、类型安全的枚举、不定长参数和自动装/拆箱 Java语言概述 是SUN(Stanford University Network，斯坦福大学网络公司)1995年推出的一门高级编程语言。 95年，SUN发布JDK 1.0，98年，JDK1.2，后续JDK1.3， 1.4，1.5（更名为Java5.0）最新为JDK13。 是一种面向Internet的编程语言。 随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 java语言的主要特性 Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。 Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。 Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。 Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。 Java语言是跨平台的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的跨平台的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。 Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。 Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。 Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 Java的应用领域 企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。 Android平台应用：Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。 嵌入式应用：是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。 3、Java语言运行机制及运行过程Java两种核心机制 Java虚拟机（Java Virtal Machine），JVM 垃圾收集机制（Garbage Collection），GC Java虚拟机 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 对于不同的平台，有不同的虚拟机。 Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 垃圾回收 不再使用的内存空间应回收—— 垃圾回收。 在C/C++等语言中，由程序员负责回收无用内存。 Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 4、Java语言的环境搭建下载、安装JDK 官方网址： https://www.oracle.com/technetwork/java/javase/downloads/index.html 安装JDK 傻瓜式安装，下一步即可。 建议：安装路径不要有中文或者特殊符号如空格等。 当提示安装 JRE 时，可以选择不安装。 推荐安装 链接：https://pan.baidu.com/s/1Yo0TmmvqcPAg3RTUPrY75g 提取码：d6zc 直接下载需要的对应版本压缩包，方便在需要使用多个版本jdk时的切换。 配置环境变量 新建系统变量JAVA_HOME 解压jdk的目录（如“D:\\Learn\\java\\jdk1.8.0_102”） 在系统变量Path中新建 %JAVA_HOME%\\bin 验证是否成功 命令行输入命令：java -version 什么是JDK，JRE JDK(Java Development Kit Java开发工具包) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JRE(Java Runtime Environment Java运行环境) 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。 JVM、JRE、JDK 关系 5、HelloWorld步骤： 将 Java 代码编写到扩展名为 .java 的文件中。 通过 javac 命令对该 java 文件进行编译。 通过 java 命令对生成的 class 文件进行运行。 步骤一：编写 选择最简单的编辑器：记事本。 敲入代码 将文件保存成HelloWorld.java，这个文件是存放java代码的文件，称为源文件。 12345public class HelloWorld{ public static void main(String args[]){ System.out.println(\"Hello World\"); }} 步骤二：编译 有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。 在该源文件目录下，通过javac编译工具对HelloWorld.java文件进行编译。 如果程序没有错误，没有任何提示，但在当前目录下会出现一个HelloWorld.class文件，该文件称为字节码文件，也是可以执行的java的程序。 步骤三：运行 有了可执行的java程序(HelloWorld.class字节码文件) 通过运行工具java.exe对字节码文件进行执行。 6、小结第一个程序 Java源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本类中的HelloWorld类。 Java应用程序的执行入口是main()方法。它有固定的书写格式：public static void main(String[] args) {…} Java语言严格区分大小写。 Java方法由一条条语句构成，每个语句以“;”结束。 括号都是成对出现的，缺一不可。 7、常见问题及解决方法 源文件名不存在或者写错，或者当前路径错误。 类文件名写错，或者类文件不在当前路径下，或者环境变量没有配置好。 声明为public的主类应与文件名一致，否知编译失败 编译失败，注意错误出现的行数，再到源代码中指定位置改错 8、注 释 用于注解说明解释程序的文字就是注释。 提高了代码的阅读性；调试程序的重要方法。 注释是一个程序员必须要具有的良好编程习惯。 将自己的思想通过注释先整理出来，再用代码去体现 Java中的注释类型： 单行注释 // 多行注释/* */ 文档注释（java特有） 单行注释1//注释文字 多行注释1/* 注释文字 */ 文档注释（java特有）12345/** * @author 指定java程序的作者 * @version 指定源文件的版本 * @param 方法的参数说明信息 */ 注： 对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。 多行注释里面不允许有多行注释嵌套。 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 来自b站 求知讲堂小龙https://www.bilibili.com/video/av76235341?p=1学习所得，资料参考其所讲内容，图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"},{"title":"第一部分 软件工程概述（一）","text":"郑人杰 《软件工程概论》（第2版）第一部分 软件工程概述（一） 课后习题题解 第一章 软件与软件工程的概念1、举出你所知道的传统应用软件的例子。 办公软件、游戏软件、财务软件、银行软件、人事管理软件、学籍管理软件等。 2、“软件就是程序，软件开发就是编程序。”这种观点是否正确？为什么？ 认为“软件就是程序，软件开发就是编程序。”这种观点是错误的。 首先，软件是计算机系统中与硬件相互依存的另一部分，它包括程序、数据、及其相关文档的完整集合，程序只是软件的组成部分之一；其次，在软件开发中，编程只是软件开发过程中的一个阶段。 3、如果将软件开发比作高楼大厦的建造，可以将软件设计比做什么？ 可以将软件的设计比作建筑设计，软件设计的成果相当于建筑设计的图纸。 4、简述软件的分类，并举例说明。 在《软件工程概论》第2版中，按照软件的作用，将软件分为系统软件、应用软件、支撑软件、可复用软件4类。 系统软件：系统软件居于计算机系统中最靠近硬件的一层，其他软件一般通过系统软件发挥作用。系统软件与具体的应用领域无关。例如：操作系统、设备驱动程序、通信和网络处理程序。 应用软件：应用软件是特定应用领域专用的软件。例如：工程、科学计算软件、Web应用软件、人工智能软件。 支撑软件：支撑软件是支撑软件开发和维护的软件。例如：网络软件、软件工具、软件开发环境。 可复用软件：在开发新的软件时，可以对已有的可复用构件稍加修改或不加修改，复用所需的属性或服务。例如：各种标准函数库。 5、请给出你所知道的互联网应用软件的例子。传统应用软件与互联网应用软件有哪些不同之处？ 与传统软件较长的软件生存周期相比，互联网软件的软件生存周期更短，要求开发者想办法在较短的时间内完成计划、分析、设计、编码、测试，及时向用户发布； 与传统软件不同，一个互联网软件一般都有许多许多用户在同一时间访问，要求互联网软件能应对数量不明确的用户的访问和请求，支持并发； 传统软件可能需要针对不同的应用平台发布不同的软件版本让不同平台上的用户能够使用，而互联网软件则能让不同平台用户能够通过Web浏览器方便地使用； 不同于传统的、按一系列规划的时间间隔发布并进行演化的应用软件，互联网软件应不断地进行演化； 互联网软件依赖于网络而存在，需要服务变化多样的客户群。它需要一定程度上的互联网的支持才能够正常运行，而且网络状况的好坏也对互联网软件的运行有着较大的影响； 互联网软件是通过网络访问可达的，因此要限制终端用户的使用就比较困难。要保护软件的安全和稳定就必须采取有效的安全措施。 6、什么是软件危机？它有哪些典型表现？为什么会出现软件危机？ 软件危机是指计算机软件开发、使用与维护过程中所遇到的一系列严重问题和难题。 典型表现有： 对软件开发成本和进度的估计常常很不准确； 软件产品的质量往往靠不住； 用户对已完成的软件系统不满意的现象经常发生； 软件常常是不可维护的； 软件中没有适当的文档资料； 软件成本在计算机系统总成本所占的比例逐年上升； 软件开发生产率提高的速度，往往跟不上计算机应用迅速普及深入的趋势。 原因： 软件本身独有的特点确实给开发和维护带来了困难； 与软件开发和维护的许多错误认识和做法的形成有关； 面对日益增长的软件需求，人们显得力不从心。 7、什么是软件工程？软件工程要解决核心问题是什么？ 应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、发布和维护的工程或进行研究的学科。 以较短的周期、较低的成本生产出高质量的软件产品，并最终实现软件的工业化生产。 8、简述软件生存期有哪些主要阶段组成，每个阶段的主要任务是什么？ 问题定义与可行性研究：问题定义必须回答的关键问题是：“要解决的问题是什么”。可行性研究要回答的关键问题是：“在成本和时间的限制条件下能否解决问题？是否值得做？”。需求分析：这个阶段的任务仍然不是具体地解决客户的问题，而是准确的回答“目标系统必须做什么”这个问题。软件设计：本阶段要回答的关键问题是“目标系统如何做？”为此，必须在设计阶段中制定设计方案，把已确定的各项需求转换成相应的软件体系架构。结构中的每一组成部分都是有意义明确的构件，此即所谓概要设计。进而具体描述每个构件所要完成的工作，为源程序编写打下基础，此即所谓详细设计。程序编码和单元测试：本阶段要解决的问题是“正确地实现已做的设计”，为此，需要选择合适的编程语言，把软件设计转换成计算机可以接受的程序代码，并对程序结构中的各个模块进行单元测试，然后运用调试的手段排除测试中发现的错误。集成测试和系统测试：集成测试的任务是将已测试过的模块按设计规定的顺序组装起来，在组装的过程中检查程序连接的问题。系统测试的任务是根据需求规格说明的要求，对必须实现的各项需求，逐项进行确认，判定已开发的软件是否符合用户需求，能否交付用户使用。运行维护：已交付的软件投入正式使用，便进入运行维护阶段。这一阶段可能持续若干年。软件在运行中可能由于多方面的原因，需要对它进行维护。通常有四种类型的维护：改正性维护、适应性维护、完善性维护和预防性维护。 9、区分单元测试、集成测试和系统测试。 10、软件工程的三种基本要素是什么？各自什么作用？ 方法、工具和过程。 软件工程方法为建造软件提供技术上的解决方法； 工具为方法的运用提供自动或半自动的软件支撑环境； 过程是获得高质量软件所需完成的一系列人物的框架，它规定了完成各项任务的工作步骤。 11、简述传统方法和面向对象方法的特点。 传统方法： 传统方法也称为生命周期方法或结构化范型。 它采用结构化技术来完成软件开发的各项任务。每一个阶段的开始和结束都有严格的标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段开始的标准。 传统方法的主要缺点是在适应需求变化方面不够灵活，另外，结构化方法要么面向行为，要么面向数据，缺乏使两者有机结合的机制。 面向对象方法的特点： 面向对象方法把数据和行为看成同等重要，是将数据核对数据的操作紧密地结合起来的方法，这也是面向对象方法与传统方法的重要区别。 面向对象方法的出发点和原则，是尽量模拟人类西噶UN的思维方式，是开发软件的方法和过程尽可能接近人类认识问题和解决问题的方法与过程，从而使描述问题空间与其解空间在结构上尽可能一致。 对于大型、复杂及交互操作比较强的系统，使用面向对象方法更具优势。 12、形式化方法的特点是什么？ 形式化方法的特点： 软件需求规格说明被细化为用数学记号表达的详细的形式化规格说明。 设计、实现和单元测试等开发过程由一个变换开发过程代替。通过一系列变换将形式的规格说明细化成为程序。 13、软件开发过程中的常用软件有哪些？ 需求分析和设计工具。如：Rational Rose、Microsoft Office Visio等。 编码工具与排错工具。如：Visual C++ 6.0、Eclipse等。 测试工具。如：xUnit、IBM Rational Functional Tester、IBM Rational Robot等。 14、在软件工程知识体系中，将软件工程划分划分为哪些知识域？ SWEBOK指南将软件工程体系划分为15个知识域，这些知识域又划分为三类： 软件工程基础类：软件工程经济学、计算基础、工程基础、数学基础。 软件生存期过程类：软件工程模型和方法、软件需求、软件设计、软件构造、软件测试、软件维护。 软件工程管理类：软件工程过程、软件工程管理、软件配置管理、软件质量、软件工程专业实践。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/03/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"第二部分 结构化分析与设计方法（一）","text":"郑人杰 《软件工程概论》（第2版）第二部分 结构化分析与设计方法（一） 课后习题题解 第三章 软件需求获取与结构化分析方法1、顶层数据流图（或称环境图）的作用是什么？ 顶层数据流图（或称环境图）仅包括一个数据处理过程，也就是要开发的目标系统。其作用如下： 确定系统在其环境中的位置，与系统有联系的外部实体（包括硬件、软件、组织机构及人）有哪些。 通过确定系统的输入和输出与外部实体的关系确定系统的边界，也就是要确定哪些功能或处理属于系统范围之内，哪些属于系统范围之外，需要由其他系统处理或人工处理。 2、简述使用数据流图进行需求分析的过程。 （1）确定系统的输入输出由于系统究竟包括哪些功能可能一时难于弄清楚，可使范围尽量大一些，把可能有的内容全部都包括进去。此时，应该向用户了解“系统从外界接受什么数据”、“系统向外界送出什么数据”等信息，然后，根据用户的答复画出数据流图的外围。（2）由外向里画系统的顶层数据流图首先，将系统的输入数据和输出数据用一连串的加工连接起来。在数据流的值发生变化的地方就是一个加工。接着，给各个加工命名。然后，给加工之间的数据命名。最后，给文件命名。（3）自顶向下逐层分解，绘出分层数据流图对于大型的系统，为了控制复杂性，便于理解，需要采用自顶向下逐层分解的方法进行，即用分层的方法将一个数据流图分解成几个数据流图来分别表示 [1] 。 3、在对数据流图进行分解时需要注意哪些问题？ 在对数据流图进行分解时，需要注意以下两个问题： 当对数据流图分层细化时必须保持信息连续性，也就是说，当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。 注意分层细化时对编号的处理方法。 4、请根据以下描述画出某库存管理系统的数据流图。该系统的数据流描述如下：（1）根据计划部门转来的收货通知单和已存在的物资编码文件，建立物资采购单流水账。（2）根据技术部门的物资验收报告和物资采购单流水账，更新物资台账文件。（3）对物资台账分类汇总，将结果存储于物资总账文件中。（4）物资出库，物资使用部门填写物资出库单，包括物资编号、物资名称、物资数量、物资使用部分、负责人、经手人。系统根据物资总账文件的库存情况判断是否能够出库，如果能够出库，则记录出库单，并更新物资总账文件。 5、分析院系、专业、班级、课程、教师、学生、成绩之间的数据关系，画出ER图。 若以选课系统为基础，可做如下分析： 一个院系设置多个专业 一个院系拥有多个教师 一个专业由多个班级组成 一个专业开设多门课程，一门课程可由多个专业开设 一个教师教授多门课程，一门课程可由多个教师教授 一个学生选修多门课程，一门课程可让多个学生选修，每个学生选修的每一门课程都会产生一个成绩 一个班级属于多个学生 依据上述分析得出如下ER图： 6、一家书店计划开发图书管理系统对书店的业务进行管理，以提高管理人员及书店工作人员的工作效率，并方便顾客对图书进行检索，书店管理系统的基本功能需求如下：（1）采购管理：实现与供货商的图书采购、退货及结算管理，提供月统计报表及任意时间段的统计报表。（2）图书信息管理：记录每种图书的信息（包括ISBN号、书名、作者、出版社、出版日期、单价、版次、印次等）、折扣及库存量，并提供简单的图书查询功能。（3）销售管理：实现图书销售功能，记录顾客购买的图书种类、数量，计算总价，打印销售小票，并付款。提供日/月统计报表及任意时间段的统计报表。（4）用户管理：提供用户组（角色）及用户管理功能。针对上面的需求建立需求分析模型，包括数据流图（至少画出两层）和ER图。 7、试题库管理系统的相关人员包括题库维护人员、教师及学生。系统的基本功能需求描述如下：（1）题库维护人员负责试题的添加、修改、删除工作。试题信息包括试题编号、试题内容、试题类型、参考答案、分值等。其中，试题类型包括选择题、判断题、填空题、应用题。（2）给教师提供自动组卷、手动组卷及打印试卷功能，教师可以指定试卷分值，并选择是否保存试卷。（3）给学生提供随机组卷，在线练习、在线评价功能。针对上面的需求建立需求分析模型，包括数据流图、ER图。针对为学生提供的功能，画出系统的状态图。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/05/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"2019 年百度之星·程序设计大赛 - 初赛二","slug":"2019-年百度之星·程序设计大赛-初赛二","link":"/tags/2019-%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%88%9D%E8%B5%9B%E4%BA%8C/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java SE","slug":"Java-SE","link":"/tags/Java-SE/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"HDOJ","slug":"HDOJ","link":"/categories/HDOJ/"},{"name":"算法思想","slug":"算法思想","link":"/categories/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}