{"pages":[{"title":"关于","text":"Crazy-Sky软件工程专业学生一枚本博客专注于学习记录以及技术分享","link":"/about/index.html"}],"posts":[{"title":"122. 买卖股票的最佳时机 II","text":"leetcode 122. 买卖股票的最佳时机 II 题目：122. 买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示: 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 方法：贪心思路：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。 运行数据：执行用时：1 ms，内存消耗：39.9 MB 123456789101112131415// LeetCode指定调用方法public int maxProfit(int[] prices) { int len = prices.length; if (len == 0 || len == 1) return 0; int profit = 0; for (int i = 1; i &lt; len; i++) { if (prices[i] &gt; prices[i - 1]) { profit += (prices[i] - prices[i - 1]); } } return profit;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/21/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"},{"title":"1. A + B","text":"XMOJ 1. A + B 题目：1. A + B 描述: 和所有的 OJ 平台一样，第一题作为热身题，也是送分题：给出两个非负数 a 和 b，输出 a+b 的结果。 输入: 多组输入。 包含两个非负数 a 和 b，以空格分隔；a 和 b 保证小于 2^32。 输出: 你的输出是对一行数据处理的结果，也即 a+b 的结果。 输入样例: 233 666123 0 输出样例: 899123 方法：模拟思路：注意数据范围，a 和 b 保证小于 2^32，即a,b &lt; 2^32，java中int的最大范围为2^31 - 1，所以本题需用long。 运行数据：最大执行时间：87.83 ms，内存消耗：17332 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(1)。 空间复杂度：O(1)。 123456789101112131415161718import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNextLine()) { line = scan.nextLine().trim(); long sum = 0; for (String str : line.split(\" \")) { long a = Long.parseLong(str); sum = sum + a; } System.out.println(sum); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/01/1.%20A%20+%20B/"},{"title":"1091. 二进制矩阵中的最短路径","text":"leetcode 1091. 二进制矩阵中的最短路径 题目：1091. 二进制矩阵中的最短路径 在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。 一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, …, C_k 组成： 相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角） C_1 位于 (0, 0)（即，值为 grid[0][0]） C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]） 如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0） 返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。 示例1: 输入：[[0,1],[1,0]] 输出：2 示例2: 输入：[[0,0,0],[1,1,0],[1,1,0]] 输出：4 提示: 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 为 0 或 1 方法：BFS（广度优先搜索）思路：BFS（广度优先搜索），最先搜索到终点的路径长度，即为最短路径长度。 运行数据：执行用时：15 ms，内存消耗：41.4 MB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// LeetCode指定调用方法public int shortestPathBinaryMatrix(int[][] grid) { // 记录网格的行、列长度 int row = grid.length; int col = grid[0].length; // 如果起点或者终点阻塞，则永远到不了终点，直接返回-1 if(grid[0][0] == 1 || grid[row - 1][col - 1] == 1) { return -1; } // 如果起点即为终点，且该点不阻塞则直接返回1 if (row - 1 == 0 &amp;&amp; col - 1 == 0) { return 1; } // 可以移动的八个方向 int[][] directions = {{0,1}, {0, -1}, {1, -1}, {1, 0}, {1, 1}, {-1, -1}, {-1, 0}, {-1, 1}}; // 用于BFS的队列 Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); // 将起点入队 queue.offer(new int[]{0,0}); // 标记当前长度 grid[0][0] = 1; // 记录当前队列的长度，当队列为空时，BFS全部搜索结束（用以代替 queue.isEmpty() 增加每次循环判断时的效率） int queueLen = 1; while(queueLen-- != 0){ // 将队列中第一个位置出队 int[] position = queue.poll(); // 记录到前位置的路径长度 int preLen = grid[position[0]][position[1]]; // 遍历八个方向，向八个方向扩展 for(int i = 0; i &lt; 8; i++){ // 记录扩展位置 int currentRow = position[0] + directions[i][0]; int currentCol = position[1] + directions[i][1]; // 判断能否向这个方向扩展 if(currentRow &gt;= 0 &amp;&amp; currentRow &lt; row &amp;&amp; currentCol &gt;= 0 &amp;&amp; currentCol &lt; col &amp;&amp; grid[currentRow][currentCol] == 0){ // 标记到扩展位置的路径长度 grid[currentRow][currentCol] = preLen + 1; // 判断是否已到达终点 if (currentRow == row - 1 &amp;&amp; currentCol == col - 1) { return grid[row - 1][col - 1]; } // 将扩展位置入队 queue.offer(new int[]{currentRow, currentCol}); // 更新当前队列长度 queueLen++; } } } return -1;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/17/1091.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"title":"121. 买卖股票的最佳时机","text":"leetcode 121. 买卖股票的最佳时机 题目：121. 买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意: 你不能在买入股票前卖出股票。 示例1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法：贪心思路：记录前面的最小股票价格，遍历数组以当前股价为出售价格，记录比较得出当前最大利润，遍历完的最大利润即为结果 运行数据：执行用时：1 ms，内存消耗：39.7 MB 12345678910111213141516171819// LeetCode指定调用方法public int maxProfit(int[] prices) { int len = prices.length; if (len == 0 || len == 1) return 0; int maxProfit = 0;; // 记录最大利润 int minPrice = prices[0]; // 记录最小股票价格 for (int i = 1; i &lt; len; i++) { if (minPrice == prices[i]) continue; // 如果当前股票价格与当前最小股票价格相等则跳过 if (minPrice &gt; prices[i]) { // 如果当前的股票价格比当前最小股票价格还小，更新当前最小股票价格 minPrice = prices[i]; } else { // 如果当前的股票价格比当前最小股票价格大，比较此时利润是否大于当前最大利润，更新当前最大利润 maxProfit = Math.max(maxProfit, prices[i] - minPrice); } } return maxProfit;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/19/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"},{"title":"1143. 最长公共子序列","text":"leetcode 1143. 最长公共子序列 题目：1143. 最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例1: 输入：text1 = “abcde”, text2 = “ace”输出: 3解释：最长公共子序列是 “ace”，它的长度为 3。 示例2: 输入：text1 = “abc”, text2 = “abc”输出: 3解释：最长公共子序列是 “abc”，它的长度为 3。 示例3: 输入：text1 = “abc”, text2 = “def”输出: 0解释：两个字符串没有公共子序列，返回 0。 提示: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 输入的字符串只含有小写英文字符。 方法一：动态规划思路：动态规划。状态转移方程为：dp[i][j] = dp[i - 1][j - 1] + 1;（text1.charAt(i - 1) == text2.charAt(j - 1)）。dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);（text1.charAt(i - 1) != text2.charAt(j - 1)）。dp[i][j]表示text1前i个字符和text2的前j个字符的最长公共子序列。 运行数据：执行用时：12 ms，内存消耗：42.2 MB 复杂度分析： 时间复杂度：O(n * m)，n为text1的长度，m为text2的长度。 空间复杂度：O(n * m)，n为text1的长度，m为text2的长度。 1234567891011121314151617181920// LeetCode指定调用方法 public int longestCommonSubsequence(String text1, String text2) { int n = text1.length(); int m = text2.length(); int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[n][m];} 方法二：优化动态规划思路：优化动态规划。在思路一的基础上将dp的二维数组空间消耗，压缩成一维数组。 运行数据：执行用时：11 ms，内存消耗：36.8 MB 复杂度分析： 时间复杂度：O(n * m)，n为text1的长度，m为text2的长度。 空间复杂度：O(m)，m为text2的长度。 123456789101112131415161718192021222324// LeetCode指定调用方法 public int longestCommonSubsequence(String text1, String text2) { int n = text1.length(); int m = text2.length(); int[] dp = new int[m + 1]; int temp1 = 0, temp2 = 0; for (int i = 1; i &lt;= n; i++) { temp1 = 0; for (int j = 1; j &lt;= m; j++) { temp2 = dp[j]; if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[j] = temp1 + 1; } else { dp[j] = Math.max(dp[j], dp[j - 1]); } temp1 = temp2; } } return dp[m];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/13/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"130. 被围绕的区域","text":"leetcode 130. 被围绕的区域 题目：130. 被围绕的区域 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: X X X XX O O XX X O XX O X X输出: 2 运行你的函数后，矩阵变为： X X X XX X X XX X X XX O X X *解释: * 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。 如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 方法：DFS（深度优先搜索）思路：DFS（深度优先搜索），通过DFS将所有没有被 ‘X’ 围绕的区域的所有’O’修改为’T’，此时矩阵中剩余的’O’都是被’X’ 围绕的，然后通过遍历矩阵将所有的’O’修改为’X’,将所有的’T’修改为’O’,即可得到所求结果。 运行数据：执行用时：2 ms，内存消耗：41.9 MB 复杂度分析： 时间复杂度：O(n * m)，其中 n 和 m 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。 空间复杂度：O(n * m)，其中 n 和 m 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// LeetCode指定调用方法 public void solve(char[][] board) { if (board == null || board.length == 0) { return; } int m = board.length; int n = board[0].length; // 通过DFS将所有没有被 'X' 围绕的区域的所有'O'修改为'T' for (int i = 0; i &lt; n; i++) { if (board[0][i] == 'O') { dfs(board, 0, i); } if (board[m - 1][i] == 'O') { dfs(board, m - 1, i); } } for (int i = 1; i &lt; m - 1; i++) { if (board[i][0] == 'O') { dfs(board, i, 0); } if (board[i][n - 1] == 'O') { dfs(board, i, n - 1); } } // 通过遍历矩阵将所有的'O'修改为'X',将所有的'T'修改为'O',即可得到所求结果 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (board[i][j] == 'T') { board[i][j] = 'O'; } else if (board[i][j] == 'O') { board[i][j] = 'X'; } } }}// DFSprivate void dfs(char[][] board, int a, int b) { if (a &lt; 0 || b &lt; 0 || a &gt;= board.length || b &gt;= board[0].length || board[a][b] != 'O') { return ; } board[a][b] = 'T'; dfs(board, a + 1, b); dfs(board, a - 1, b); dfs(board, a, b + 1); dfs(board, a, b - 1);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/28/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"},{"title":"153. 寻找旋转排序数组中的最小值","text":"leetcode 153. 寻找旋转排序数组中的最小值 题目：153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例1: 输入: [3,4,5,1,2]输出: 1 示例2: 输入: [4,5,6,7,0,1,2]输出: 0 方法：二分查找思路：通过二分查找缩小区间查找，每次缩小一半，如果中间的元素小于或等于右边界元素则将右边界往中间移（由于此时中间元素可能是唯一的最小元素所以直接将右边界移至中间即可），否则将左边界往中间移（此时中间元素不可能是唯一的最小元，所以可将左边界移至中间加1元素处），当左边界等于右边界时，此元素即为最小元素。 运行数据：执行用时：0 ms，内存消耗：39.3 MB 1234567891011121314151617// LeetCode指定调用方法public int findMin(int[] nums) { int l = 0; int r = nums.length - 1; while (l &lt; r) { int mid = l + (r - l) / 2; if (nums[mid] &lt;= nums[r]) { r = mid; } else { l = mid + 1; } } return nums[l];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/09/153.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"title":"131. 分割回文串","text":"leetcode 131. 分割回文串 题目：131. 分割回文串 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 说明: 所有数字都是正整数。 解集不能包含重复的组合。 示例: 输入: “aab”输出:[ [“aa”,”b”], [“a”,”a”,”b”]] 方法：Backtracking（回溯）思路：Backtracking（回溯），通过递归回溯前判断当前截取字符串是否是回文串对程序进行剪枝。运行数据：执行用时：3 ms，内存消耗：40.4 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为9，最坏情况分割字符的时间复杂度为O(2^n)，判断回文串的时间复杂度为O(n)。 空间复杂度：O(n)，n为s的长度，回溯递归时保存临时组合。 123456789101112131415161718192021222324252627282930313233343536373839// LeetCode指定调用方法 public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;(); backtracking(s, result, new ArrayList&lt;&gt;()); return result;}// 回溯private void backtracking(String s, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; tempList) { if (s.length() == 0) { result.add(new ArrayList&lt;&gt;(tempList)); return ; } for (int i = 0; i &lt; s.length(); i++) { if (isPalindromeString(s, 0, i)) { tempList.add(s.substring(0, i + 1)); backtracking(s.substring(i + 1), result, tempList); tempList.remove(tempList.size() - 1); } }}// 判断回文串private boolean isPalindromeString(String str, int start, int end) { while (start &lt; end) { if (str.charAt(start++) != str.charAt(end--)) { return false; } } return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/20/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"title":"167. 两数之和 II - 输入有序数组","text":"leetcode 167. 两数之和 II - 输入有序数组 题目：167. 两数之和 II - 输入有序数组 给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9。因此 index1 = 1, index2 = 2 。 方法一：数学组合思路：数学组合 C(numbers.length,2)，遍历所有组合，找出符合条件的组合。 运行数据：执行用时：376 ms，内存消耗：40MB 123456789101112131415161718// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // 用于存储结果 int result[] = new int[2]; // 遍历所有组合 for (int i = 0; i &lt; numbers.length - 1; i++) { for (int j = i + 1; j &lt; numbers.length; j++) { if (numbers[i] + numbers[j] == target) { result[0] = i + 1; result[1] = j + 1; } } } return result;} 方法二：双指针 （对撞指针）思路：输入数组为有序数组，从题中可以看出数组是从小到大排列，所以使用双指针（对撞指针），一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。如果两元素之和等于target，则得出结果。如果两元素之和大于target，则指向较小元素的指针右移；否则相反。 运行数据：执行用时：1 ms，内存消耗：40MB 1234567891011121314151617181920// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = numbers.length - 1; // 双指针（对撞指针）算法 while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[] { i + 1, j + 1 }; } else if (sum &lt; target) { i++; } else { j--; } } return null;} 方法三：双指针（对撞指针）+折半查找思路：在思路二的基础上，判断最小数组元素是否为非负整数，是则说明数组全为非负整数，此时可用折半查找确定双指针（对撞指针）遍历的右侧指针的初始位置，从而减少遍历次数。另外判断数组最大值是否大于target，否则没必要使用折半查找。 运行数据：执行用时：0 ms，内存消耗：39.4MB 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法public int[] twoSum(int[] numbers, int target) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = numbers.length - 1; // 判断数组是否全为非负整数，判断数组最大值是否大于目标数，都满足则进行折半查找 if (numbers[i] &gt;= 0 &amp;&amp; numbers[j] &gt; target) { int left = 0, mid = 0, right = j; while (left &lt;= right) { mid = (left + right) &gt;&gt; 1; if (target == numbers[mid]) { break; } else if (target &lt; numbers[mid]) { right = mid - 1; } else { left = mid + 1; } } j = mid; } // 双指针（对撞指针）算法 while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[] { i + 1, j + 1 }; } else if (sum &lt; target) { i++; } else { j--; } } return null;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/12/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"1576. A/B","text":"HDOJ 1576. A/B 题目：1576. A/B 问题描述： 要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。 输入： 数据的第一行是一个T，表示有T组数据。每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。 输出： 对应每组数据输出(A/B)%9973。 样本输入： 21000 5387 123456789 样本输出： 79226060 方法：扩展欧几里得思路：令m = 9973，inv(a)表示a关于m的逆元，根据题意可得 (A / B) % m = ((n + k * m) * inv(B)) % m = ((n + k * m) % m) * (inv(B) % m) = (n % MOD) * (inv(B) % MOD) = n * inv(B) % m。所以只需求n * inv(B) % m的值即可。本题使用扩展欧几里得求逆元。 运行数据：执行用时：249MS，内存消耗：9316K 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); long m= 9973; while (T-- &gt; 0) { long n = sc.nextLong(); long B = sc.nextLong(); long result = n * inv(B) % m; System.out.println(result); } } private static long x,y; // 拓展欧几里得算法 private static void exgcd(long a, long b) { if (b == 0) { x = 1; y = 0; return ; } exgcd(b, a % b); long k = x; x = y; y = k - a / b * y; } // 求逆元 private static long inv(long a) { long b = 9973; exgcd(a, b); return (x + b) % b; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/30/1576.%20AB/"},{"title":"127. 单词接龙","text":"leetcode 127. 单词接龙 题目：127. 单词接龙 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,返回它的长度 5。 示例1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,返回它的长度 5。 示例2: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 方法一：BFS（广度优先搜索）思路：BFS（广度优先搜索），将当前单词只改变一个字母的所有单词都视为可扩展搜索的方向，通过判断改变的单词是否在词库中，选择是否将其扩展入队（在词库中则入队）。直至扩展到endWord（此时说明已搜索到目标数），或者队列为空（此时说明无法搜索到目标数），则搜索结束。Set检索元素效率低下，删除和插入效率高；List查找元素效率高，插入删除元素效率低。但是若用contains方法查询对象元素，Set集合应该比List效率要高，所以将词库wordList转成Set，以提高效率。 运行数据：执行用时：64 ms，内存消耗：41.6 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// LeetCode指定调用方法public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) { // 记录结果 int result = 0; // 将词库wordList转成Set，以提高效率 HashSet&lt;String&gt; words = new HashSet&lt;&gt;(wordList); // 用于BFS的队列 Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); // 将起点单词入队 queue.offer(beginWord); // 记录当前队列的长度，当队列为空时，BFS全部搜索结束（用以代替 queue.isEmpty() 增加每次循环判断时的效率） int queueLen = 1; // BFS while (queueLen &gt; 0) { // 记录当前扩展轮的单词的个数 int currentQueueLen = queueLen; // 更新结果 result++; words.removeAll(queue); // 扩展当前轮次的单词 while (currentQueueLen-- &gt; 0) { // 将队列中第一个单词出队 String currentString = queue.poll(); // 更新当前队列长度 queueLen--; // 将单词转换成字符数组以便使用 char[] chars = currentString.toCharArray(); // 当前单词只改变一个字母的所有单词都视为可扩展搜索的方向，以下两个循环均用于遍历可扩展单词 for (int i = 0; i &lt; chars.length; i++) { // 记录当前字母 char temp = chars[i]; for (char j = 'a'; j &lt;= 'z'; j++) { // 改变当前字母 chars[i] = j; // 改变一个字母之后的单词 String word = new String(chars); // 判断改变的单词是否在词库中 if (words.contains(word)) { // 扩展到endWord，此时说明已搜索到目标单词，返回结果 if (word.equals(endWord)) { return result + 1; } // 将扩展单词入队 queue.offer(word); // 更新当前队列长度 queueLen++; } } // 将以改变的字母恢复原来的值，以便下一次改变单词字母 chars[i] = temp; } } } return 0;} 方法二：双向BFS（广度优先搜索）思路：双向BFS（广度优先搜索），在上述基本BFS的基础上，进行该进。endWord为起点endWord为终点，用start、end分别记录从起点端向终点端的扩展单词和从终点向起点扩展的单词，一开始从起点向终点扩展，扩展一轮后如果当前的扩展单词数大于另一个方向的扩展单词数则改变方向，从终点往起点开始扩展。依次类推，根据这个规则改变搜索方向，直至当前方向的搜索搜索到另一个方向的扩展单词（此时说明已收索到目标数），或者当前搜索方向的扩展单词为空（此时说明无法搜索到目标数），则搜索结束。 运行数据：执行用时：11 ms，内存消耗：40.7 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// LeetCode指定调用方法public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) { // 初始化两个方向记录扩展的集合 HashSet&lt;String&gt; start = new HashSet&lt;&gt;(); start.add(beginWord); HashSet&lt;String&gt; end = new HashSet&lt;&gt;(); end.add(endWord); // 将词库类型转成Set HashSet&lt;String&gt; words = new HashSet&lt;&gt;(wordList); // 如果终点单词不在词库中，则无法到达终点，直接返回0 if (!words.contains(endWord)) { return 0; } return bothwayBfs(start,end,words,2);}// 双向BFSprivate int bothwayBfs(HashSet&lt;String&gt; start, HashSet&lt;String&gt; end, HashSet&lt;String&gt; words, int depth) { // 当前的扩展单词数大于另一个方向的扩展单词数则改变方向 if (start.size() &gt; end.size()) { return bothwayBfs(end, start, words, depth); } // 清除词库中已被搜索过的单词，防止重复搜索 words.removeAll(start); // 记录当前轮的扩展单词 HashSet&lt;String&gt; next = new HashSet&lt;&gt;(); // 对上一轮扩展的单词，进行搜索扩展 for (String str : start) { // 将单词转换成字符数组以便使用 char[] chars = str.toCharArray(); // 当前单词只改变一个字母的所有单词都视为可扩展搜索的方向，以下两个循环均用于遍历可扩展单词 for (int i = 0; i &lt; chars.length; i++) { // 记录当前字母 char temp = chars[i]; for (char j = 'a'; j &lt;= 'z'; j++) { // 改变当前字母 chars[i] = j; // 改变一个字母之后的单词 String word = new String(chars); // 判断改变的单词是否在词库中 if (words.contains(word)) { // 当前方向的搜索搜索到另一个方向的扩展单词，此时说明已收索到目标数，返回扩展次数 if (end.contains(word)) { return depth; } next.add(word); } } // 将以改变的字母恢复原来的值，以便下一次改变单词字母 chars[i] = temp; } } // 当前搜索方向的扩展单词为空，此时说明无法搜索到目标数，直接返回0 if (start.isEmpty()) { return 0; } // 进行下一轮搜索扩展 return bothwayBfs(next, end, words, depth + 1);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/21/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"},{"title":"16. 最接近的三数之和","text":"leetcode 16. 最接近的三数之和 题目：16. 最接近的三数之和 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例: 输入: nums = [-1,2,1,-4], target = 1输出: 2解释: 与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。 提示: 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 方法：排序 + 双指针思路：排序 + 双指针，先对数组进行从小到大排序，然后从大到小遍历出第一个整数a，对于剩下的两个整数 b和c，希望它们的和最接近 target-a。假设数组的长度为 n，我们先枚举 a，它在数组中的位置为 i，借助双指针（对撞指针）我们在位置[0,i-1]的范围内枚举 b和 c，初始时令b为i-1位置上的值，c为0位置上的值，如果a+b+c &lt; target，则将c往右移一位，指向1位置的值；如果a+b+c &gt; target，则将b往左移一位，指向i-2位置的值；如果a+b+c == target，则直接返回target，结束方法。 运行数据：执行用时：6 ms，内存消耗：38.2MB 1234567891011121314151617181920212223242526// LeetCode指定调用方法public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int bestSum = nums[0] + nums[1] + nums[2]; for (int i = nums.length - 1; i &gt;= 0; i--) { int l = 0; int r = i - 1; while (l &lt; r) { int sum = nums[i] + nums[r] + nums[l]; if (sum &gt; target) { if (Math.abs(sum - target) &lt; Math.abs(bestSum - target)) { bestSum = sum; } r--; } else if (sum &lt; target){ if (Math.abs(sum - target) &lt; Math.abs(bestSum - target)) { bestSum = sum; } l++; } else { return target; } } } return bestSum;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2021/03/12/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"17. 电话号码的字母组合","text":"leetcode 17. 电话号码的字母组合 题目：17. 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 方法：Backtracking（回溯）思路：Backtracking（回溯），通过回溯找出所有组合（典型回溯问题）。 运行数据：执行用时：0 ms，内存消耗：38.1 MB 复杂度分析： 时间复杂度：O(3^m * 4^n)，其中 m 和 n 分别为输入字符串中数字对应九宫键盘中拥有3个字符的个数和4个字符的个数（示例中”23”中的2对应”abc”、3对应”def”都是3个字符，此时时间复杂度为O(3^2)）。 空间复杂度：O(m + n)，其中 m 和 n 分别为输入字符串中数字对应九宫键盘中拥有3个字符的个数和4个字符的个数。空间复杂度主要在于回溯过程中的递归的栈开销，为O(m + n)。 1234567891011121314151617181920212223242526272829303132// LeetCode指定调用方法 public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (digits == null || digits.length() == 0) { return result; } combination(new StringBuilder(), result, digits); return result;}// 记录电话九宫键盘上的字母String[] letters = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};// 通过回溯找出所有组合private void combination(StringBuilder prefix, List&lt;String&gt; result, String digits) { if (prefix.length() == digits.length()) { result.add(prefix.toString()); return ; } int currentNum = digits.charAt(prefix.length()) - 48; for (char cha : letters[currentNum].toCharArray()) { combination(prefix.append(cha), result, digits); prefix.deleteCharAt(prefix.length() - 1); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/03/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"141. 环形链表","text":"leetcode 141. 环形链表 题目：141. 环形链表 给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例1: 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2: 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3: 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶:你能用 O(1)（即，常量）内存解决此问题吗？ 方法一：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 1234567891011121314151617181920212223// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化快慢指针 ListNode fast = head; ListNode slow = head.next; // 双指针（快慢指针）算法 while (slow != null &amp;&amp; slow.next != null) { if (fast == slow) { return true; } fast = fast.next; slow = slow.next.next; } return false;} 方法二：标记法思路：标记法，通过遍历链表，将已遍历的链表结点赋值为Integer.MAX_VALUE，当遍历到链表结点为null时说明链表不成环，当链表结点的值为Integer.MAX_VALUE时说明链表成环。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 12345678910111213141516171819202122// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化遍历指针 ListNode node = head; // 标记算法 while (node != null) { if (node.val == Integer.MAX_VALUE) { return true; } node.val = Integer.MAX_VALUE; node = node.next; } return false;} 方法三：hash表思路：hash表，遍历链表，将遍历结点放入hash表中，当遍历到链表结点为null时说明链表不成环，当链表结点已经在hash表中时说明链表成环。 运行数据：执行用时：5 ms，内存消耗：40.8 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean hasCycle(ListNode head) { // 当head满足如下条件时，绝不能成环，直接返回false即可 if (head == null || head.next == null || head.next.next == null) { return false; } // 初始化遍历指针 ListNode node = head; // 初始化hash表 Set&lt;ListNode&gt; set = new LinkedHashSet&lt;&gt;(); // hash算法 while (node != null) { if (set.contains(node)) { return true; } set.add(node); node = node.next; } return false;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/24/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"200. 岛屿数量","text":"leetcode 200. 岛屿数量 题目：200. 岛屿数量 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例1: 输入:[[‘1’,’1’,’1’,’1’,’0’],[‘1’,’1’,’0’,’1’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’0’,’0’,’0’]]输出: 1 示例2: 输入:[[‘1’,’1’,’0’,’0’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’1’,’0’,’0’],[‘0’,’0’,’0’,’1’,’1’]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 方法：DFS（深度优先搜索）思路：DFS（深度优先搜索），遍历矩阵，值为1时进行一次DFS，搜索所有与它水平或垂直相邻的值为’1’的位置，将已搜索过的’1’赋值为’0’，返回DFS的运行次数，即为岛屿数。 运行数据：执行用时：2 ms，内存消耗：42.2 MB 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法 public int numIslands(char[][] grid) { int result = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { // 值为'1'时进行一次DFS if (grid[i][j] == '1') { dfs(grid, i, j); result++; } } } return result;}// DFSprivate void dfs(char[][] grid, int a, int b) { // 该位置已超出矩阵限制或该位置值为'0'，结束搜索 if (a &lt; 0 || b &lt; 0 || a &gt;= grid.length || b &gt;= grid[0].length || grid[a][b] == '0') { return ; } // 将已搜索过的'1'赋值为'0' grid[a][b] = '0'; // 递归搜索4个方向 dfs(grid, a + 1, b); dfs(grid, a - 1, b); dfs(grid, a, b + 1); dfs(grid, a, b - 1);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/24/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"title":"198. 打家劫舍","text":"leetcode 198. 打家劫舍 题目：198. 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例1: 输入：[1,2,3,1]输出：4解释： 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2: 输入：[2,7,9,3,1]输出：12解释： 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示: 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 方法：动态规划思路：动态规划，状态转移方程为：f(i) = max(f(i - 1), f(i - 2) + nums[i])，由于不能偷窃两间相邻的房屋，所以偷窃到第i个房间时的金额数肯定为偷窃到前一个房间（i - 1房间）的金额数或者偷窃到前两个房间（i - 2房间）的金额数和当前房间的总和。运行数据：执行用时：0 ms，内存消耗：36.2 MB 复杂度分析： 时间复杂度：O(n)，n为房间数，循环执行 n次。 空间复杂度：O(1)，常数个变量作为辅助空间。 123456789101112// LeetCode指定调用方法 public int rob(int[] nums) { int f = 0, f1 = 0, f2 = 0; for (int i = 0; i &lt; nums.length; i++) { f = Math.max(f1, f2 + nums[i]); f2 = f1; f1 = f; } return f;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/28/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"2. 找出单独出现的数字","text":"XMOJ 2. 找出单独出现的数字 题目：2. 找出单独出现的数字 描述: 给出N个数字。其中仅有一个数字出现过一次，其他数字均出现过两次，找出这个出现且只出现过一次的数字。要求时间和空间复杂度最小。 输入: 输入多个数字，每个数字以空格分开。数字数量 N &lt; 20，输入数字的最大值小于 256. 输出: 输出内容为只出现过唯一一次的数字 输入样例: 10 10 11 12 12 11 16 输出样例: 16 方法：异或思路：异或，a^b^b = a，将0与输入数据逐个异或即可得出答案。 运行数据：最大执行时间：85.34 ms，内存消耗：17340 KiB 复杂度分析： 时间复杂度：O(n)，n为输入数字个数。 空间复杂度：O(1)。 123456789101112131415import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; line = scan.nextLine(); short ans = 0; for (String string : line.split(\" \")) { ans ^= Short.parseShort(string); } System.out.println(ans); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/02/2.%20%E6%89%BE%E5%87%BA%E5%8D%95%E7%8B%AC%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"213. 打家劫舍 II","text":"leetcode 213. 打家劫舍 II 题目：213. 打家劫舍 II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例1: 输入: [2,3,2]输出：3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例2: 输入: [1,2,3,1]输出：4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4。 方法：动态规划思路：动态规划，状态转移方程为：f(i) = max(f(i - 1), f(i - 2) + nums[i])。由于房屋围成了一个圈，为了避免同时偷窃第一个房屋和最后一个房屋，因此将该问题分为两个子问题进行处理，一个是从第二个房屋到最后一个房屋进行偷窃的最高金额，另一个是从第一个房屋到倒数第二个房屋进行偷窃的最高金额。两个子问题的最优解即为该问题的最优解。运行数据：执行用时：0 ms，内存消耗：36.2 MB 复杂度分析： 时间复杂度：O(n)，n为房间数，循环执行 n次。 空间复杂度：O(1)，常数个变量作为辅助空间。 1234567891011121314151617181920212223242526272829303132// LeetCode指定调用方法 public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int n = nums.length; if (n == 1) { return nums[0]; } // dp(nums, 0, n - 2) ： 从第二个房屋到最后一个房屋进行偷窃的最高金额 // dp(nums, 1, n - 1) ： 从第一个房屋到倒数第二个房屋进行偷窃的最高金额 return Math.max(dp(nums, 0, n - 2), dp(nums, 1, n - 1));}// 动态规划private int dp(int[] nums, int start, int end) { int f = 0, f1 = 0, f2 = 0; for (int i = start; i &lt;= end; i++) { f2 = f1; f1 = f; f = Math.max(f1, f2 + nums[i]); } return f;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/30/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/"},{"title":"215. 数组中的第K个最大元素","text":"leetcode 215. 数组中的第K个最大元素 题目：215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 方法一：java.util.Arrays的sort方法思路：使用java.util.Arrays的sort方法排序 运行数据：执行用时：2 ms，内存消耗：40.4 MB 12345// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length - k];} 方法二：堆排序（大顶堆）思路：使用堆排序（大顶堆） 运行数据：执行用时：2 ms，内存消耗：39.9 MB 12345678910111213141516171819202122232425262728293031323334353637383940// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { int len = nums.length; createBigHeap(nums, len); // 通过大顶堆排序，找出第 k个最大的元素 for (int i = 1; i &lt;= k; i++) { int temp = nums[len - i]; nums[len - i] = nums[0]; nums[0] = temp; adjustBigHeap(nums, 0, len - i); } return nums[len - k];}// 创建大顶堆public void createBigHeap(int[] nums, int len) { for (int i = len / 2 - 1; i &gt;= 0; i--) { //从第一个非叶子结点从下至上，从右至左调整结构 adjustBigHeap(nums, i, len); }}// 调整大顶堆public void adjustBigHeap(int[] nums, int i, int len) { int temp = nums[i]; for(int j = i * 2 + 1; j &lt; len; j = j * 2 + 1){ // 遍历从i开始的左子节点，左子节点的左子节点 if(j + 1 &lt; len &amp;&amp; nums[j] &lt; nums[j + 1]){ // 如果左子结点小于右子结点，则将子节点指针j指向右子结点 j++; } if(nums[j] &gt; temp){ // 如果子节点大于父节点，将子节点值赋给父节点，并将父节点指针i指向该子节点 nums[i] = nums[j]; i = j; }else{ break; } } nums[i] = temp;} 方法三：快速排序（快速选择）思路：使用快速排序，并结合题目要求对其进行优化。（通过随机数确定枢轴，降低有序数据对快速排序的影响，当确定了第 k个最大的元素时，结束快速排序，直接返回结果） 运行数据：执行用时：2 ms，内存消耗：39.9 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// LeetCode指定调用方法public int findKthLargest(int[] nums, int k) { int len = nums.length; int low = 0; int high = len - 1; // 将第 k个最大的元素的下标赋值给k（从小到大排序） k = len - k; // 枢轴位置 int pos; // 结合题目需求，优化后的快速排序 while (low &lt; high) { pos = partition(nums, low, high); if (pos == k) { break; } else if (pos &gt; k) { high = pos - 1; } else { low = pos + 1; } } return nums[k];}// 进行一次快速排序，确定枢轴位置public int partition(int[] nums, int low, int high) { // 通过随机数确定枢轴，降低有序数据对快速排序的影响 Random random = new Random(); int random_index = low + random.nextInt(high - low); // 枢轴 int temp = nums[random_index]; nums[random_index] = nums[low]; nums[low] = temp; while (low &lt; high) { while (low &lt; high &amp;&amp; nums[high] &gt;= temp) { // 从右往左找小于枢轴的元素 high--; } nums[low] = nums[high]; while (low &lt; high &amp;&amp; nums[low] &lt;= temp) { // 从左往右找大于枢轴的元素 low++; } nums[high] = nums[low]; } nums[low] = temp; return low; // 返回枢轴位置} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/01/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"216. 组合总和 III","text":"leetcode 216. 组合总和 III 题目：216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明: 所有数字都是正整数。 解集不能包含重复的组合。 示例1: 输入: k = 3, n = 7输出: [[1,2,4]] 示例2: 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 方法：Backtracking（回溯）思路：Backtracking（回溯）。运行数据：执行用时：0 ms，内存消耗：37.1 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为9，生成所有子集的时间复杂度O(2^n)，复制到输出集合中的时间复杂度O(n)。 空间复杂度：O(n)，n为9，回溯递归时保存临时组合。 123456789101112131415161718192021222324252627282930// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtracking(k, n, result, new ArrayList&lt;&gt;(), 1); return result;}// 回溯，记录当前candidates的开始位置起始元素private void backtracking(int k, int n, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combinationSum3List, int t) { if (n == 0 || k == 0) { if (n == 0 &amp;&amp; k == 0) { result.add(new ArrayList&lt;&gt;(combinationSum3List)); } return ; } for (int i = t; i &lt;= 9; i++) { if (i &gt; n) { break; } combinationSum3List.add(i); backtracking(k - 1, n - i, result, combinationSum3List, i + 1); combinationSum3List.remove(combinationSum3List.size() - 1); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/19/216.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"},{"title":"241. 为运算表达式设计优先级","text":"leetcode 241. 为运算表达式设计优先级 题目：241. 为运算表达式设计优先级 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例1: 输入: “2-1-1”输出: [0, 2]解释: ((2-1)-1) = 0 (2-(1-1)) = 2 示例2: 输入: “23-45”输出: [-34, -14, -10, -10, 10]解释: (2(3-(45))) = -34 ((23)-(45)) = -14 ((2(3-4))5) = -10 (2((3-4)5)) = -10 (((23)-4)5) = 10 方法：分治思路：通过分治的思想，将字符串以运算符为标识把字符串分为两个部分，然后分别计算这两个部分的值，可以继续细分的继续按运算符细分求结果，两部分中每个部分都有可能会有不同的结果（可以继续细分就会有不同的结果），所以求结果时，要将两部分不同结果组合起来，才能得出最终的结果。 运行数据：执行用时：2 ms，内存消耗：40.1 MB 1234567891011121314151617181920212223242526272829303132333435363738394041// LeetCode指定调用方法public List&lt;Integer&gt; diffWaysToCompute(String input) { // 记录结果 List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); // 将字符串按运算符分为两个部分 for (int i = 0; i &lt; input.length(); i++) { char cha = input.charAt(i); if (cha == '+' || cha == '-' || cha == '*') { // 继续细分得出两个部分的所有结果 List&lt;Integer&gt; leftList = diffWaysToCompute(input.substring(0, i)); List&lt;Integer&gt; rightList = diffWaysToCompute(input.substring(i + 1)); // 将两个部分的通过结果组合起来，得出最终结果 for (Integer l : leftList) { for (Integer r : rightList) { switch (cha) { case '+': result.add(l + r); break; case '-': result.add(l - r); break; case '*': result.add(l * r); break; } } } } } // 如果result为空，说明字符串不能分为两个部分，字符串只包含数 if (result.size() == 0){ result.add(Integer.valueOf(input)); } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/13/241.%20%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"},{"title":"278. 第一个错误的版本","text":"leetcode 278. 第一个错误的版本 题目：278. 第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 方法：二分查找思路：通过二分查找缩小区间查找，每次缩小一半，如果中间的版本是正确的版本则将右边界往中间移，否则将左边界往中间移，当左边界等于右边界时，此版本即为第一个错误的结果或第一个错误的结果前面的版本。 运行数据：执行用时：16 ms，内存消耗：36.4 MB 123456789101112131415161718// LeetCode指定调用方法public int firstBadVersion(int n) { int l = 1; int r = n; while (l &lt; r) { int mid = l + (r - l) / 2; if (isBadVersion(mid)) { r = mid - 1; } else { l = mid + 1; } } // 判断为第一个错误的结果还是第一个错误的结果前面的版本，返回对应结果 return isBadVersion(l) ? l : l + 1;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/07/278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"},{"title":"257. 二叉树的所有路径","text":"leetcode 257. 二叉树的所有路径 题目：257. 二叉树的所有路径 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 输出: [“1-&gt;2-&gt;5”, “1-&gt;3”] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 方法：Backtracking（回溯）思路：Backtracking（回溯），从根节点往左右节点搜索，每搜索到一个节点，记录到该节点的路径，如果当前节点左右子节点都为null，则该节点为叶子节点，将叶子节点路径保存进结果集，如果当左子节点为null，回退到上一步，复原当前记录的节点路径，搜索右子节点。 运行数据：执行用时：7 ms，内存消耗：40.3 MB 复杂度分析： 时间复杂度：O(n)，n为二叉树节点数目。 空间复杂度：O(n)，n为二叉树节点数目。 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法 public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; result = new ArrayList&lt;String&gt;(); backtracking(root, result, new StringBuilder()); return result;}// 回溯算法，prefix记录当前节点路径private void backtracking(TreeNode node, List&lt;String&gt; result, StringBuilder prefix) { if (node == null) { return ; } // 将当前节点加入节点路径中 String tempString = node.val + \"\"; if (prefix.length() != 0) { tempString = \"-&gt;\" + tempString; } prefix.append(tempString); // 如果当前节点左右子节点都为null，则该节点为叶子节点，将叶子节点路径保存进结果集 if (node.left == null &amp;&amp; node.right == null) { result.add(prefix.toString()); } else { backtracking(node.left, result, prefix); backtracking(node.right, result, prefix); } // 复原节点路径 prefix.delete(prefix.length() - tempString.length(), prefix.length());} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/08/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"},{"title":"3. 大数相减","text":"XMOJ 3. 大数相减 题目：3. 大数相减 描述: 两个长度超出常规整形变量上限的大数相减，请避免使用各语言内置大数处理库，如 Java.math.BigInteger 等。 输入: 有 N 行测试数据，每一行有两个代表整数的字符串 a 和 b，长度超过百位。规定 a&gt;=b，a, b &gt; 0。 测试结果可以用 linux 小工具 bc进行测试是否正确。 输出: 返回表示结果整数的字符串。 输入样例: 1231231237812739878951331231231237812739878951331231231237812739878951331231231237812739878951331231231237812739878951331231231237812739870-895133123123123781273987895133123123123781273987895133123123123781273987895131231231237812739878951331231231237812739878951331231231237812739878951331230000000000000000000000001-331231231237812739878951331231231 输出样例: 12312312378127398789513312312312378127398789513312312312378126503656390189188531104139503656390189188531104139503656390189188531104139503571231231237812739878951331231231237812739878951331231231237812739878620099998762187260121048668768770 方法：模拟思路：将输入字符串处理从两个字符数组，根据数学减法规则，从尾向头进行运算。 运行数据：最大执行时间：86.96 ms，内存消耗：17396 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(n)，n为输入字符串长度，一个循环进行运算，一个循环输出结果。 空间复杂度：O(n)，n为输入字符串长度，两个字符数组的空间消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNext()) { line = scan.nextLine().trim(); String[] strs = line.split(\"-\"); char[] cha1 = strs[0].toCharArray(); char[] cha2 = strs[1].toCharArray(); int len1 = cha1.length; int len2 = cha2.length; for (int i = len2 - 1,j = len1 - 1; i &gt;= 0; i--,j--) { int a = cha1[j] - 48; int b = cha2[i] - 48; if (a &lt; b) { if (j &gt; 0) { a += 10 - b; cha1[j - 1] -= 1; } else { a -= b; } } else { a -= b; } cha1[j] = (char) (a + 48); } boolean flag = true; for (int i = 0; i &lt; cha1.length; i++) { if (cha1[i] == '0' &amp;&amp; flag) { continue; } else { flag = false; } System.out.print(cha1[i]); } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/03/3.%20%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%87%8F/"},{"title":"279. 完全平方数","text":"leetcode 279. 完全平方数 题目：279. 完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 方法一：BFS（广度优先搜索）思路：BFS（广度优先搜索），将小于等于n的所有平方数都视为可扩展搜索的方向，每次扩展将当前数减去该扩展方向的平方数即为扩展后的数。直至扩展到第一个为0的数时，搜索结束。 运行数据：执行用时：25 ms，内存消耗：39.5 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// LeetCode指定调用方法public int numSquares(int n) { // 记录结果 int result = 0; // 记录可用平方数 List&lt;Integer&gt; squareNums = new ArrayList&lt;Integer&gt;(); // 求可用平方数 for (int i = 1; i * i &lt;= n; i++) { squareNums.add(i * i); } // 标记该数是否在BFS中扩展过 boolean[] marks = new boolean[n + 1]; // 用于BFS的队列 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 将第一个数入队 queue.offer(n); // 记录当前队列的长度，当队列为空时，BFS全部搜索结束（用以代替 queue.isEmpty() 增加每次循环判断时的效率） int queneLen = 1; // BFS while (queneLen &gt; 0) { // 记录当前扩展轮的数的个数 int currentQueueLen = queneLen; // 更新结果 result++; // 扩展当前轮次的数 while (currentQueueLen-- &gt; 0) { // 将队列中第一个数出队 int currentNum = queue.poll(); // 更新当前队列长度 queneLen--; // 遍历平方数，扩展收索 for (Integer squareNum : squareNums) { // 记录扩展后的数 int nextNum = currentNum - squareNum; // 如果扩展数不可用，后面的数也不可以用，此时直接退出循环（根据前面的生成平方数的规则，后面的平方数会越来越大，扩展数则会越来越小） if (nextNum &lt; 0) { break; } // 如果扩展数为0，则BFS结束，返回结果 if (nextNum == 0) { return result; } // 如果该数已被扩展过，则跳过该数 if (marks[nextNum]) { continue; } // 将扩展数入队 queue.offer(nextNum); // 标记该扩展数已被扩展 marks[nextNum] = true; // 更新当前队列长度 queneLen++; } } } return 0;} 方法二：动态规划（完全背包）思路：动态规划（完全背包），将小于等于n的所有平方数都视为不同种类物品的空间，将所求的数视为背包容量，将整个问题转换成求用最少的物品完全装满背包 ，不限制每种物品的数量，即转换为完全背包问题进行解决。 运行数据：执行用时：39 ms，内存消耗：38.9 MB 1234567891011121314151617181920212223242526272829// LeetCode指定调用方法public int numSquares(int n) { // 记录可用平方数 List&lt;Integer&gt; squareNums = new ArrayList&lt;Integer&gt;(); // 求可用平方数 for (int i = 1; i * i &lt;= n; i++) { squareNums.add(i * i); } // 动态规划记录数组，f[j]表示装满背包空间为j的最小物品数 int[] f = new int[n + 1]; // 初始化 动态规划记录数组 Arrays.fill(f, Integer.MAX_VALUE); f[0] = 0; // 动态规划 for (Integer squareNum : squareNums) { for (int j = squareNum; j &lt;= n; j++) { // 状态转移方程 f[j] = Math.min(f[j], f[j - squareNum] + 1); } } return f[n];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/19/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"title":"303. 区域和检索 - 数组不可变","text":"leetcode 303. 区域和检索 - 数组不可变 题目：303. 区域和检索 - 数组不可变 给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例: 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 方法：动态规划思路：动态规划，提前对nums进行预处理，计算出从0到nums每个元素位置的总和记录到sums，查询i 到 j范围内元素的总和时只需用sums[j + 1] - sums[i]即为答案。运行数据：执行用时：10 ms，内存消耗：41.7 MB 复杂度分析： 时间复杂度：每次查询的时间复杂度为O(1)，构造函数的预处理时间复杂度为O(n)，n为nums的元素个数。 空间复杂度：O(n)，n为nums的元素个数。 1234567891011121314151617// LeetCode指定类class NumArray { private int[] sums; public NumArray(int[] nums) { sums = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length; i++) { sums[i] = sums[i - 1] + nums[i - 1]; } } public int sumRange(int i, int j) { return sums[j + 1] - sums[i]; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/03/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"},{"title":"300. 最长上升子序列","text":"leetcode 300. 最长上升子序列 题目：300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 方法一：动态规划思路：动态规划，状态转移方程为：dp[i] = max(dp[i], dp[j] + 1);（nums[i] &gt; nums[j]）。dp[i]表示以nums[i]结尾的最长上升子序列的长度。 运行数据：执行用时：14 ms，内存消耗：36.8 MB 复杂度分析： 时间复杂度：O(n^2)，n为nums的元素个数，两层循环。 空间复杂度：O(n)，n为nums的元素个数，dp消耗的空间。 123456789101112131415161718// LeetCode指定调用方法 public int lengthOfLIS(int[] nums) { int n = nums.length; int [] dp = new int[n]; int ans = 0; for (int i = 0; i &lt; n; i++) { int max = 1; for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { max = Math.max(max, dp[j] + 1); } } dp[i] = max; ans = Math.max(ans, dp[i]); } return ans;} 方法二：贪心 + 二分查找思路：贪心 + 二分查找，通过一次循环遍历nums，用tails存储当前最长最小上升子序列，每次遍历一个nums数组新元素num，通过二分查找在当前tails中查询与num最接近的元素tails[m]，如果num大于tails[m]则将num覆盖tails[m + 1]，否则将num覆盖tails[m]，从而保持tails是当前的最长最小上升子序列，如果num大于tails[m]且tails[m]刚好是最后一个元素，则会将num储存在tails[m + 1]上，且当前的最长最小上升子序列长度将会加一。遍历完nums后，tails中存储元素个数即为最长上升子序列长度。 运行数据：执行用时：1 ms，内存消耗：37 MB 复杂度分析： 时间复杂度：O(n * log(n))，n为nums的元素个数，遍历nums的时间复杂度为O(n)，二分查找的时间复杂度为O(log(n))。 空间复杂度：O(n)，n为nums的元素个数，tails消耗的空间。 12345678910111213141516// LeetCode指定调用方法 public int lengthOfLIS(int[] nums) { int[] tails = new int[nums.length]; int res = 0; for(int num : nums) { int i = 0, j = res; while (i &lt; j) { int m = (i + j) / 2; if (tails[m] &lt; num) i = m + 1; else j = m; } tails[i] = num; if (j == res) res++; } return res;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/07/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"34. 在排序数组中查找元素的第一个和最后一个位置","text":"leetcode 34. 在排序数组中查找元素的第一个和最后一个位置 题目：34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 方法一：二分查找思路：通过二分查找缩小区间查找，找到等于target的数组元素后，根据该数组位置向两边寻找，直到找到不等于target的元素为止，从而确定目标值在数组中的开始位置和结束位置。 运行数据：执行用时：0 ms，内存消耗：43.2 MB 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法public int[] searchRange(int[] nums, int target) { int len = nums.length; int l = 0; int r = len - 1; // 存储开始位置和结束位置 int[] result = {-1,-1}; // 二分查找 while (l &lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] &gt; target) { r = mid - 1; } else if (nums[mid] &lt; target) { l = mid + 1; } else { // 找到等于target的数组元素后，根据该数组位置向两边寻找，确定开始位置和结束位置 for (int i = mid; i &gt;= l; i--) { if (nums[i] != target) { break; } result[0] = i; } for (int i = mid; i &lt;= r; i++) { if (nums[i] != target) { break; } result[1] = i; } break; } } return result;} 方法二：二分查找（两次二分查找）思路：通过两次二分查找分别查找左右边界，查找右边界时，通过searchBinaryBeforTarget()查target+1的位置，再减1得出右边界位置，由于target+1可能不在nums内，所以需要将searchBinaryBeforTarget()的范围扩展一位，以保证查target+1能找到对应位置。 运行数据：执行用时：0 ms，内存消耗：43.4 MB 12345678910111213141516171819202122232425262728293031323334// LeetCode指定调用方法public int[] searchRange(int[] nums, int target) { // 通过两次二分查找分别查找左右边界 int left = searchBinaryBeforTarget(nums, target); int right = searchBinaryBeforTarget(nums, target + 1) - 1; // 如果没有找到左右边界则返回[-1,-1],否则正常返回 if (left == nums.length || nums[left] != target) { return new int[]{-1,-1}; } else { return new int[]{left, right}; }}// 二分查找private int searchBinaryBeforTarget(int[] nums, int target) { int l = 0; int r = nums.length; // 右边界扩展一位 while (l &lt; r) { int mid = l + (r - l) / 2; if (nums[mid] &gt;= target) { r = mid; } else { l = mid + 1; } } return l;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/11/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"title":"345. 反转字符串中的元音字母","text":"leetcode 345. 反转字符串中的元音字母 题目：345. 反转字符串中的元音字母 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例1: 输入: “hello”输出: “holle” 示例2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 方法：双指针 （对撞指针）思路：双指针（对撞指针） ，一个从头向尾遍历，一个指针从尾向头遍历，找到一对元音字母交换一次 运行数据：执行用时：2 ms，内存消耗：39.8 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// LeetCode指定调用方法public String reverseVowels(String s) { // 如果字符串长度小于2，无需反转字符串中的元音字母 ，直接原样返回 if (s.length() &lt; 2) { return s; } // 将字符串转换成字符数组 char schar[] = s.toCharArray(); // i标识头指针位置，j标识尾指针位置 int i = 0, j = schar.length - 1; // flagI标识头端是否找到元音字母，flagJ标识尾端是否找到元音字母， boolean flagI = false, flagJ = false; // 反正字符串中的元音字母 while (i &lt; j) { // 判断是否找到了头端的元音字母 if (!flagI) { if (isVowel(schar[i])) { flagI = true; } else { i++; } } // 判断是否找到了尾端的元音字母 if (!flagJ) { if (isVowel(schar[j])) { flagJ = true; } else { j--; } } // 判断是否两端都找到了元音字母，都找到了将交换元音字母 if (flagI &amp;&amp; flagJ) { char temp = schar[i]; schar[i] = schar[j]; schar[j] = temp; i++; j--; flagI = false; flagJ = false; } } return new String(schar);}// 判断字符是否为元音字母public boolean isVowel(char ch) { return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||ch=='A'|| ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/18/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"},{"title":"37. 解数独","text":"leetcode 37. 解数独 题目：37. 解数独 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则: ​ 数字 1-9 在每一行只能出现一次。 ​ 数字 1-9 在每一列只能出现一次。 ​ 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。 一个数独。 答案被标成红色。 说明: 给定的数独序列只包含数字 1-9 和字符 ‘.’ 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 方法：Backtracking（回溯）思路：Backtracking（回溯），遍历board，找到没有填入数字的点，遍历字符1-9，通过isPut方法判断是否可以填入，直到填完所有点为止。运行数据：执行用时：9 ms，内存消耗：36.2 MB 复杂度分析： 时间复杂度：O((9!)^9)，由于该题board是固定的即9 * 9，所以最坏情况第一行第一个位置有9种情况，第二个位置有8种情况，……，第九个位置有1种可能，即第一行有9！情况，一共有9行所以，时间复杂度为O((9!)^9)。 空间复杂度：O(9 * 9)，由于该题board是固定的即9 * 9，所以空间复杂度为O(9 * 9)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// LeetCode指定调用方法 public void solveSudoku(char[][] board) { backtracking(board, 0, 0);}// 可选填入字符char[] chars = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};// 回溯private boolean backtracking(char[][] board, int x, int y) { // 当该行的所有列都遍历完时，判断该行是否是最后一行，如果是则说明board已填完，直接结束，如果不是最后一行，则接着遍历下一行 if (y == 9) { if (x == 8) { return true; } x++; y = 0; } // 如果该位置已填入字符，则遍历下一个位置，否则遍历字符1-9，判断是否可以填入 if (board[x][y] != '.') { return backtracking(board, x, y + 1); } else { // 遍历字符1-9 for (int i = 0; i &lt; 9; i++) { // 判断字符是否可以填入 if (isPut(board, x, y, chars[i])) { // 将该字符填入 board[x][y] = chars[i]; // 继续填下一个位置 if (backtracking(board, x, y + 1)) { return true; } // 复原该位置字符 board[x][y] = '.'; } } } return false;}// 判断字符ch是否可以填入board[x][y]private boolean isPut(char[][] board, int x, int y, char ch) { // 判断行和列是否已有该字符，有则不能填入，返回false for (int i = 0; i &lt; 9; i++) { if (board[x][i] == ch || board[i][y] == ch) { return false; } } // 判断 3x3 宫内是否已有该字符，有则不能填入，返回false for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (board[(x / 3) * 3 + i][(y / 3) * 3 + j] == ch) { return false; } } } return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/22/37.%20%E8%A7%A3%E6%95%B0%E7%8B%AC/"},{"title":"347. 前 K 个高频元素","text":"leetcode 347. 前 K 个高频元素 题目：347. 前 K 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2: 输入: nums = [1], k = 1输出: [1] 说明: 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 方法一：sort排序思路：使用HashMap + ArrayList + sort，根据出现频率排序，返回频率最大的k个元素 运行数据：执行用时：16 ms，内存消耗：42.7 MB 123456789101112131415161718192021222324252627// LeetCode指定调用方法public int[] topKFrequent(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 使用sort方法排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer,Integer&gt;&gt;(map.entrySet()); list.sort(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() { @Override public int compare(Entry&lt;Integer, Integer&gt; o1, Entry&lt;Integer, Integer&gt; o2) { return o2.getValue().compareTo(o1.getValue()); } }); // 记录频率最大的k个元素 int[] result = new int[k]; for (int i = 0; i &lt; k; i++) { result[i] = list.get(i).getKey(); } return result;} 方法二：堆排序（大顶堆）思路：使用PriorityQueue,维护大顶堆，返回k个堆顶元素 运行数据：执行用时：16 ms，内存消耗：42.4 MB 123456789101112131415161718192021// LeetCode指定调用方法public int[] topKFrequent(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 优先队列 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; (map.get(o2) - map.get(o1))); queue.addAll(map.keySet()); // 记录k个堆顶元素 int[] result = new int[k]; for (int i = 0;!queue.isEmpty() &amp;&amp; i &lt; k; i++) { result[i] = queue.poll(); } return result;} 方法三：桶排序思路：桶排序，将出现频率相同的放到一个桶中 运行数据：执行用时：12 ms，内存消耗：42.5 MB 1234567891011121314151617181920212223242526272829303132// LeetCode指定调用方法public int[] topKFrequent3(int[] nums, int k) { // 记录每个元素出现的频率 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { map.put(i, map.getOrDefault(i, 0) + 1); } // 将每个元素放到对应的桶中 List&lt;Integer&gt;[] arr = new ArrayList[nums.length + 1]; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { int value = entry.getValue(); if (arr[value] == null) { arr[value] = new ArrayList&lt;&gt;(); } arr[value].add(entry.getKey()); } // 频率最大的k个元素 int[] result = new int[k]; int t = 0; for (int i = arr.length - 1; t &lt; k &amp;&amp; i &gt; 0; i--) { if (arr[i] == null) continue; for (int item : arr[i]) { result[t++] = item; if (t == k) break; } } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/05/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"title":"343. 整数拆分","text":"leetcode 343. 整数拆分 题目：343. 整数拆分 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例1: 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例2: 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 方法一：动态规划思路：动态规划，状态转移方程为：dp[i] = max(dp[i], j * max(dp[i - j], i - j));（dp[i]表示表示拆分i的乘积最大值），求dp[i]将i拆分为j和i - j两个部分求乘积。 运行数据：执行用时：1 ms，内存消耗：35.3 MB 复杂度分析： 时间复杂度：O(n^2)，两层循环的时间复杂度。 空间复杂度：O(n)，dp数组所消耗的空间。 1234567891011// LeetCode指定调用方法 public int integerBreak(int n) { int[] dp = new int[n + 1]; for (int i = 2; i &lt;= n; i++) { for (int j = 1; j &lt;= i / 2; j++) { dp[i] = Math.max(dp[i], j * Math.max(dp[i - j], i - j)); } } return dp[n];} 方法二：优化动态规划思路：优化动态规划，状态转移方程为：dp[i] = max(2 * (i - 2), 2 * dp[i - 2],3 * (i - 3), 3 * dp[i - 3]);（dp[i]表示表示拆分i的乘积最大值），根据题意找规律，求dp[i]只需要判断将i拆分为2和i - 2以及3和i - 3这两中分拆分情况的最大值即可。 运行数据：执行用时：0 ms，内存消耗：35.3 MB 复杂度分析： 时间复杂度：O(n)，只需循环n - 3次即可。 空间复杂度：O(n)，dp数组所消耗的空间。 12345678910111213// LeetCode指定调用方法 public int integerBreak(int n) { if (n &lt; 4) { return n - 1; } int[] dp = new int[n + 1]; dp[2] = 1; for (int i = 3; i &lt;= n; i++) { dp[i] = Math.max(Math.max(2 * (i - 2), 2 * dp[i - 2]), Math.max(3 * (i - 3), 3 * dp[i - 3])); } return dp[n];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/05/343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"},{"title":"376. 摆动序列","text":"leetcode 376. 摆动序列 题目：376. 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例1: 输入: [1,7,4,9,2,5]输出: 6解释: 整个序列均为摆动序列。 示例2: 输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例3: 输入: [1,2,3,4,5,6,7,8,9]输出: 2 方法一：动态规划思路：动态规划。状态转移方程为：up[i] = max(up[i], down[j] + 1);（nums[i] &gt; nums[j]）。down[i] = max(down[i], up[j] + 1);（nums[i] &lt; nums[j]）。up[i]表示以nums[i]结尾的最后是上升的摆动序列长度（即nums[i] &gt; nums[j]），down[i]表示以nums[i]结尾的最后是下降的摆动序列长度（即nums[i] &lt; nums[j]）。 运行数据：执行用时：6 ms，内存消耗：36.5 MB 复杂度分析： 时间复杂度：O(n^2)，n为nums的长度，两层循环。 空间复杂度：O(n)，n为nums的长度，主要是up和down数组消耗的空间2n。 1234567891011121314151617181920212223// LeetCode指定调用方法 public int wiggleMaxLength(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int n = nums.length; int[] up = new int[n]; int[] down = new int[n]; for (int i = 0; i &lt; n; i++) { int maxUp = 1, maxDown = 1; for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { maxUp = Math.max(maxUp, down[j] + 1); } else if (nums[i] &lt; nums[j]) { maxDown = Math.max(maxDown, up[j] + 1); } } up[i] = maxUp; down[i] = maxDown; } return Math.max(up[n - 1], down[n - 1]);} 方法二：优化动态规划思路：优化动态规划。因为数组中任何一个元素都组下列三种情况的一种：（1）、该元素是上升的位置，意味着 nums[i] &gt; nums[i - 1]；（2）、该元素是下降的位置，意味着 nums[i] &lt; nums[i - 1];（1）、该元素不是上升也不是下降的位置，意味着 nums[i] == nums[i - 1]，所以只需要用一个up记录以当前元素为结尾的最后是上升的摆动序列长度，一个down记录以当前元素为结尾的最后是下降的摆动序列长度即可。当遍历到一个新元素时，如果该元素是处在上升位置，则up = down + 1;如果该元素是处在上升位置，则down = up + 1；如果该元素是处在不是上升也不是下降的位置；则up和down都不需要该变，遍历下一个元素时，在之前的基础上进行修改。 运行数据：执行用时：0 ms，内存消耗：36.4 MB 复杂度分析： 时间复杂度：O(n)，n为nums的长度，只需要遍历一次nums。 空间复杂度：O(1)。 123456789101112131415// LeetCode指定调用方法 public int wiggleMaxLength(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int up = 1, down = 1; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] &gt; nums[i - 1]) { up = down + 1; } else if (nums[i] &lt; nums[i - 1]) { down = up + 1; } } return Math.max(up, down);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/11/376.%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"},{"title":"392. 判断子序列","text":"leetcode 392. 判断子序列 题目：392. 判断子序列 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例1: s = “abc”, t = “ahbgdc”返回 true. 示例2: s = “axc”, t = “ahbgdc”返回 false. 方法：贪心思路：遍历字符串s，判断s的所有字符是否都在字符串t里的相对位置（相对于字符在s的位置），判断完在一个字符之后，如果不在字符串t里则直接返回false，如果在则继续判断下一个字符，且从上一个字符被在字符串t中找到的位置继续往后找，以保证相对位置正确，当s的全部字符都在t里，且符合相对位置时，返回true。 运行数据：执行用时：0 ms，内存消耗：37.8 MB 123456789101112131415161718192021// LeetCode指定调用方法public boolean isSubsequence(String s, String t) { // 标识t的当前位置 int index = -1; // 遍历字符串s for (char c : s.toCharArray()) { // 判断字符串s的字符c是否在t的里，且满足相对位置（相对于字符在s的位置） index = t.indexOf(c, index + 1); // 如果字符串s的字符c不在字符串t里则直接返回false if (index == -1) { return false; } } // 当s的全部字符都在t里，且符合相对位置时，返回true return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/25/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"39. 组合总和","text":"leetcode 39. 组合总和 题目：39. 组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明: 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例1: 输入: candidates = [2,3,6,7], target = 7所求解集为:[ [7], [2,2,3]] 示例2: 输入：candidates = [2,3,5], target = 8所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 提示: 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 方法：Backtracking（回溯）思路：Backtracking（回溯），经典回溯问题，由于元素可重复选择，每次回溯后重新选择该位置元素时，从上一次回溯开始选择的元素开始。 运行数据：执行用时：2 ms，内存消耗：40.1 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为candidates中元素的个数，生成所有子集的时间复杂度O(2^n)，复制到输出集合中的时间复杂度O(n)。 空间复杂度：O(n)，n为为candidates中元素的个数，回溯递归时保存临时组合。 1234567891011121314151617181920212223242526// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(candidates, target, result, new ArrayList&lt;&gt;(), 0); return result;}// 回溯，记录当前candidates的开始位置private void backtracking(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combinationSumList, int t) { if (target == 0) { result.add(new ArrayList&lt;&gt;(combinationSumList)); return ; } for (int i = t; i &lt; candidates.length; i++) { if (candidates[i] &lt;= target) { combinationSumList.add(candidates[i]); backtracking(candidates, target - candidates[i], result, combinationSumList, i); combinationSumList.remove(combinationSumList.size() - 1); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/16/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"},{"title":"406. 根据身高重建队列","text":"leetcode 406. 根据身高重建队列 题目：406. 根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意: 总人数少于1100人。 示例: 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 方法：贪心思路：先按身高 h 降序、个数 k 值升序排列，然后将其按顺序插入到k的位置上，如果k位置上已有数据，则将原有数据后移一位再插入，由于之前排好了序，插入时会先插入身高较高的，所以后面如果k位置上有数据需要后移一位，对后移的数据也不会有影响，因为新插入的数据身高一定会比后移的低。 运行数据：执行用时：8 ms，内存消耗：40.8 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public int[][] reconstructQueue(int[][] people) { // 判断输入数据是否为空，为空则返回空结果 if (people == null || people.length == 0 || people[0].length == 0) { return new int[0][0]; } // 身高 h 降序、个数 k 值升序排列 Arrays.sort(people, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]; } }); // 插入到k的位置上，如果k位置上已有数据，则将原有数据后移一位再插入，此时使用list，它会自动后移数据 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int[] p : people) { list.add(p[1], p); } // 将结果list转为数组结果返回 return list.toArray(new int[list.size()][]);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/17/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"},{"title":"4. 最长连续数列","text":"XMOJ 4. 最长连续数列 题目：4. 最长连续数列 描述: 输入一个乱序的连续数列，输出其中最长连续数列长度，要求算法复杂度为 O(n) 输入: 54,55,300,12,56 输出: 你的输出是对一行数据处理的结果，也即 a+b 的结果。 输入样例: 100,4,200,1,3,254,55,300,1215,4,3,2,11,2,3,4,5,6 输出样例: 42156 方法：hash思路：hash表，将输入数字依次加入hash表中，然后依次根据输入数字去删除hash表中的数字，以及相邻数字的，记录删除的数字的个数，数字个数即为该输入数字所在连续数列的长度，之后继续通过上述方法获取每一个输入数据所在连续序列的长度，其中最长的连续序列长度，即为整个乱序的连续数列的最长连续数列长度。 运行数据：最大执行时间：106.15 ms，内存消耗：17344 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(n)，n为一组输入数据的个数，加入hash表的时间复杂度为O(n)，删除hash表中所有数字的时间复杂度也为O(n)。 空间复杂度：O(n)，n为一组输入数据的个数，主要为保存拆分字符串的字符串数组的空间消耗以及hash表的空间消耗。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNextLine()) { line = scan.nextLine().trim(); System.out.println(LongestContinuousSequence(line)); } } private static int LongestContinuousSequence(String line) { String[] strs = line.split(\",\"); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (String string : strs) { set.add(Integer.valueOf(string)); } int ans = 0; for (String string : strs) { int count = 0; int i = Integer.valueOf(string); int j = i + 1; // 删除输入数字及其相邻数字，统计该输入数字所在的连续序列长度 while (set.remove(i)) { count++; i--; } while (set.remove(j)) { count++; j++; } ans = Math.max(ans, count); } return ans; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/04/4.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97/"},{"title":"40. 组合总和 II","text":"leetcode 40. 组合总和 II 题目：40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明: 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例1: 输入: candidates = [10,1,2,7,6,1,5], target = 8所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例2: 输入: candidates = [2,5,2,1,2], target = 5所求解集为:[ [1,2,2], [5]] 方法：Backtracking（回溯）思路：Backtracking（回溯），通过事先对candidates排序，在回溯递归选取元素时，如果当前选取元素是同层递归的非第一选取元素且与在candidates中的前一个元素相等时，直接跳过该元素的选取。运行数据：执行用时：4 ms，内存消耗：39.8 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为candidates中元素的个数，生成所有子集的时间复杂度O(2^n)，复制到输出集合中的时间复杂度O(n)。 空间复杂度：O(n)，n为为candidates中元素的个数，回溯递归时保存临时组合。 1234567891011121314151617181920212223242526272829303132// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 事先对candidates排序 Arrays.sort(candidates); backtracking(candidates, target, result, new ArrayList&lt;&gt;(), 0); return result;}// 回溯，记录当前candidates的开始位置private void backtracking(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combinationSumList, int t) { if (target == 0) { result.add(new ArrayList&lt;&gt;(combinationSumList)); return ; } for (int i = t; i &lt; candidates.length; i++) { if (i &gt; t &amp;&amp; candidates[i] == candidates[i - 1]) { continue; } if (candidates[i] &lt;= target) { combinationSumList.add(candidates[i]); backtracking(candidates, target - candidates[i], result, combinationSumList, i + 1); combinationSumList.remove(combinationSumList.size() - 1); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/17/40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/"},{"title":"413. 等差数列划分","text":"leetcode 413. 等差数列划分 题目：413. 等差数列划分 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: ​ 1, 3, 5, 7, 9​ 7, 7, 7, 7​ 3, -1, -5, -9 以下数列不是等差数列。 ​ 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组： 元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。 函数要返回数组 A 中所有为等差数组的子数组个数。 示例: A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 方法：动态规划思路：动态规划，状态转移方程为：dp[i] += dp[i - 1] + 1;（A[i- 2]、A[i - 1]、A[i]成等差数列，dp[i]表示前i个数组元素的等差数列个数）。 运行数据：执行用时：0 ms，内存消耗：36.5 MB 复杂度分析： 时间复杂度：O(n)，n为A的元素个数，只需遍历n - 2次即可得到结果。 空间复杂度：O(n)，n为A的元素个数，dp数组所消耗的空间。 1234567891011121314// LeetCode指定调用方法 public int numberOfArithmeticSlices(int[] A) { int n = A.length; int[] dp = new int[n]; int count = 0; for (int i = 2; i &lt; n; i++) { if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) { dp[i] += dp[i - 1] + 1; count += dp[i]; } } return count;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/09/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"},{"title":"435. 无重叠区间","text":"leetcode 435. 无重叠区间 题目：435. 无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 1.可以认为区间的终点总是大于它的起点。 2.区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 方法一：贪心思路：先使用贪心计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次不重叠区间的选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 运行数据：执行用时：4 ms，内存消耗：39.5 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public int eraseOverlapIntervals(int[][] intervals) { // 如果区间为空，则直接返回0 int count = intervals.length; if (count == 0) return 0; // 根据区间结尾排序从小到大排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 选择结尾最小，并且和前一个区间不重叠的区间 int number = 1; int index = 0; for (int i = 1; i &lt; count; i++) { if (intervals[index][1] &lt;= intervals[i][0]) { number++; index = i; } } // 总个数减去最大不重叠区间的个数 return count - number;} 方法二：动态规划思路：使用动态规划计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。对区间按区间结尾从小到大排序，方便使用动态规划时判断是否重叠， 动态转移方程为：dp[i]=max(dp[i], dp[j] + 1) 其中dp[i]表示从第0个区间到第i个区间的最大不重叠区间的个数，dp[j]表示从第0个区间到第j个区间的最大不重叠区间的个数，0 &lt;= j &lt; i。 运行数据：执行用时：224 ms，内存消耗：40 MB 1234567891011121314151617181920212223242526272829303132333435// LeetCode指定调用方法public int eraseOverlapIntervals(int[][] intervals) { // 如果区间为空，则直接返回0 int count = intervals.length; if (count == 0) return 0; // 根据区间结尾排序从小到大排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 动态规划 int[] dp = new int[count]; int number = 1; dp[0] = 1; // 求出dp for (int i = 1; i &lt; count; i++) { // 遍历第个i区间前的dp，判断是否能与第i个区间不重叠，通过遍历得出能与第i个区间不重叠的拥有最大不重叠区间个数的dp，将其加上第i个区间，则为dp[i] for (int j = i - 1; j &gt;= 0; j--) { // 判断第i个区间是否与第j个区间重叠 if (intervals[i][0] &gt;= intervals[j][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } // 记录当前的最大不重叠区间的个数 number = Math.max(number, dp[i]); } // 总个数减去最大不重叠区间的个数 return count - number;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/13/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"},{"title":"416. 分割等和子集","text":"leetcode 416. 分割等和子集 题目：416. 分割等和子集 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例1: 输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例2: 输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集.输入的字符串只含有小写英文字符。 方法：动态规划思路：动态规划。状态转移方程为：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])。dp[j]表示剩余空间为j时所能装下的最体积。把nums中的数字看作体积。将是否可以将这个数组分割成两个子集，使得两个子集的元素和相等这个问题转换成是否能从使数组中的选择一些元素，使得这些元素的和刚好为数组所有元素总和的一半。然后将其装换成01背包问题，判断当背包空间为数组所有元素总和的一半时，所装入的体积最大是否等于背包空间，如果相等则说明可以从使数组中的选择一些元素，使得这些元素的和刚好为数组所有元素总和的一半，即说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。 运行数据：执行用时：18 ms，内存消耗：38.9 MB 复杂度分析： 时间复杂度：O(n * halfSum)，n为nums的长度，halfSum为nums的和的一半。 空间复杂度：O(halfSum)，halfSum为nums的和的一半。 123456789101112131415161718192021222324252627// LeetCode指定调用方法 public boolean canPartition(int[] nums) { int n = nums.length; if (n == 1) { return false; } int sum = 0; for (int i : nums) { sum += i; } if (sum % 2 != 0) { return false; } int halfSum = sum &gt;&gt; 1; int[] dp = new int[halfSum + 1]; for (int i = 0; i &lt; n; i++) { for (int j = halfSum; j &gt;= nums[i]; j--) { dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } return dp[halfSum] == halfSum;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/15/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"},{"title":"417. 太平洋大西洋水流问题","text":"leetcode 417. 太平洋大西洋水流问题 题目：417. 太平洋大西洋水流问题 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。 规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 提示: 输出坐标的顺序不重要 m 和 n 都小于150 示例: 给定下面的 5x5 矩阵: 太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * 大西洋 返回:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). 方法：DFS（深度优先搜索）思路：DFS（深度优先搜索），通过DFS用两个数组reachPacific、reachAtlantic分别标记所有能够到达太平洋和大西洋的位置（搜索从边界开始）,再遍及每个位置，如果同时被reachPacific和reachAtlantic标记，则说明该位置既可以到达太平洋也可以到达大西洋。 运行数据：执行用时：5 ms，内存消耗：41.1 MB 复杂度分析： 时间复杂度：O(max(m,n) * m * n)，其中 m 和 n 分别为矩阵的行数和列数。深度优先搜索的时间复杂度为O(max(m,n) * m * n)，最后的遍历的时间复杂度为O(m * n)。 空间复杂度：O(m * n)，其中 m 和 n 分别为矩阵的行数和列数。深度优先搜索的栈开销为O(m * n), 标记数组的开销也为O(m * n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] matrix) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (matrix == null || matrix.length == 0) { return result; } int m = matrix.length; int n = matrix[0].length; // 标记能够到达太平洋的位置 boolean[][] reachPacific = new boolean[m][n]; // 标记能够到达大西洋的位置 boolean[][] reachAtlantic = new boolean[m][n]; // 从边界出发搜索并标记能够到达太平洋或者大西洋的位置 for (int i = 0; i &lt; m; i++) { dfs(matrix, i, 0, reachPacific); dfs(matrix, i, n - 1, reachAtlantic); } // 从边界出发搜索并标记能够到达太平洋或者大西洋的位置 for (int i = 0; i &lt; n; i++) { dfs(matrix, 0, i, reachPacific); dfs(matrix, m - 1, i, reachAtlantic); } // 遍历找出同时能够到达太平洋和大西洋的位置 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (reachPacific[i][j] &amp;&amp; reachAtlantic[i][j]) { result.add(Arrays.asList(i, j)); } } } return result;}// 记录在上下左右四个方向的变化值private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};// DFSprivate void dfs(int[][] matrix, int a, int b, boolean[][] reach) { if (reach[a][b]) { return; } reach[a][b] = true; for (int[] d : direction) { int nextA = d[0] + a; int nextB = d[1] + b; if (nextA &lt; 0 || nextA &gt;= matrix.length || nextB &lt; 0 || nextB &gt;= matrix[0].length || matrix[a][b] &gt; matrix[nextA][nextB]) { continue; } dfs(matrix, nextA, nextB, reach); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/01/417.%20%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/"},{"title":"451. 根据字符出现频率排序","text":"leetcode 451. 根据字符出现频率排序 题目：451. 根据字符出现频率排序 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。。 示例1: 输入: “tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。 因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例2: 输入: “cccaaa”输出: “cccaaa”解释: ‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。 注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例3: 输入: “Aabb”输出: “bbAa”解释: 此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。 注意’A’和’a’被认为是两种不同的字符。 方法一：堆排序（大顶堆）思路：使用PriorityQueue,维护大顶堆。通过HashMap记录每个字符的出现次数，通过维护大顶堆将出现频率按从大到小的顺序遍历字符，在遍历过程中将字符（出现次数个字符）追加到记录结果的StringBuilder里面。 运行数据：执行用时：15 ms，内存消耗：40.7 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (char ch : s.toCharArray()) { map.put(ch, map.getOrDefault(ch, 0) + 1); } // 优先队列 PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;((o1,o2)-&gt;(map.get(o2) - map.get(o1))); queue.addAll(map.keySet()); // 拼接字符串 StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { char key = queue.poll(); int count = map.get(key); while (count-- &gt; 0) { builder.append(key); } } return builder.toString();} 方法二：堆排序（大顶堆），数组替换HashMap思路：使用PriorityQueue,维护大顶堆，在方法一的基础上进行优化，使用数组替换HashMap记录字符出现的次数。 运行数据：执行用时：5 ms，内存消耗：40.6 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 int[] freq = new int[256]; for (char ch : s.toCharArray()) { freq[ch]++; } // 优先队列 PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;((o1,o2)-&gt;(freq[o2] - freq[o1])); for (int i = 0; i &lt; freq.length; i++) { if (freq[i] == 0) continue; queue.offer((char)i); } // 拼接字符串 StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { char key = queue.poll(); int count = freq[key]; while (count-- &gt; 0) { builder.append(key); } } return builder.toString();} 方法三：桶排序思路：桶排序，将出现频率相同的放到一个桶中。通过数组记录每个字符的出现次数，在进行分桶之后，依次按出现频率从大到小遍历桶，遍历桶中的元素，在遍历桶中元素的过程中将字符（出现次数个字符）追加到记录结果的StringBuilder里面。 运行数据：执行用时：10 ms，内存消耗：41.4 MB 123456789101112131415161718192021222324252627282930313233// LeetCode指定调用方法public String frequencySort(String s) { // 记录每个元素出现的频率 int[] freq = new int[256]; for (char ch : s.toCharArray()) { freq[ch]++; } // 将每个元素放到对应的桶中 List&lt;Character&gt;[] arr = new ArrayList[s.length() + 1]; for (int i = 0; i &lt; freq.length; i++) { if (freq[i] == 0) continue; if (arr[freq[i]] == null) { arr[freq[i]] = new ArrayList&lt;&gt;(); } arr[freq[i]].add((char)i); } // 拼接字符串 StringBuilder builder = new StringBuilder(); for (int i = arr.length - 1; i &gt; 0; i--) { if (arr[i] == null) continue; for (Character item : arr[i]) { int t = i; while (t-- &gt; 0) { builder.append(item); } } } return builder.toString();} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/07/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"},{"title":"452. 用最少数量的箭引爆气球","text":"leetcode 452. 用最少数量的箭引爆气球 题目：452. 用最少数量的箭引爆气球 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend，且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 示例: 输入: [[10,16], [2,8], [1,6], [7,12]]输出: 2解释: 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 方法：贪心思路：本题主要是实现用最少的弓箭把所有的气球射爆，弓箭一次性可以射爆叠加处的所有气球，因此我们只需使用贪心找出最多的不重叠区间数即可，最多不重叠区间数即为所需的最小弓箭数，因为其他区间必然是与不重叠区间中的一个或者多个相重叠于一处的（其他区间必定会重叠于不重叠区间的开始或者结尾处），所以只需要射击不重叠区间处即可把所有气球射爆。 在每次不重叠区间的选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 运行数据：执行用时：21 ms，内存消耗：47.4 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public int findMinArrowShots(int[][] points) { // 如果区间为空，则直接返回0 int count = points.length; if (count == 0) return 0; // 根据区间结尾排序 Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[1] - o2[1]; } }); // 选择结尾最小，并且和前一个区间不重叠的区间 int number = 1; int index = 0; for (int i = 1; i &lt; count; i++) { if (points[i][0] &gt; points[index][1]) { number++; index = i; } } //返回不重叠区间数 return number;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/15/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"},{"title":"455. 分发饼干","text":"leetcode 455. 分发饼干 题目：455. 分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意: 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例1: 输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例2: 输入: [1,2], [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2。 方法：贪心 + 双指针（快慢指针）思路： 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子.因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。 首先将孩子的胃口数组和饼干尺寸数组按从小到大排序，然后使用双指针（快慢指针）的方式遍历判断当前最小尺寸的饼干是否满足当前最小胃口的孩子，若不满足，则将遍历至能够满足这个孩子的胃口的饼干尺寸处，，接着继续遍历下一个孩子的胃口和下一个饼干的尺寸，依此遍历，当孩子胃口遍历完了，或者饼干尺寸遍历完了，则运行结束。 运行数据：执行用时：7 ms，内存消耗：40.9 MB 1234567891011121314151617181920212223// LeetCode指定调用方法public int findContentChildren(int[] g, int[] s) { // 若没有孩子胃口或者没有饼干尺寸，则说明不会有一个孩子满足 if (g == null || s == null) return 0; // 对孩子胃口和饼干尺寸排序 Arrays.sort(g); Arrays.sort(s); // 分别标识孩子胃口和饼干尺寸数组遍历位置的指针 int gi = 0; int si = 0; // 双指针（快慢指针）遍历 while (gi &lt; g.length &amp;&amp; si &lt; s.length) { if (g[gi] &lt;= s[si]) gi++; si++; } // 孩子为胃口被满足了gi才会加，所以gi其实就是被满足的孩子数 return gi;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/11/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"},{"title":"46. 全排列","text":"leetcode 46. 全排列 题目：46. 全排列 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法：Backtracking（回溯）思路：Backtracking（回溯），用flag标记nums已中使用的元素，每次搜索按顺序选取一个未被标记的元素加入排列集合，当排列集合满时，将排列集合加入结果集中，本次搜索结束，将元素标记、当前排列集合复原，进行下一次搜索。 运行数据：执行用时：1 ms，内存消耗：39.9 MB 复杂度分析： 时间复杂度：O(n * n!)，n为需要排列的元素个数，O(n!)为递归的时间复杂度，将结果加入结果集的时间复杂度为O(n)。 空间复杂度：O(n)，n为需要排列的元素个数，递归栈的深度为n。 123456789101112131415161718192021222324252627282930313233343536// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); boolean[] flag = new boolean[nums.length]; backtracking(result, nums, flag, new ArrayList&lt;&gt;()); return result;}// 回溯，permuteList记录当前已排好的元素序列private void backtracking(List&lt;List&lt;Integer&gt;&gt; result, int[] nums, boolean[] flag, List&lt;Integer&gt; permuteList) { // 当排列集合满时，将排列集合加入结果集中，本次搜索结束 if (permuteList.size()== nums.length) { result.add(new ArrayList&lt;&gt;(permuteList)); return ; } // 每次搜索按顺序选取一个未被标记的元素加入排列集合 for (int i = 0; i &lt; nums.length; i++) { if (flag[i]) { continue; } flag[i] = true; permuteList.add(nums[i]); backtracking(result, nums, flag, permuteList); // 将元素标记、当前排列集合复原 permuteList.remove(permuteList.size() - 1); flag[i] = false; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/10/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"},{"title":"474. 一和零","text":"leetcode 474. 一和零 题目：474. 一和零 在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 示例1: 输入: strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3输出: 4解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,”0001”,”1”,”0” 。 示例2: 输入: strs = [“10”, “0”, “1”], m = 1, n = 1输出: 2解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。 提示: 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 ‘0’ 和 ‘1’ 组成 1 &lt;= m, n &lt;= 100 方法：动态规划思路：动态规划。状态转移方程为：dp[j][k] = Math.max(dp[j][k], dp[j - zeroCount][k - oneCount] + 1)。dp[j][k]表示装剩余0的个数为j，剩余1的个数为k时所能装下的最大字符串数量。 运行数据：执行用时：33 ms，内存消耗：38.3 MB 复杂度分析： 时间复杂度：O(l * m * n)，l为strs数组长度。 空间复杂度：O(m * n)。 123456789101112131415161718192021222324252627// LeetCode指定调用方法 public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (String str : strs) { int zeroCount = getZeroCount(str); int oneCount = str.length() - zeroCount; for (int j = m; j &gt;= zeroCount; j--) { for (int k = n; k &gt;= oneCount; k--) { dp[j][k] = Math.max(dp[j][k], dp[j - zeroCount][k - oneCount] + 1); } } } return dp[m][n];}// 获取字符串中0的个数private int getZeroCount(String s) { int count = 0; for (char c: s.toCharArray()) { if (c == '0') { count++; } } return count;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/08/02/474.%20%E4%B8%80%E5%92%8C%E9%9B%B6/"},{"title":"47. 全排列 II","text":"leetcode 47. 全排列 II 题目：47. 全排列 II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1] ] 方法：Backtracking（回溯）思路：Backtracking（回溯），用flag标记nums已中使用的元素，为避免重复排列，搜索前先对nums进行排序，每次搜索按顺序选取一个未被标记的元素加入排列集合，在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素（因为与之相等的前一个元素肯定在上一次排列中在这个位置出现过，回溯时是按顺序的），当排列集合满时，将排列集合加入结果集中，本次搜索结束，将元素标记、当前排列集合复原，进行下一次搜索。 运行数据：执行用时：1 ms，内存消耗：40.4 MB 复杂度分析： 时间复杂度：O(n * n!)，n为需要排列的元素个数，O(n!)为递归的时间复杂度，将结果加入结果集的时间复杂度为O(n)。 空间复杂度：O(n)，n为需要排列的元素个数，递归栈的深度为n。 123456789101112131415161718192021222324252627282930313233// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { // 为避免重复排列，搜索前先对nums进行排序 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(nums, result, new ArrayList&lt;&gt;(), new boolean[nums.length]); return result;}private void backtracking(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; permuteUniqueList, boolean[] flag) { if (nums.length == permuteUniqueList.size()) { result.add(new ArrayList&lt;&gt;(permuteUniqueList)); return ; } for (int i = 0; i &lt; nums.length; i++) { // 在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素，以避免重复排列 if ((i != 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !flag[i - 1]) || flag[i]) { continue; } flag[i] = true; permuteUniqueList.add(nums[i]); backtracking(nums, result, permuteUniqueList, flag); permuteUniqueList.remove(permuteUniqueList.size() - 1); flag[i] = false; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/10/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"},{"title":"51. N 皇后","text":"leetcode 51. N 皇后 题目：51. N 皇后 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例: 输入：4输出：[[“.Q..”, // 解法 1“…Q”,“Q…”,“..Q.”], [“..Q.”, // 解法 2“Q…”,“…Q”,“.Q..”]] 解释: 4 皇后问题存在两个不同的解法。 提示: 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。 方法：Backtracking（回溯）思路：Backtracking（回溯），将问题转化为为每一行的合适列放入一个皇后，通过三个集合columns、diagonals1、diagonals2分别记录已有皇后的所在的列数、所在从左上角指向右下角斜线位置的行数与列数的差、所在从左下角指向右上角斜线位置的行数与列数的和，用于皇后放置前的位置判断。运行数据：执行用时：5 ms，内存消耗：39.5 MB 复杂度分析： 时间复杂度：O(n!)，其中 n 是皇后数量。 空间复杂度：O(n * n)，其中 n 是棋盘的行列数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// LeetCode指定调用方法 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;(); char[][] grid = new char[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { grid[i][j] = '.'; } } backtracking(result, grid, n, 0); return result;}// columns、diagonals1、diagonals2分别记录已有皇后的所在的列数、所在从左上角指向右下角斜线位置的行数与列数的差、所在从左下角指向右上角斜线位置的行数与列数的和。private Set&lt;Integer&gt; columns = new HashSet&lt;Integer&gt;();private Set&lt;Integer&gt; diagonals1 = new HashSet&lt;Integer&gt;();private Set&lt;Integer&gt; diagonals2 = new HashSet&lt;Integer&gt;();private void backtracking(List&lt;List&lt;String&gt;&gt; result, char[][] grid, int n, int k) { // 当所有的行都填入了皇后，记录结果 if (n == k) { List&lt;String&gt; tempList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { tempList.add(String.valueOf(grid[i])); } result.add(tempList); return ; } // 遍历当前行的每一列，判断是否可以填入皇后 for (int i = 0; i &lt; n; i++) { if (columns.contains(i) || diagonals1.contains(k - i) || diagonals2.contains(k + i)) { continue; } grid[k][i] = 'Q'; columns.add(i); diagonals1.add(k - i); diagonals2.add(k + i); backtracking(result, grid, n, k + 1); grid[k][i] = '.'; columns.remove(i); diagonals1.remove(k - i); diagonals2.remove(k + i); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/24/51.%20N%20%E7%9A%87%E5%90%8E/"},{"title":"494. 目标和","text":"leetcode 494. 目标和 题目：494. 目标和 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例: 输入：nums: [1, 1, 1, 1, 1], S: 3输出: 5解释：-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 提示: 数组非空，且长度不会超过 20 。 初始的数组的和不会超过 1000 。 保证返回的最终结果能被 32 位整数存下。 方法一：动态规划思路：动态规划。状态转移方程为：dp[j] = dp[j] + dp[j - nums[i]]。dp[j]表示装满空间j有多少中方案。根据提意，可以把数组划分为两部分，一部分minuend为被减数（即前面加符号 + 的部分），一部分subtractive为减数（即前面加负号的部分），当sum(minuend) - sum(subtractive) = S，即为一种方案数，将该等式左右两边同时加上sum(minuend)、sum(subtractive)，得到sum(minuend) - sum(subtractive) + sum(minuend) + sum(subtractive) = S + sum(minuend) + sum(subtractive)，又sum(nums) = sum(minuend) + sum(subtractive),化简可得sum(minuend) = (S + sum(nums)) / 2。由上述等式可得，我们只需从nums挑选几个元素使得它们的和刚好等于sum(minuend)，即为一种方案数。从而将问题转换为01背包的变种问题，即从n个元素的数组中，挑选出几个元素使得刚好装满空间为sum(minuend)的背包的方案数。 运行数据：执行用时：3 ms，内存消耗：36.6 MB 复杂度分析： 时间复杂度：O(n * target)，n为nums的长度，target = (sum + S) / 2，sum为nums的所有元素之和。 空间复杂度：O(target)，target = (sum + S) / 2，sum为nums的所有元素之和。 1234567891011121314151617181920212223// LeetCode指定调用方法 public int findTargetSumWays(int[] nums, int S) { int sum = 0; for (int i : nums) { sum += i; } if (sum &lt; S || ((sum + S) &amp; 1) == 1) { return 0; } int target = (sum + S) / 2; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) { for (int j = target; j &gt;= nums[i]; j--) { dp[j] = dp[j] + dp[j - nums[i]]; } } return dp[target];} 方法二：DFS（深度优先搜索）思路：DFS（深度优先搜索）。数组中每个元素都可以分别使用+和-去计算，如果最后等于S就计入1次。 运行数据：执行用时：645 ms，内存消耗：36.7 MB 复杂度分析： 时间复杂度：O(2^n)，递归深度为n。 空间复杂度：O(n)，递归深度为n。 123456789101112131415// LeetCode指定调用方法 public int findTargetSumWays(int[] nums, int S) { return dfs(nums, S, 0);}// DFS(深度优先搜索)private int dfs(int[] nums, int S, int t) { if (t == nums.length) { return S == 0 ? 1 : 0; } return dfs(nums, S - nums[t], t + 1) + dfs(nums, S + nums[t], t + 1);} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/08/01/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/"},{"title":"524. 通过删除字母匹配到字典里最长单词","text":"leetcode 524. 通过删除字母匹配到字典里最长单词 题目：524. 通过删除字母匹配到字典里最长单词 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例1: 输入：s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出：”apple” 示例2: 输入：s = “abpcplea”, d = [“a”,”b”,”c”]输出：”a” 示例3: 1.所有输入的字符串只包含小写字母。2.字典的大小不会超过 1000。3.所有输入的字符串长度不会超过 1000。 方法：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针指向字符串s，一个指针指向字典字符串d(i)。 运行数据：执行用时：11 ms，内存消耗：40 MB 123456789101112131415161718192021222324252627282930313233343536373839404142// LeetCode指定调用方法public String findLongestWord(String s, List&lt;String&gt; d) { // 最长字串 String longestWord = \"\"; int len = s.length(); for (String string : d) { int len1 = longestWord.length(), len2 = string.length(); if (len &gt; len2) { if (len1 &lt; len2 || (len1 == len2 &amp;&amp; string.compareTo(longestWord) &lt; 0)) { if (isSubstr(s, len, string, len2)) { longestWord = string; } } } else if (len == len2 &amp;&amp; s.compareTo(string) == 0) { return string; } } return longestWord;}// 双指针（快慢指针）算法，判断是否为子串public boolean isSubstr(String s, int len, String string, int len2) { int i = len - 1, j = len2 - 1; while (i &gt;= j &amp;&amp; i &gt;= 0 &amp;&amp; j &gt;= 0) { if (s.charAt(i) == string.charAt(j)) { j--; } i--; } return j == -1;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/26/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"5. 找出旋转有序数列的中间值","text":"XMOJ 5. 找出旋转有序数列的中间值 题目：5. 找出旋转有序数列的中间值 描述: 给出一个有序数列随机旋转之后的数列，如原有序数列为：[0,1,2,4,5,6,7] ，旋转之后为[4,5,6,7,0,1,2]。 假定数列中无重复元素，且数列长度为奇数。 求出旋转数列的中间值。如数列[4,5,6,7,0,1,2]的中间值为4。 输入: 4,5,6,7,0,1,2 输出: 4 输入样例: 11,2,34,5,6,7,0,1,212,13,14,5,6,7,8,9,10 输出样例: 1249 方法：数学思路：通过一次循环找到数列中最大数字的索引maxIndex，通过以下公式即可得到中间值的索引：(maxIndex + n / 2 + 1) % n，n为数列的长度。 运行数据：最大执行时间：87.20 ms，最大内存开销：17356 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(n)，n为一组输入数据的个数，循环一次输入数据。 空间复杂度：O(n)，n为一组输入数据的个数，主要为保存拆分字符串的字符串数组的空间消耗。 12345678910111213141516171819202122232425import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNextLine()) { line = scan.nextLine().trim(); String[] strs = line.split(\",\"); int n = strs.length; int pre = Integer.MIN_VALUE; int maxIndex = 0; for (int i = 0; i &lt; n; i++) { int current = Integer.valueOf(strs[i]); if (current &lt; pre) { break; } pre = current; maxIndex = i; } System.out.println(strs[(maxIndex + n / 2 + 1) % n]); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/05/5.%20%E6%89%BE%E5%87%BA%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E5%88%97%E7%9A%84%E4%B8%AD%E9%97%B4%E5%80%BC/"},{"title":"559. N 叉树的最大深度","text":"leetcode 559. N 叉树的最大深度 题目：559. N 叉树的最大深度 给定一个 N 叉树，找到其最大深度。数，你都可以从 + 或 -中选择一个符号添加在前面。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 示例1: 输入: root = [1,null,3,2,4,null,5,6]输出: 3 示例2: 输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出: 5 提示: 树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。 方法：BFS（广度优先搜索）思路：BFS（广度优先搜索），将子节点作为扩展方向，进行BFS搜索。 运行数据：执行用时：3 ms，内存消耗：38.7 MB 复杂度分析： 时间复杂度：O(n)，n为节点数。 空间复杂度：O(n)，n为节点数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// LeetCode指定调用方法 public int maxDepth(Node root) { // 记录深度 int depth = 0; // 根节点为null，则直接返回深度0 if (root == null) { return depth; } // 用于BFS的队列 Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); // 将第一个数入队 queue.offer(root); // 记录当前队列的长度，当队列为空时，BFS全部搜索结束（用以代替 queue.isEmpty() 增加每次循环判断时的效率） int queueLength = 1; // BFS while (queueLength &gt; 0) { // 记录当前扩展轮的数的个数 int currQueueLength = queueLength; // 扩展当前轮次的数 while (currQueueLength-- &gt; 0 ) { // 将队列中第一个数出队 Node currNode = queue.poll(); // 更新当前队列长度 queueLength--; // 如果没有子节点，则跳过扩展 if (currNode.children == null) { continue; } // 遍历子节点，扩展搜索 for (Node node : currNode.children) { // 将扩展数入队 queue.offer(node); // 更新当前队列长度 queueLength++; } } // 更新深度 depth++; } return depth;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2021/03/18/559.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"53. 最大子序和","text":"leetcode 53. 最大子序和 题目：53. 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 方法：贪心思路：遍历数组，对于第i个数，计算以i为终点的最大序列和。如果以 i-1 为终点的最大序列和为正数，则加上它，否则抛弃。 运行数据：执行用时：1 ms，内存消耗：40 MB 123456789101112// LeetCode指定调用方法public int maxSubArray(int[] nums) { int maxValue = nums[0]; int preValue = nums[0]; for (int i = 1; i &lt; nums.length; i++) { preValue = Math.max(nums[i], preValue + nums[i]); maxValue = Math.max(maxValue, preValue); } return maxValue;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/29/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"547. 朋友圈","text":"leetcode 547. 朋友圈 题目：547. 朋友圈 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例1: 输入:[[1,1,0],[1,1,0],[0,0,1]]输出: 2说明: 已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例2: 输入:[[1,1,0],[1,1,1],[0,1,1]]输出: 1说明: 已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 *注意: * N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 方法一：DFS（深度优先搜索）思路：DFS（深度优先搜索），把 M 看成图的邻接矩阵，将问题转换成求图中数的数量。用visited数组标记图中的节点是否被访问，通过M数组作为邻接矩阵判断节点之间的关系。 运行数据：执行用时：1 ms，内存消耗：40.6 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445int m;// LeetCode指定调用方法 public int findCircleNum(int[][] M) { // 记录结果 int result = 0; m = M.length; // 标记图中的节点是否被访问 int[] visited = new int[m]; for (int i = 0; i &lt; m; i++) { // 如果节点i未被搜索则可以进行DFS搜索 if (visited[i] == 0) { // DFS搜索 dfs(M, visited, i); // 更新结果 result++; } } return result;}// DFSprivate void dfs(int[][] M, int[] visited, int i) { for (int j = 0; j &lt; m; j++) { // 如果节点i与节点j相连且节点j没有被访问过则可继续搜索 if (M[i][j] == 1 &amp;&amp; visited[j] == 0) { // 被搜索过的节点赋值为1 visited[j] = 1; // 继续搜索 dfs(M, visited, j); } }} 方法二：并查集思路：并查集，将问题转换成并查集，合并所有有关系的元素后的集合的个数即为结果。 运行数据：执行用时：1 ms，内存消耗：40.6 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// LeetCode指定调用方法 public int findCircleNum(int[][] M) { // 记录结果 int result = 0; int m = M.length; // 记录父节点（parent[i] = 0，表示元素i的父元素为0） int[] parent = new int[m]; // 初始化，将每个学生看作一个单元素集合，父节点值赋值为-1（表示当前元素即为根节点） for (int i = 0; i &lt; m; i++) { parent[i] = -1; } // 合并M中所有有关系的元素集合 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; i; j++) { if (M[i][j] == 1) { union(parent, i, j); } } } // 统计并查集中合并所有有关系的元素后的集合的数量（数量即为结果） for (int i = 0; i &lt; m; i++) { if (parent[i] == -1) { result++; } } return result;}// 查找private int find(int[] parent, int x){ if (parent[x] == -1) { return x; } return find(parent, parent[x]);}// 合并private void union(int[] parent, int a, int b){ int rootA = find(parent, a); int rootB = find(parent, b); if (rootA != rootB) { parent[rootA] = rootB; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/26/547.%20%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"title":"6. 交叉队列","text":"XMOJ 6. 交叉队列 题目：6. 交叉队列 描述: 给出三个队列 s1，s2，s3 ，判断 s3 是否是由 s1 和 s2 交叉得来。 如：s1 为 aabcc ， s2 为 dbbca。 当 s3 为 aadbbcbcac 时，返回 true（即将 s1 拆成三部分： aa，bc，c 分别插入 s2 对应位置） 否则返回 false。 输入: aabcc,dbbca,aadbbcbcac 输出: true 输入样例: aabcc,dbbca,aadbbcbcacaabcc,dbbca,aadbbbaccca,b,aba,b,baa,b,acabc,bca,bcaabcabc,bca,aabbcc 输出样例: truefalsetruetruefalsetruefalse 方法：动态规划思路：动态规划。当arr3[i + j - 1] == arr1[i - 1]时，dp[i][j] = dp[i][j] | dp[i - 1][j]。当arr3[i + j - 1] == arr1[j - 1]时，dp[i][j] = dp[i][j] | dp[i][j - 1]。arr1、arr2、arr3代表s1、s2、s3，dp[i][j]表示arr1的前i个字符和arr2的前j个字符是否能够组成arr3前i + j个字符，等于1表示能组成，等于0表示不能组成。 运行数据：最大执行时间：85.43 ms，最大内存开销：17352 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(n * m)，n为s1的长度，m为s2的长度。 空间复杂度：O(n * m)，n为s1的长度，m为s2的长度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNextLine()) { line = scan.nextLine().trim(); String[] strs = line.split(\",\"); System.out.println(judge(strs)); } } private static boolean judge(String[] strs) { char[] arr1 = strs[0].toCharArray(); char[] arr2 = strs[1].toCharArray(); char[] arr3 = strs[2].toCharArray(); int len1 = arr1.length; int len2 = arr2.length; int len3 = arr3.length; if (len3 != len1 + len2) { return false; } if (len1 == 0) { return strs[1].equals(strs[2]); } if (len2 == 0) { return strs[0].equals(strs[2]); } int[][] dp = new int[len1 + 1][len2 + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= len1; i++) { if (arr1[i - 1] == arr3[i - 1]) { dp[i][0] = dp[i - 1][0]; } } for (int i = 1; i &lt;= len2; i++) { if (arr2[i - 1] == arr3[i - 1]) { dp[0][i] = dp[0][i - 1]; } } for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (arr3[i + j - 1] == arr1[i - 1]) { dp[i][j] = dp[i][j] | dp[i - 1][j]; } if (arr3[i + j - 1] == arr2[j - 1]) { dp[i][j] = dp[i][j] | dp[i][j - 1]; } } } return dp[len1][len2] == 1; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/06/6.%20%E4%BA%A4%E5%8F%89%E9%98%9F%E5%88%97/"},{"title":"605. 种花问题","text":"leetcode 605. 种花问题 题目：605. 种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例1: 输入: flowerbed = [1,0,0,0,1], n = 1输出: True 示例2: 输入: flowerbed = [1,0,0,0,1], n = 2输出: False 提示: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 方法：贪心思路：从头开始一个一个判断是否可以种植花卉。 运行数据：执行用时：1 ms，内存消耗：41.5 MB 1234567891011121314151617// LeetCode指定调用方法public boolean canPlaceFlowers(int[] flowerbed, int n) { int len = flowerbed.length; for (int i = 0; i &lt; len; i++) { if (flowerbed[i] == 1) continue; int pre = i == 0 ? 0 : flowerbed[i - 1]; int next = i == len - 1 ? 0 : flowerbed[i + 1]; if (pre == 0 &amp;&amp; next == 0) { flowerbed[i] = 1; n--; } } return n &lt;= 0;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/23/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"},{"title":"62. 不同路径","text":"leetcode 62. 不同路径 题目：62. 不同路径 一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 问总共有多少条不同的路径？ 示例1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例2: 输入: m = 7, n = 3输出: 28 提示: 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9 方法一：动态规划思路：动态规划，状态转移方程为：dp[i][j] = dp[i][j - 1] + dp[i - 1][j]，dp[i][j]表示到达i，j位置的不同路径数。运行数据：执行用时：0 ms，内存消耗：35.6 MB 复杂度分析： 时间复杂度：O(m * n)。 空间复杂度：O(m * n)。 123456789101112131415161718192021// LeetCode指定调用方法 public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) { dp[i][0] = 1; } for (int i = 1; i &lt; n; i++) { dp[0][i] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } } return dp[m - 1][n - 1];} 方法二：动态规划(优化空间复杂度)思路：在思路一的基础上将记录动态规划的二维数组压缩成一维数组，状态转移方程为：dp[j] = dp[j - 1] + dp[j]，dp[j]表示到达第j列的不同路径数。运行数据：执行用时：0 ms，内存消耗：35.6 MB 复杂度分析： 时间复杂度：O(m * n)。 空间复杂度：O(n)。 123456789101112131415// LeetCode指定调用方法 public int uniquePaths(int m, int n) { int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[j] = dp[j - 1] + dp[j]; } } return dp[n - 1];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/02/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"633. 平方数之和","text":"leetcode 633. 平方数之和 题目：633. 平方数之和 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1: 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 方法一：双指针（对撞指针）思路：由题意可得a^2、b^2的最小值为0，最大值不能大于c。由于是平方和，且只需判断是否存在，因此负整数对结果没影响 ；由于负整数的平方值跟他对应的正整数的平方值相等，所以只需考虑非负整数即可；综上所述，可使用双指针一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 运行数据：执行用时：2 ms，内存消耗：36.2 MB 123456789101112131415161718192021// LeetCode指定调用方法public boolean judgeSquareSum(int c) { // i标识头指针位置，j标识尾指针位置，通过sqrt确定尾指针最大值，在确定头指针最小值 int i = 0, j = (int)Math.sqrt(c), sum = 0; i = (int)Math.sqrt(c - j * j); // 双指针（对撞指针）算法 while (i &lt;= j) { sum = i * i + j * j; if (sum == c) { return true; }else if (sum &lt; c) { i++; } else { j--; } } return false;} 方法二：直接使用sqrt思路：直接使用sqrt函数确定a的最大值，并对其进行枚举，通过b^2=c-a^2得出b平方的值，最后通过sqrt判断b平方开方取整是否等于b。 运行数据：执行用时：4 ms，内存消耗：36.4 MB 123456789101112// LeetCode指定调用方法public boolean judgeSquareSum(int c) { for (long a = 0; a * a &lt;= c; a++) { double b = Math.sqrt(c - a * a); if (b == (int) b) { return true; } } return false;} 方法三：费马平方和定理思路：根据费马平方和定理得出的：一个非负整数 c 能够表示为两个整数的平方和，当且仅当 c 的所有形如 4k+3 的质因子的幂次均为偶数。证明方法可以见 这里。 运行数据：执行用时：0 ms，内存消耗：36 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean judgeSquareSum(int c) { // 判断因子c是否满足条件，因为c是c自己的因数，幂次是奇数（幂次只能为1），若C为4k+3的形式，将不满足推论 if ((c &amp; 3) == 3) { return false; } // 判断在2到c开平方之间的因子是否满足条件 for (int i = 2; i * i &lt;= c; i++) { int count = 0; if (c % i == 0) { while (c % i == 0) { count++; c /= i; } if ((i &amp; 3) == 3 &amp;&amp; count % 2 != 0){ return false; } } } // 判断1和在c开平方到c之间的因子是否满足条件 return (c &amp; 3) != 3;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/16/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"64. 最小路径和","text":"leetcode 64. 最小路径和 题目：64. 最小路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明: 每次只能向下或者向右移动一步。 示例: 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 方法一：动态规划思路：动态规划，状态转移方程为：dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]，dp[i][j]表示到达i，j位置的数字最小和。运行数据：执行用时：3 ms，内存消耗：41.7 MB 复杂度分析： 时间复杂度：O(n * m)，n为grid的行数，m为grid的列数。 空间复杂度：O(n * m)，n为grid的行数，m为grid的列数。 12345678910111213141516171819202122232425// LeetCode指定调用方法 public int minPathSum(int[][] grid) { int n = grid.length; int m = grid[0].length; int[][] dp = new int[n][m]; dp[0][0] = grid[0][0]; for (int i = 1; i &lt; n; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } for (int i = 1; i &lt; m; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i]; } for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt; m; j++) { dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]; } } return dp[n - 1][m - 1];} 方法二：动态规划(优化空间复杂度)思路：在方法一的基础上将记录动态规划的二维数组压缩成一维数组，状态转移方程为：dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]，dp[j]表示到达第j列的数字最小和。运行数据：执行用时：3 ms，内存消耗：41.6 MB 复杂度分析： 时间复杂度：O(n * m)，n为grid的行数，m为grid的列数。 空间复杂度：O(m)，m为grid的列数。 123456789101112131415161718192021222324252627// LeetCode指定调用方法 public int minPathSum(int[][] grid) { if (grid == null || grid.length == 0 || grid[0].length == 0) { return 0; } int n = grid.length; int m = grid[0].length; int[]dp = new int[m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (j == 0){ dp[j] = dp[j]; } else if (i == 0){ dp[j] = dp[j - 1]; } else { dp[j] = Math.min(dp[j], dp[j - 1]); } dp[j] += + grid[i][j]; } } return dp[m - 1];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/01/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"646. 最长数对链","text":"leetcode 646. 最长数对链 题目：646. 最长数对链 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例: 输入: [[1,2], [2,3], [3,4]]输出: 2解释: 最长的数对链是 [1,2] -&gt; [3,4] 注意: 给出数对的个数在 [1, 1000] 范围内。 方法一：贪心思路：贪心，事先对pairs数对数组中数对的第二个数进行从小到大排序。遍历pairs，将排序后的第一个数对作为数对链的第一个数对，用ans记录当前数对链的长度，用current数组保存当前数对链中最后一个对数，继续遍历，通过比较遍历数对的第一个数是否大于数对链末尾数对中的第二个数，从而判断该遍历数对是否可以链接在数对链上，可以的话更新current、ans。由于对所有数对进行了排序，所以可以确保每次遍历数对都是在当前的最优的链接数对链的数对。 运行数据：执行用时：11 ms，内存消耗：39.4 MB 复杂度分析： 时间复杂度：O(n * log(n))，n为pairs的长度，主要是排序的时间复杂度。 空间复杂度：O(n)，n为pairs的长度，主要是排序的辅助空间。 123456789101112131415161718192021// LeetCode指定调用方法 public int findLongestChain(int[][] pairs) { Arrays.sort(pairs, (a, b) -&gt; (a[1] - b[1])); int ans = 0; int[] current = null; for (int[] is : pairs) { if (current == null) { current = is; ans = 1; } else { if (is[0] &gt; current[1]) { current = is; ans++; } } } return ans;} 方法二：动态规划思路：动态规划，状态转移方程为：dp[i] = max(dp[i], dp[j] + 1);（pairs[i][0] &gt; pairs[j][1]）。dp[i]表示以pairs[i]结尾的最长数对链长度。 运行数据：执行用时：11 ms，内存消耗：39.4 MB 复杂度分析： 时间复杂度：O(n^2)，n为pairs的长度，主要是动态规划的两层循环。 空间复杂度：O(n)，n为pairs的长度，主要是dp数组消耗的空间。 12345678910111213141516171819// LeetCode指定调用方法 public int findLongestChain(int[][] pairs) { int n = pairs.length; int ans = 0; Arrays.sort(pairs, (a, b) -&gt; (a[0] - b[0])); int[] dp = new int[n]; for (int i = 0; i &lt; n; i++) { int max = 1; for (int j = 0; j &lt; i; j++) { if (pairs[i][0] &gt; pairs[j][1]) { max = Math.max(max, dp[j] + 1); } } dp[i] = max; ans = Math.max(ans, dp[i]); } return ans;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/10/646.%20%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/"},{"title":"6674. 度度熊与数字","text":"HDOJ 6674. 度度熊与数字 2019 年百度之星·程序设计大赛 - 初赛二 6674. 度度熊与数字 6675. 度度熊与排列 6676. 度度熊与运算式 1 题目：6674. 度度熊与数字 问题描述： 度熊发现，1个， 3 以及 9 这三个数字很神奇，它们的所有的倍数的每位数字的和一定是自己的倍数。 54 是 3 的倍数，同时 5 + 4 = 9 也是 3 的倍数。在另一个例子 666 是 9 的倍数，同时 6 + 6 + 6 = 18 也是 9的倍数。 度熊又发现，除了1个， 3， 9 以外的正整数，虽然不一定满足“所有的倍数的每位数字的和一定是自己的倍数”，但也存在一些数是它们的倍数且各位数字和也是它们的倍数。888 是 12 的倍数，且他的各位数字和 8 + 8 + 8 = 24 也是 12的倍数。 现在度熊想知道，给你一个正整数V，是否存在一个数 X，从而 V 是 X 的倍数，同时它的每位数字的和也是 X 的倍数呢？请寻找所有这样的数 X。 输入： 有多组询问，第一行包含一个正整数 T代表有几组询问，随后每组测试数据占一行，包含一个正整数 V。1 ≤ T≤ 1001 ≤ V≤109 输出： 对于每一个询问，输出两行，第一行包含一个正整数 m，m 代表对于该询问的 V，有几个满足条件的 x。第二行输出 m 个数，把所有满足条件的 x 由小到大输出。 样本输入： 319666666 样本输出： 1131 3 9 6 1 2 3 6 9 18 注意： 第一个询问中，11 的各位数和为 1=1×1，本身等于1×1 都是 1 的倍数，故 1 确实为 V=1 的答案。 第三个询问中，666666 的各位数和为 36=9×4，本身等于9×7474 都是 99 的倍数，故 9 确实为 V=666666的答案，经过仔细计算后能发现，除 9 以外, 1,2,3,6,18 也都是答案。 方法：枚举思路：因为1必为所求X，所以只需从2开始枚举到numberSum(V)满足V%X== 0 &amp;&amp; numberSum(V)%X == 0的即为所求除1外的X。 运行数据：执行用时：249 MS，内存消耗：9400K 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); while (m-- &gt; 0) { int v = sc.nextInt(); StringBuilder result = new StringBuilder(\"1\"); int count = 1; int numberSum = numberSum(v); for (int i = 2; i &lt;= numberSum; i++) { if (v % i == 0 &amp;&amp; numberSum % i == 0) { result.append(\" \" + i); count++; } } System.out.println(count); System.out.println(result); } } // 求number各位数字之和 public static int numberSum(int number) { int sum = 0; while (number != 0) { sum += number % 10; number /= 10; } return sum; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/28/6674.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E6%95%B0%E5%AD%97/"},{"title":"665. 非递减数列","text":"leetcode 665. 非递减数列 题目：665. 非递减数列 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 示例1: 输入: nums = [4,2,3]输出: true解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例2: 输入: nums = [4,2,1]输出: false解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: 1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 方法：贪心思路：遍历数组，如遇到当前值比后一个值大时，根据当前的值的前后值做相应修改，以保证为非递减数列，当出现两次，当前值比后一个值大时直接返回false，如果遍历完之后只出现一次或者零次当前值比后一个值大的情况则返回true。修改时应尽可能往小了修改，从而保证能够得到非递减数列。 运行数据：执行用时：1 ms，内存消耗：41 MB 12345678910111213141516171819202122232425// LeetCode指定调用方法public boolean checkPossibility(int[] nums) { int len = nums.length; int count = 0; for (int i = 0; i &lt; len - 1; i++) { // 当前值比后一个值小时跳过，当前值比后一个值大时做相应修改 if (nums[i] &lt;= nums[i + 1]) continue; // 当出现两次，当前值比后一个值大时直接返回false count++; if (count &gt; 1) return false; // 当前一个值比后一个值大时，此时隐含着当前值比后一个大值（循环中第一个if没进去的隐含条件），前一个值比当前值小（已遍历的数据必会满足这一点），为了尽可能是被修改的值小且满足非递减数组，应将当前值赋值给后一个值 // 否则时，此时隐含着前一个值比后一个值小或者相等（否则时的条件），当前值比后一个大值，前一个值比当前值小，为了尽可能是被修改的值小且满足非递减数组，应将后一个值赋值给当前值 if (i != 0 &amp;&amp; nums[i - 1] &gt; nums[i + 1]) { nums[i + 1] = nums[i]; } else { nums[i] = nums[i + 1]; } } return true;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/27/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"},{"title":"6783. Discount","text":"HDOJ 6783. Discount 2020 年百度之星·程序设计大赛 - 初赛三 6783. Discount 6784. Game 6785. Permutation 6786. Intersection 题目：6783. Discount 问题描述： 学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。 一共有 n 种会员充值卡套餐，假设学皇这餐饭的消费为 a 元，选择第 i 种套餐，需要充值 b[i]∗a 的钱，这次吃饭可以打 c[i]×10 折，由充值的钱支付（即这次吃饭只需要从充值金额中扣除 a×c[i] 元）。以后用剩余的充值的钱吃饭不再打折。 请问学皇应该选择哪个套餐（必须选择恰好一个套餐），使得优惠的比例最大？ 优惠比例的定义是把充的钱用完以后，(本来应该付的钱 - 实际付的钱) / 本来应该付的钱。在这个题目里，实际付的钱就是这次充值的花费。 输入： 第一行一个整数 test(1≤test≤100) 表示数据组数。对于每组数据，第一行一个正整数 n(1≤n≤100) 表示套餐的数目。接下来 n 行，每行一个正整数 bi 和一个小数 c[i](0≤c[i]≤1，c[i] 最多包含两位小数)。 输出： 对于每组数据，输出一个五位小数表示最大的优惠比例。如果小数点后超过五位，四舍五入到五位。 样本输入： 122 0.53 0.1 样本输出： 0.23077 样例解释： 对于第一种套餐，优惠比例为 0.5a / (2a + 0.5a） = 0.2； 对于第二种套餐，优惠比例为 0.9a / (3a + 0.9a） = 9 / 39； 方法：模拟思路：根据题目给出的公式进行计算即可。题中给出优惠比例的计算公式为(本来应该付的钱 - 实际付的钱) / 本来应该付的钱 ，根据题意得出具体公式为(b[i] * a + (1 - c[i]) * a - b[i] * a) / b[i] * a + (1 - c[i]) * a (其中b[i] * a + (1 - c[i]) * a为本来应该付的钱，b[i] * a为实际付的钱)，化简后即为1 - c[i] / b[i] + (1 - c[i])。 运行数据：执行用时：343MS，内存消耗：14220K 12345678910111213141516171819202122import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int test = sc.nextInt(); while (test-- &gt; 0) { int n = sc.nextInt(); double result = 0; while (n-- &gt; 0) { int b = sc.nextInt(); double c = 1 - sc.nextDouble(); result = Math.max(result, Math.round(c / (b + c) * 100000) / (double)100000); } System.out.println(String.format(\"%.5f\", result)); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/27/6783.%20Discount/"},{"title":"540. 有序数组中的单一元素","text":"leetcode 540. 有序数组中的单一元素 题目：540. 有序数组中的单一元素 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例1: 输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例2: 输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 方法：二分查找思路：通过二分查找缩小区间查找，维持mid为奇数，保证0 ~ mid共包含偶数个元素，判断nums[mid]与nums[mid - 1]是否相等，相等则说明前半区间不包含只出现一次的数，将区间往后半区间缩，否则相反，当区间只包含一个元素时，即为结果。 运行数据：执行用时：0 ms，内存消耗：39.4 MB 12345678910111213141516171819202122232425262728// LeetCode指定调用方法public int singleNonDuplicate(int[] nums) { // 左右区间范围 int l = 0; int r = nums.length - 1; // 二分查找 while (l &lt; r) { // 中间位置 int mid = (l + r) / 2; // 确保mid为奇数，保证0 ~ mid共包含偶数个元素 if (mid % 2 == 0) { mid--; } // 判断nums[mid]与nums[mid - 1]是否相等，相等则说明前半区间不包含只出现一次的数，将区间往后半区间缩，否则相反 if (nums[mid] == nums[mid - 1]) { l = mid + 1; } else { r = mid - 1; } } return nums[l];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/05/540.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/"},{"title":"6675. 度度熊与排列","text":"HDOJ 6675. 度度熊与排列 2019 年百度之星·程序设计大赛 - 初赛二 6674. 度度熊与数字 6675. 度度熊与排列 6676. 度度熊与运算式 1 题目：6675. 度度熊与排列 问题描述： 度熊有一个机器，这个机器有一个 1∼M 的排列 p[1..M] 当作参数，若丢进一个长度为 M 的字符串，此机器会将此字符串重新排列后再输出，重新排列的方式为：原本第 i 个位置的字符会变到第 p[i] 个位置。 举例来说，当 M=3，p[1]=3,p[2]=1,p[3]=2，那么丢 “abc” 进入这个机器后，机器会输出”bca”;若丢进的是 “ded”，那么机器会输出 “edd”。 某天，度熊不小心忘记这个机器的参数了，只记得参数的长度是 M，于是他丢了 N 长度为 M 的字符串进去，并记录下对于每个字符串机器的输出结果，请你根据这些结果，帮度熊找回这个机器的参数。若有多组参数都满足度熊的记录，请输出字典序最小的排列作为参数。若并不存在任何参数满足度熊的记录，请输出 −1。 注：对于两个相异的排列a: a[1..M] 和 b[1..M]，我们称 a 比 b 小当且仅当 存在一个 i，满足对于所有小于 i 的 j 都有 aj=bj 且 ai&lt;bi。 输入： 有多组询问，第一行包含一个正整数 T 代表有几组询问。每组询问的第一行包含两个正整数 N,M，分别代表度熊丢进机器的字符串数目以及参数的长度。接下来还有 2×N 行，每行有一个长度为 M 的字符串，当中的第 2×i−1 行的字符串代表度熊丢进去机器的第 i 个字符串，而第 2×i 行的字符串代表机器对于第 i 个字符串的输出结果。1≤T≤1001≤N≤201≤M≤50字符串由英文小写字母(‘a’ 至 ‘z’) 组成 输出： 对于每一个询问，输出一行，若不存在任何参数满足度熊的记录，这行只包含一个整数 −1。否则这行包含一个排列，代表此机器所有可能的参数中字典序最小的那个。 样本输入： 41 3abcbca2 4aaabbaaacdcccccd3 3aaaaaabbbbbbcccccc1 1az 样本输出： 3 1 22 4 3 11 2 3-1 注意： 第一组询问中， $p[1]=3,p[2]=1,p[3]=2$ 是唯一的机器可能的参数。 第二组询问中， $p=[2,4,3,1]$ 和 $p=[3,4,2,1]$ 都是机器可能的参数，不过 $[2,4,3,1]$ 的字典序比 $[3,4,2,1]$ 还小，故必须输出 2,4,3,1。 方法：枚举思路：先确定第一个字符串的第一个机器参数，再判断其他字符串是否满足该机器参数，满足则继续确定第一个字符串的下一个机器参数，否则将重新确定第一个字符串的第一个机器参数，且从刚刚的位置开始找，若找不到其他的机器参数则认为其没有满足条件的机器参数，直接结束，若找到了，依次类推继续判断其他字符串是否满足这个机器参数。 运行数据：执行用时：343MS，内存消耗：11356K 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); while (t-- &gt; 0) { int n = sc.nextInt(); int m = sc.nextInt(); String instr[] = new String[n]; String outstr[] = new String[n]; for (int i = 0; i &lt; n; i++) { instr[i] = sc.next(); outstr[i] = sc.next(); } fun(instr, outstr, n, m); } } private static void fun(String[] instr, String[] outstr, int n, int m) { // 记录机器参数 int result[] = new int[m]; // 标记第一字符串已确定为机器参数的输出字符串序号 boolean flag[] = new boolean[m]; // 记录第一个输出字符串的位置 int number = 0; // 搜索每个位置的机器参数 for (int i = 0; i &lt; m; i++) { // 搜索第一个字符串的机器参数 boolean searchFlag = false; for (int k = number; k &lt; m; k++) { if (instr[0].charAt(i) == outstr[0].charAt(k) &amp;&amp; !flag[k]) { number = k + 1; searchFlag = true; break; } } // 判断是否有机器参数 if (!searchFlag) { System.out.println(\"-1\"); return ; } // 遍历除第一个字符串外的其他字符串是否都满足第一个字符串的机器参数 boolean tempFlag = false; for (int j = 1; j &lt; n; j++) { if (instr[j].charAt(i) != outstr[j].charAt(number - 1)) { tempFlag = true; break; } } // 满足则继续寻找下一个机器参数，否则重新确定当前位置的机器参数 if (!tempFlag) { result[i] = number; flag[number - 1] = true; number = 0; } else { i--; } } // 输出结果 for (int i = 0; i &lt; m; i++) { System.out.print(result[i]); if (i == m - 1) { System.out.println(); } else { System.out.print(\" \"); } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/30/6675.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E6%8E%92%E5%88%97/"},{"title":"6676. 度度熊与运算式 1","text":"HDOJ 6676. 度度熊与运算式 1 2019 年百度之星·程序设计大赛 - 初赛二 6674. 度度熊与数字 6675. 度度熊与排列 6676. 度度熊与运算式 1 题目：6676. 度度熊与运算式 1 问题描述： 某天度熊发现了一个由 n+1 个数字 1 组成的运算式如下： 1 op1 1 op2 1 … 1 opn 1 其中 opi 可能是 ⊕ (按位异或运算) 或是 ? (问号)。 例如当 n=5 时，式子可能长成这样：1⊕1 ? 1⊕1 ? 1 ? 1 现在，度熊想把所有的 ‘?’ 取代为 + 或 ⊕。 (贴心提示： 加法运算的优先级比按位异或运算还高) 请问取代完后此运算式可能的最大运算结果为何？ 输入： 有多组询问，第一行包含一个正整数 T 代表有几组询问，接着每组测试数据占一行，包含一个长度为 n 的字符串，仅由 ‘^’和 ‘?’组成，第 i 个字符若是 ‘^’ 就代表 opi=⊕，否则 opi 就是问号。(n 的值不会在数据中出现，请由字符串长度来判断。)1≤n≤2^21−2 所有询问的 n 的总和不超过 2×10^7 输出： 对于每一个询问输出一行包含一个整数代表答案，也就是该算式的问号被取代后可能的最大运算结果。 样本输入： 4???^^^^^ 样本输出： 2310 注意： 样例的第一组询问算式为：1?1。取代后有 2种可能 1+1和 1^1，其中 1+1=2、1^1=0，所以最大的可能值是 2。 样例的第二组询问算式为：1?1?1。取代后有 4 种可能 1+1+1,1+1^1,1^1+1和 1^1^1， 样例的第三组询问算式为：1^1^1。并不包含问号，只有唯一的运算结果 1。 样例的第四组询问算式为：1^1^1^1。并不包含问号，只有唯一的运算结果 0。 方法：异或原理思路：将字符串按^分成多个小段，把每个小段整理成为2的i次幂（幂次i不能相同， i &gt; 0）的段，从而使得不同幂次间的小段执行^时最大，再处理其他整理之后剩余的不满足2的i次幂（幂次i不能相同， i &gt; 0）的段，这些剩余的小段要么不能分解为2的i次幂（小段的值是1），要么能分解但幂次与之前分解的小段相同(若分解，合并执行^时，会相互抵消，使得最后的值变小，所以这样的小段只能将小段中的？变为^，从而使得小段的值最小，执行^时相互抵消最小) 运行数据：执行用时：1014MS，内存消耗：15832K 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); while (t-- &gt; 0) { String s = sc.next(); // 记录1的个数 int numLen = s.length() + 1; // 用split方法分段 String[] sections = s.split(\"\\\\^\"); // 分段数 int sectionLen = sections.length; // 如果分段数为0，说明源字符串s全为^ if (sectionLen == 0) { System.out.println(numLen % 2); continue; } // 将每一段整理分成多个2的i次幂（幂次i不能相同， i &gt; 0）段并执行^，余下不为2的i次幂（幂次i不能相同， i &gt; 0）的段不处理 int sum = 0; for (String section : sections) { int len = section.length() + 1; for (int i = Integer.toBinaryString(len).length() - 1; i &gt;= 1; i--) { if ((sum &amp; (1 &lt;&lt; i)) &gt; 0 || len &lt; (1 &lt;&lt; i)) continue; len -= (1 &lt;&lt; i); sum ^= (1 &lt;&lt; i); } } // 判断余下不为2的i次幂（幂次i不能相同， i &gt; 0）的段的和是否为奇数 if ((numLen - sum) % 2 &gt; 0) sum ^= 1; System.out.println(sum); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/03/6676.%20%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E8%BF%90%E7%AE%97%E5%BC%8F%201/"},{"title":"6784. Game","text":"HDOJ 6784. Game 2020 年百度之星·程序设计大赛 - 初赛三 6783. Discount 6784. Game 6785. Permutation 6786. Intersection 题目：6784. Game 问题描述： Alice 和 Bob 在玩游戏。 桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。 假设金币可以被无限细分。Alice 和 Bob 事先都不知道 x 是几，但是他们都知道 x 是一个 (0,1] 之间均匀分布的随机实数。 Alice 会等概率的被分配到其中的一堆金币，Bob 会得到另一堆。xx 的值和两堆金币的分配是相互独立的。 拿到金币以后，Alice 会马上数清自己拿到多少金币。然后 Alice 可以选择是否和 Bob 那堆换。 给定 Alice 拿到的金币数目，请问 Alice 要不要交换，使得她期望能得到的金币数目更多？ 如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。 输入： 第一行一个正整数 test (1≤test≤200000) 表示数据组数。接下来每行一个小数 p (0&lt;p≤2)，p 最多保留五位小数，表示 Alice 拿到的金币数目。 输出： 对于每组数据，输出 Yes 表示需要交换，输出 No 表示不要交换。 样本输入： 11.00000 样本输出： Yes 方法：博弈思路：博弈问题，因为x是(0,1]的，p是(0,2]的，又由于当p&gt;1的时候Alice肯定是拿的大的部分不用换，否则Alice可能拿的大的可能拿的小的，算出来的期望值为1.25x&gt;x，所以肯定换 运行数据：执行用时：2277MS，内存消耗：13972K 12345678910111213141516171819import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int test = sc.nextInt(); while (test-- &gt; 0) { if (sc.nextDouble() &lt;= 1) { System.out.println(\"Yes\"); } else { System.out.println(\"No\"); } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/27/6784.%20Game/"},{"title":"6838. BattleForWosneth","text":"HDOJ 6838. BattleForWosneth 2020 年百度之星·程序设计大赛 - 复赛 6838. BattleForWosneth 题目：6838. BattleForWosneth 问题描述： 你在打游戏的时候碰到了如下问题： 有两个人记作Alice和Bob，Bob的生命值为m，Alice的生命值很高，所以可以认为是无限的。两个人的攻击命中率分别为p%,q%。两个人轮流攻击对方。从Alice开始攻击，每次攻击的时候，如果Alice命中，那么能让对方的生命值减低11，同时自己的生命值能恢复11，如果Bob命中，那么能让对方的生命值减低11，注意Bob不会自己回血。 直到Bob的血量变为0，游戏结束。Alice想知道，游戏结束的时候，自己期望生命值变化是多少，对998244353取模。 注意这里的变化量不是绝对值，也就是如果50%的概率加一，50%的概率减一，那么期望的变化量就是0。 对于一个分数a/b，其中gcd(a,b)=1，那么我们认为这个分数对998244353取模的值为一个数c(0≤c&lt;998244353)满足bc≡a(mod998244353)。 输入： 第一行一个正整数T(1≤T≤104)表示数据组数。对于每组数据，第一行三个整数m,p,q(1≤m≤109,1≤p,q≤100)。 输出： 每组测试数据，输出一个数，表示答案。 样本输入： 24 100 1001 50 50 样本输出： 1499122177 样本输入： 第一组数据中，每次都能命中，所以Alice能恢复 4 点生命值，减低 3 点生命值，变化量必定为 1。 第二组数据中，对应的分数为 1/2，在Alice命中Bob之前，Bob能期望命中Alice 1/2 次。 方法：扩展欧几里得思路：把 p 和 q 当作攻击力，那么 Alice需要攻击 m / p 个回合才能结束，由于最后一个回合，Alice攻击完就结束了，所以Bob只攻击了 m / p - 1 个回合，所以前 m / p - 1个回合Alice的生命值变化为 (m / p - 1) * (p - q)，最后一个回合Alice的生命值变化为 p ，因此Alice的生命值的总变化为 (m / p - 1) * (p - q) + p，由于p和q原来均表示概率需要除以100，为了避免计算过程中出现小数和丢失精度的情况，可采用逆元将原本的除装换成乘，根据题目要求取余并将公式简化得到最终计算公式(m - p * inv(100)) % MOD * (p - q) % MOD * inv(p) % MOD + p * inv(100)，本题使用扩展欧几里得求逆元。 运行数据：执行用时：2823MS，内存消耗：13820K 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); long MOD= 998244353; while (T-- &gt; 0) { int m = sc.nextInt(); long p = sc.nextLong(); long q = sc.nextLong(); long result = (m - p * inv(100)) % MOD * (p - q) % MOD * inv(p) % MOD + p * inv(100); System.out.println((result + MOD) % MOD); } } private static long x,y; // 拓展欧几里得算法 private static void exgcd(long a,long b){ if(b == 0){ x = 1; y = 0; return; } exgcd(b,a % b); long k = x; x = y; y = k - a / b* y; } // 求逆元 private static long inv(long a) { long b = 998244353; exgcd(a, b); return (x + b) % b; }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/08/10/6838.%20BattleForWosneth/"},{"title":"6785. Permutation","text":"HDOJ 6785. Permutation 2020 年百度之星·程序设计大赛 - 初赛三 6783. Discount 6784. Game 6785. Permutation 6786. Intersection 题目：6785. Permutation 问题描述： 一开始有 n 个数，他们按 1…n 的顺序排列，要求交换最多 m 对数字（同一个数字可以参与多次交换），使得逆序对数目最大。 对于一个序列 A，如果存在正整数 i,j 使得 1≤i&lt;j≤n 而且 A[i]&gt;A[j]，则 &lt;A[i],A[j]&gt; 这个有序对称为 A 的一个逆序对。 输入： 第一行一个正整数 test (1≤test≤100000) 表示数据组数。对于每组数据，一行两个整数 n，m (1≤n≤1000000,0≤m≤1000000) 表示数字个数和最多可以交换的数字对数。 输出： 对于每组数据，一行一个整数表示答案。 样本输入： 61 12 02 13 14 14 2 样本输出： 001356 方法：数学思路：根据题目寻找规律，可以发现按照第一个元素跟最后一个交换、第二个元素跟倒数第二个交换这样的规律交换即可使得逆序对数目最大，巧妙利用等差数列求和公式可尽快得出结果。当交换次数m &gt;= n/2时，可实现将原来的序列全部逆序（如原序列1、2、3、4、5、6，当m &gt;= n/2时，可使得原序列变为6、5、4、3、2、1），此个序列拥有最大逆序对，可用(n - 1) * n/ 2得出逆序对数目。 当交换次数m &lt; n/2时,此时不能将原序列全部逆序（如原序列1、2、3、4、5、6，当m == 2时交换后为6、5、3、4、1、2，当m == 1时交换后为6、2、3、4、5、1，当m == 0时交换后为1、2、3、4、5、6），这时可用((n - 1) + (n - m)) * m / 2计算与前部分组合时的逆序对数（以上前面例子来说明，当m == 2时，交换后序列为6、5、3、4、2、1，前部分指的就是6、5），可用(n - 2 * m) * m计算与中间部分组合时的逆序对数（以上前面例子来说明，当m == 2时，交换后序列为6、5、3、4、2、1，中间部分指的就是3、4），可用((m - 1) + 0) * m / 2计算与后部分组合时的逆序对数（以上前面例子来说明，当m == 2时，交换后序列为6、5、3、4、2、1，后部分指的就是2、1），计算全部的逆序对数只需将前、中、后的逆序相加即可，整理可得(2 * n - m - 1) * m / 2 + (n - 2 * m) * m + (m - 1) * m / 2。 运行数据：执行用时：1294MS，内存消耗：13792K 1234567891011121314151617181920212223import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int test = sc.nextInt(); while (test-- &gt; 0) { long n = sc.nextLong(); long m = sc.nextLong(); long result = 0; if (n / 2 &lt;= m) { result = (n - 1) * n / 2; } else { result = (2 * n - m - 1) * m / 2 + (n - 2 * m) * m + (m - 1) * m / 2; } System.out.println(result); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/27/6785.%20Permutation/"},{"title":"680. 验证回文字符串 Ⅱ","text":"leetcode 680. 验证回文字符串 Ⅱ 题目：680. 验证回文字符串 Ⅱ 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例1: 输入: “aba”输出: True 示例2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 方法一：双指针（对撞指针）思路：双指针（对撞指针） ，一个从头向尾遍历，一个指针从尾向头遍历，循环一次头指针向后移一位，尾指针向前一位。若找到头指针指向的字符不等于尾指针指向的字符时，分为两种情况，一种是删除左指针指向字符，然后再次使用双指针（对撞指针）算法进行遍历判断是否是回文字符串，另一种是删除右指针指向字符，然后再次使用双指针（对撞指针）算法进行遍历判断是否是回文字符串，当有一种情况判断出是回文串时，即为回文字符串。若遍历结束还没有找到头指针指向的字符不等于尾指针指向的字符，即为回文字符串。 运行数据：执行用时：7 ms，内存消耗：40.1 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// LeetCode指定调用方法public boolean validPalindrome(String s) { // i标识头指针位置，j标识尾指针位置 int i = 0, j = s.length() - 1; // 双指针（对撞指针）算法 while (i &lt; j) { if (s.charAt(i) != s.charAt(j)) { // 删除左指针处字符 if (s.charAt(i + 1) == s.charAt(j)) { // l标识头指针位置，r标识尾指针位置 int l = i + 1, r = j; // 标识是否为回文字符串 boolean flag = true; // 双指针（对撞指针）算法 while (l &lt; r) { if (s.charAt(l) != s.charAt(r)) { flag = false; break; } else { l++; r--; } } // 如果是回文则直接返回true if (flag) { return true; } } // 删除右指针处字符 if (s.charAt(i) == s.charAt(j - 1)) { // l标识头指针位置，r标识尾指针位置 int l = i, r = j - 1; // 标识是否为回文字符串 boolean flag = true; // 双指针（对撞指针）算法 while (l &lt; r) { if (s.charAt(l) != s.charAt(r)) { flag = false; break; } else { l++; r--; } } // 如果是回文则直接返回true if (flag) { return true; } } // 如果两种情况都没有返回true，则直接返回false return false; } else { i++; j--; } } return true;} 方法二：双指针（对撞指针）简洁版思路：思路一的简洁版，代码简洁，但执行速度有所下降 运行数据：执行用时：9 ms，内存消耗：39.9 MB 123456789101112131415161718// LeetCode指定调用方法public boolean validPalindrome(String s) { for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(i + 1, j, s) || isPalindrome(i, j - 1, s); } } return true;}public boolean isPalindrome(int i, int j, String s) { for (; i &lt; j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return false; } } return true;} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/20/680.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/"},{"title":"695. 岛屿的最大面积","text":"leetcode 695. 岛屿的最大面积 题目：695. 岛屿的最大面积 给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。) 示例1: [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 示例2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 方法：DFS（深度优先搜索）思路：DFS（深度优先搜索），遍历矩阵，值为1时进行一次DFS，搜索所有与它水平或垂直相邻的值为1的位置，将已搜索过的1赋值为0，返回1的数量。比较每次DFS返回的结果，将最大的结果返回。 运行数据：执行用时：2 ms，内存消耗：40 MB 123456789101112131415161718192021222324252627282930313233343536373839// LeetCode指定调用方法 public int maxAreaOfIsland(int[][] grid) { int maxArea = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { // 值为1时进行一次DFS if (grid[i][j] == 1) { maxArea = Math.max(maxArea, dfs(grid, i, j)); } } } return maxArea;}// DFSprivate int dfs(int[][] grid, int a, int b) { // 该位置已超出矩阵限制或该位置值为0，结束搜索 if (a &lt; 0 || b &lt; 0 || a &gt;= grid.length || b &gt;= grid[0].length || grid[a][b] == 0) { return 0; } // 将已搜索过的1赋值为0 grid[a][b] = 0; // 记录1的个数 int area = 1; // 递归搜索4个方向 area += dfs(grid, a + 1, b); area += dfs(grid, a - 1, b); area += dfs(grid, a, b + 1); area += dfs(grid, a, b - 1); return area;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/22/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"},{"title":"6786. Intersection","text":"HDOJ 6786. Intersection 2020 年百度之星·程序设计大赛 - 初赛三 6783. Discount 6784. Game 6785. Permutation 6786. Intersection 题目：6786. Intersection 问题描述： Mr. Left 来到了一个路口，这个路口只能右转，并且都是两车道。 现在在南北向车道上有 n 辆车，他们都在线 x 南边，这些车想要通过这个路口，到东边去，具体地说，他们要开到线 y 东边。 一辆车一个时刻可以从东南西北中选一个方向移动一个位置，或者呆在原地不动。 同一时刻同一位置不能有超过一辆车。车不能开到路外面。 在任意时刻，所有车都同时移动。两辆相邻的车不能都移动到对方的格子上。在此基础上，只要所有车移动后不存在两辆车处于同一位置，移动就合法。 问最少要多少时间，这些车才可以都开到东边？ 输入： 第一行一个整数 test (1≤test≤10)。对于每组数据，第一行一个整数 n (1≤n≤100000)，表示车辆数目。接下来 n 行，每行两个整数 x，y 表示车的位置，其中 x 表示车道 id（ x=1 表示右车道，x=2 表示左车道），y (1≤y≤100000) 表示车在路口前第几个位置。数据保证没有两辆车初始在同一位置。 输出： 对于每组数据，一行一个整数表示答案。 样本输入： 221 12 121 22 1 样本输出： 34 样例解释： 第一组time 0….….CC..time 1….CC......time 2…..CC.....time 3…...CC....第二组time 0….….C..Ctime 1….C….C..time 2C….C......time 3.C....C.....time 4..C.…C.... 方法：贪心思路：只需计算最后一辆车通过的时间即可，根据寻找规律，如果最后一辆车（根据从右到左，从上到下的顺序排）在左车道则全部车通过需要y + 2时间，如果最后一辆车在右车道则全部车通过需要y + 2或者y + 1时间。 当最后一辆车在右车道，倒数第二辆车在其左前方时，由于需要等待或者绕远道，所以此时全部车通过需要y + 2时间，否则只需y + 1时间。 运行数据：执行用时：2823MS，内存消耗：13820K 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int test = sc.nextInt(); while (test-- &gt; 0) { int n = sc.nextInt(); // 记录最后一辆车和倒数第二辆车的位置 int x1 = 0, y1 = 0; int x2 = 0, y2 = 0; // 遍历每一辆车的位置确定最后一辆车和倒数第二辆车的位置 while (n-- &gt; 0) { int x = sc.nextInt(); int y = sc.nextInt(); if (y &gt;= y2) { if (x &gt; x2 || y &gt; y2) { x1 = x2; y1 = y2; x2 = x; y2 = y; } else { x1 = x; y1 = y; } } else if (y &gt;= y1) { x1 = x &gt; x1 ? x : x1; y1 = y; } } // 根据最后一辆车和倒数第二辆车的位置得出结果 if (x2 == 2 || (x1 == 2 &amp;&amp; y1 == (y2 - 1))) { System.out.println(y2 + 2); } else { System.out.println(y2 + 1); } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/07/27/6786.%20Intersection/"},{"title":"69. x 的平方根","text":"leetcode 69. x 的平方根 题目：69. x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例1: 输入: 4输出: 2 示例2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 方法：二分查找思路：通过二分查找寻找寻找小于x的平方根的最大正整数。 运行数据：执行用时：2 ms，内存消耗：38.2 MB 12345678910111213141516171819// LeetCode指定调用方法public int mySqrt(int x) { int l = 0; int r = x; int result = 0; while (l &lt;= r) { int mid = (l + r) / 2; if ((long)mid * mid &gt; x) { r = mid - 1; } else { result = mid; l = mid + 1; } } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/01/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"title":"7. 第一个缺失正数","text":"XMOJ 7. 第一个缺失正数 题目：7. 第一个缺失正数 描述: 给出一个无序的数列，找出其中缺失的第一个正数，要求复杂度为 O(n) 如：[1,2,0]，第一个缺失为3。 如：[3,4,-1,1]，第一个缺失为2。 输入: 1,2,0 输出: true 输入样例: 1,2,03,4,-1,1-1,-3,-51,2,3-1,-10,0 输出样例: 32141 方法：模拟思路：用一个数组arr记录每一个输入正整数，遍历输入数据，输入数据中有正整数i则arr[i] = 1，否则arr[i] = 0。再通过从arr[1]顺序遍历arr，找到第一个arr[i] != 1 的情况，i则为第一个缺失正数。 运行数据：最大执行时间：85.22 ms，最大内存开销：17340 KiB 复杂度分析： 由于输入数据组数无法确定，时间复杂度和空间复杂度只考虑一组数据。 时间复杂度：O(n)，n为输入数据的长度。 空间复杂度：O(n)，n为输入数据的长度。 123456789101112131415161718192021222324252627282930import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scan = new Scanner(System.in); String line; while (scan.hasNextLine()) { line = scan.nextLine().trim(); if (line.equals(\"\")) { System.out.println(1); break; } String[] strs = line.split(\",\"); int[] arr = new int[strs.length + 2]; for (int i = 0; i &lt; strs.length; i++) { int index = Integer.valueOf(strs[i]); if (index &gt; 0) { arr[index] = 1; } } for (int i = 1; i &lt; arr.length; i++) { if (arr[i] != 1) { System.out.println(i); break; } } } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/07/7.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E6%AD%A3%E6%95%B0/"},{"title":"744. 寻找比目标字母大的最小字母","text":"leetcode 744. 寻找比目标字母大的最小字母 题目：744. 寻找比目标字母大的最小字母 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子：如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 示例1: 输入: letters = [“c”, “f”, “j”] target = “a” 输出: “c” 示例2: 输入: letters = [“c”, “f”, “j”] target = “c” 输出: “f” 示例3: 输入: letters = [“c”, “f”, “j”] target = “d” 输出: “f” 示例4: 输入: letters = [“c”, “f”, “j”] target = “g” 输出: “j” 示例5: 输入: letters = [“c”, “f”, “j”] target = “j” 输出: “c” 示例6: 输入: letters = [“c”, “f”, “j”] target = “k” 输出: “c” 提示: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 方法：二分查找思路：通过二分查找找到target的最小区间（最小区间最多包含两个数），右半区间数即为所求，右半区间数越界，则取字符数组中第一个字符为结果。 运行数据：执行用时：0 ms，内存消耗：39.9 MB 1234567891011121314151617// LeetCode指定调用方法public char nextGreatestLetter(char[] letters, char target) { int len = letters.length; int l = 0, h = len - 1; while (l &lt;= h) { int mid = (l + h) / 2; if (letters[mid] &lt;= target) { l = mid + 1; } else { h = mid - 1; } } return l &lt; len ? letters[l] : letters[0];} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/03/744.%20%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/"},{"title":"763. 划分字母区间","text":"leetcode 763. 划分字母区间 题目：763. 划分字母区间 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例: 输入：S = “ababcbacadefegdehijhklij”输出：[9,7,8]解释: 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 提示: S的长度在[1, 500]之间。 S只包含小写字母 ‘a’ 到 ‘z’ 。 方法一：双指针（对撞指针）思路：双指针（对撞指针），将需要划分的字符串装换成字符数组，从左到右遍历数组，假设遍历的第一个字符为’a’，再从右到左遍历数组，找到’a’最后出现的位置，依次类推找每一个字符的最后出现位置，并记录最远的字符位置，直到从左到右遍历到了当前记录的最远位置，此位置即为第一段字符串的结束位置，接着按照此方法继续找下一段字符串的结束位置。 运行数据：执行用时：10 ms，内存消耗：38.4 MB 123456789101112131415161718192021222324252627282930313233343536373839404142// LeetCode指定调用方法public List&lt;Integer&gt; partitionLabels(String S) { // 记录结果 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 将需要划分的字符串转成字符数组 char[] chars = S.toCharArray(); // 记录字符数组chars的长度 int charsLen = chars.length; // 记录当前这一段字符串最远字符位置 int index = 0; // 记录前一段字符串的结束位置长度 int preStringLength = 0; // 从左到右遍历字符数组 for (int i = 0; i &lt; charsLen; i++) { // 从右到左找从左到右遍历的字符最后出现的位置 for (int j = charsLen - 1; j &gt;= index ; j--) { if (chars[i] == chars[j]) { index = j; break; } } // 从左到右遍历到了当前记录的最远位置 if (i == index) { // 将这一段字符串的结束位置长度减去前一段字符串的结束位置长度即为当前字符串的长度 list.add(index + 1 - preStringLength); // 更新前一段字符串的结束位置长度 preStringLength = index + 1; } } return list;} 方法二：贪心思路：由于字符串都是由小写字母组成，所以可以通过一个循环用一个长度为26的字符数组记录每一个字符的最后出现位置，然后遍历需要划分的字符串，更新当前字符串的结束位置，直到遍历需要划分的字符串到当前这一段字符串的结束位置时，此位置即为这一段字符串的最终结束位置，以此类推继续找下一段字符串。 运行数据：执行用时：2 ms，内存消耗：38 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445// LeetCode指定调用方法public List&lt;Integer&gt; partitionLabels(String S) { // 记录结果 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 将需要划分的字符串转成字符数组 char[] chars = S.toCharArray(); // 记录字符数组chars的长度 int charsLen = chars.length; // 记录每个字符出现的最后位置 int[] lastPosition = new int[26]; // 循环统计每个字符出现的最后位置 for (int i = 0; i &lt; charsLen; i++) { lastPosition[chars[i] - 'a'] = i; } // 记录前一段字符串的结束位置长度 int left = 0; // 记录当前这一段字符串的结束位置长度 int right = 0; // 计算结果 for (int i = 0; i &lt; charsLen; i++) { // 更新当前这一段字符串的结束位置 right = Math.max(right, lastPosition[chars[i] - 'a']); // 当遍历到当前这一段字符串结束位置时，此位置即为这一段字符串的最终结束位置 if (i == right) { // 记录这一段字符串长度 list.add(right + 1 - left); // 更新前一段字符串的结束位置长度 left = right + 1; } } return list;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/30/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"},{"title":"75. 颜色分类","text":"leetcode 75. 颜色分类 题目：75. 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶: 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 方法一：模拟、统计思路：统计红色、白色和蓝色各自的数量，然后根据红色、白色和蓝色的顺序和各自对应的数量，重新赋值nums。 运行数据：执行用时：0 ms，内存消耗：38.1 MB 1234567891011121314151617// LeetCode指定调用方法public void sortColors(int[] nums) { // 统计红色、白色和蓝色各自的数量 int[] count = new int[3]; for (int i : nums) { count[i]++; } // 根据红色、白色和蓝色的顺序和各自对应的数量，重新赋值nums int t = 0; for (int i = 0; i &lt; count.length; i++) { while (count[i]-- &gt; 0) { nums[t++] = i; } }} 方法二：荷兰国旗问题思路：将数组视为红色、白色和蓝色（左、中、右）三个区间，使用三个变量标识区间元素位置，一开始认为整个数组都为白色区间，遍历白色区间，找到不满足白色区间的元素 ，将其与该元素对应区间的标识位置的的元素做交换，直至遍历到蓝色区间，即白色区间遍历结束为止。 运行数据：执行用时：0 ms，内存消耗：38.4 MB 123456789101112131415161718192021222324// LeetCode指定调用方法public void sortColors(int[] nums) { // 红色、白色和蓝色三个区间对应的标识指针 int red = -1, white = 0, blue = nums.length; // 遍历白色区间 while (white &lt; blue) { if (nums[white] == 0) { // 找到不满足白色区间的元素，此时该元素应为红色区间 swap(nums, ++red, white++); } else if (nums[white] == 2) { // 找到不满足白色区间的元素，此时该元素应为蓝色区间 swap(nums, white, --blue); } else { white++; } }}// 交换private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/04/09/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"},{"title":"70. 爬楼梯","text":"leetcode 70. 爬楼梯 题目：70. 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意: 给定 n 是一个正整数。 示例1: 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例2: 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 提示: 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。 方法一：动态规划思路：动态规划，状态转移方程为：f(n) = f(n - 1) + f(n - 2)，由于一次只能爬一阶或两阶楼梯，爬到n阶楼梯，必须从n - 1阶或者n - 2阶楼梯爬，所以爬到n阶楼梯的方法总数即为爬到n - 1 阶和爬到n - 2阶楼梯的方法总和。运行数据：执行用时：0 ms，内存消耗：35.4 MB 复杂度分析： 时间复杂度：O(n)，循环执行 n次。 空间复杂度：O(1)，常数个变量作为辅助空间。 12345678910111213// LeetCode指定调用方法 public int climbStairs(int n) { int f = 1, f1 = 0, f2 = 0; while (n-- &gt; 0) { f2 = f1; f1 = f; f = f1 + f2; } return f;} 方法二：Backtracking（回溯）思路：Backtracking（回溯），通过回溯找出每一种爬楼梯的方法，然后对其进行统计，虽然本题不用求爬楼梯的具体方法，使用此方法解决此题时会执行超时，但也在此提供一种解决求具体爬楼方法的思路。 复杂度分析： 时间复杂度：O(2^n)，其中 n 是楼梯总数。 空间复杂度：O(1)，常数个变量作为辅助空间。 123456789101112131415161718// LeetCode指定调用方法 public int climbStairs(int n) { int count = 0; if (n == 0) { return 1; } for (int i = 1; i &lt;= 2; i++) { if (n &gt;= i) { count += climbStairs(n - i); } } return count;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/26/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"},{"title":"78. 子集","text":"leetcode 78. 子集 题目：78. 子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明: 解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 方法：Backtracking（回溯）思路：Backtracking（回溯），将求子集问题转化成求所有可能的组合问题（循环依次求0、1、2、……、num.length个数的组合，这些组合就是它的子集），通过回溯求组合。可参考letecode 77. 组合。 运行数据：执行用时：1 ms，内存消耗：40.4 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为nums中元素的个数，生成所有子集的时间复杂度O(2^n)，复制到输出集合中的时间复杂度O(n)。 空间复杂度：O(n * 2^n)，n为nums中元素的个数，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。 123456789101112131415161718192021222324252627// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 循环依次求0、1、2、……、num.length个数的组合，这些组合就是它的子集 for (int i = 0; i &lt;= nums.length; i++) { combine(nums, result, new ArrayList&lt;&gt;(), 0, i); } return result;}// 求nums中选出k个数的所有组合private void combine(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; subsetsList, int t, int k) { if (k == 0) { result.add(new ArrayList&lt;&gt;(subsetsList)); return ; } for (int i = t; i &lt;= nums.length - k; i++) { subsetsList.add(nums[i]); combine(nums, result, subsetsList, i + 1, k - 1); subsetsList.remove(subsetsList.size() - 1); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/12/78.%20%E5%AD%90%E9%9B%86/"},{"title":"79. 单词搜索","text":"leetcode 79. 单词搜索 题目：79. 单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] 给定 word = “ABCCED”, 返回 true给定 word = “SEE”, 返回 true给定 word = “ABCB”, 返回 false 提示: board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 方法：Backtracking（回溯）思路：Backtracking（回溯），用flag标记位置是否被搜索，通过遍历board找到第一个word字母位置开始向4个方向搜索，当搜索到边界或者已被搜索过的位置或者该位置的字母不是word对应位置的字母则回退到上一步，继续搜索其他方向，当word包含的所有字母都被搜索到时，返回true，停止递归回溯。 运行数据：执行用时：8 ms，内存消耗：41.9 MB 复杂度分析： 时间复杂度：O((m * n)^2)，m为board行数，n为board的列数，最坏情况时word在二维网格board中蛇形排列，长度等于board的元素个数，此时递归层次为m * n,每次递归会拓展出4中情况，所以递归搜索的时间复杂度为O(4 * m * n) = O(m * n)， 在主函数中遍历board，以不同位置为搜索入口时的时间复杂度为O(m * n)，所以总时间复杂度为O((m * n)^2)。 空间复杂度：O(m * n)，空间消耗主要集中于递归时栈的开销，最坏情况时为O(m * n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// LeetCode指定调用方法 public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; boolean[][] flag = new boolean[m][n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if(wordSearch(board, word, flag, i, j, 0)) { return true; } } } return false;}private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};// 在二维网格board中搜索word单词，a、b记录当前搜索位置，t记录当前已搜索到的单词字母数量private boolean wordSearch(char[][] board, String word, boolean[][] flag, int a, int b, int t) { // 当单词字母全部被搜索到时，返回true if (word.length() == t) { return true; } // 当搜索到边界或者已被搜索过的位置或者该位置的字母不是word对应位置的字母时，返回false if (a &lt; 0 || b &lt; 0 || a &gt;= board.length || b &gt;= board[0].length || flag[a][b] || board[a][b] != word.charAt(t)) { return false; } // 标记已搜索到的位置 flag[a][b] = true; for (int[] d : direction) { // 当单词已被搜索完时，不在继续搜索，停止递归回溯 if (wordSearch(board, word, flag, a + d[0], b + d[1], t + 1)) { return true; } } // 复原标记 flag[a][b] = false; return false;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/06/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"},{"title":"77. 组合","text":"leetcode 77. 组合 题目：77. 组合 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4]] 方法：Backtracking（回溯）思路：Backtracking（回溯），先选一个数字，然后进入递归继续选，满足条件后加到结果中，然后回溯到上一步，继续递归(通过剪枝限制每次可选的数的范围，以提升效率)，本次在组合采用的是顺序组合的方法以避免重复组合(假设n = 4，k = 2，组合时将1与2、3、4组合，2与3、4组合，3与4组合)。 运行数据：执行用时：1 ms，内存消耗：41 MB 复杂度分析： 时间复杂度：O(k * C(k,n))，将结果加入结果集的时间复杂度为O(k)，组合的时间复杂度为C(k,n)。 空间复杂度：O(k)，递归栈的深度为k。 12345678910111213141516171819202122232425// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(1, n, k, result, new ArrayList&lt;&gt;()); return result;}// 回溯，t记录当前可选元素的开始位置，combineList记录当前的组合数private void backtracking(int t, int n, int k, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combineList) { if (k == 0) { result.add(new ArrayList&lt;&gt;(combineList)); return ; } // 剪枝（当从n个数中选k个数时，第一个数必定只能在1 ~ (n - k + 1)之间选，以保证后面还有k - 1个数可选） for (int i = t; i &lt;= n - k + 1; i++) { combineList.add(i); backtracking(i + 1, n, k - 1, result, combineList); combineList.remove(combineList.size() - 1); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/12/77.%20%E7%BB%84%E5%90%88/"},{"title":"90. 子集 II","text":"leetcode 90. 子集 II 题目：90. 子集 II 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明: 解集不能包含重复的子集。 示例: 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 方法：Backtracking（回溯）思路：Backtracking（回溯），将求子集问题转化成求所有可能的组合问题（循环依次求0、1、2、……、num.length个数的组合，这些组合就是它的子集），通过回溯求组合。可参考letecode 78. 子集。通过事先对nums排序，在回溯递归选取元素时，如果当前选取元素是同层递归的非第一选取元素且与在nums中的前一个元素相等时，直接跳过该元素的选取。 运行数据：执行用时：1 ms，内存消耗：40 MB 复杂度分析： 时间复杂度：O(n * 2^n)，n为nums中元素的个数，生成所有子集的时间复杂度O(2^n)，复制到输出集合中的时间复杂度O(n)。 空间复杂度：O(n * 2^n)，n为nums中元素的个数，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。 12345678910111213141516171819202122232425262728293031323334// LeetCode指定调用方法 public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 循环依次求0、1、2、……、num.length个数的组合，这些组合就是它的子集 for (int i = 0; i &lt;= nums.length; i++) { combine(nums, result, new ArrayList&lt;&gt;(), 0, i); } return result;}// 求nums中选出k个数的所有组合private void combine(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; subsetsList, int t, int k) { if (k == 0) { result.add(new ArrayList&lt;&gt;(subsetsList)); return ; } for (int i = t; i &lt;= nums.length - k; i++) { // 如果当前选取元素是同层递归的非第一选取元素（通过判断i &gt; t）且与在nums中的前一个元素相等时，直接跳过该元素的选取 if (i &gt; t &amp;&amp; nums[i] == nums[i - 1]) { continue; } subsetsList.add(nums[i]); combine(nums, result, subsetsList, i + 1, k - 1); subsetsList.remove(subsetsList.size() - 1); }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/14/90.%20%E5%AD%90%E9%9B%86%20II/"},{"title":"88. 合并两个有序数组","text":"leetcode 88. 合并两个有序数组 题目：88. 合并两个有序数组 给你两个有序整数数组 nums1 和 nums2*，请你将 *nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 方法：双指针（快慢指针）思路：双指针（快慢指针） ，一个指针指向nums1的尾部，一个指针指向nums2的尾部，从尾到头遍历，比较大小之后将大的一方放入到nums1尾部，指针向前移一格。 运行数据：执行用时：0 ms，内存消耗：39.7 MB 123456789101112131415// LeetCode指定调用方法public void merge(int[] nums1, int m, int[] nums2, int n) { // i标识头nums1指针位置，j标识nums2指针位置 int i = m - 1, j = n - 1; // 双指针（快慢指针）算法 while (j &gt;= 0) { if (i &lt; 0 || nums1[i] &lt; nums2[j]) { nums1[i + j + 1] = nums2[j--]; } else { nums1[i + j + 1] = nums1[i--]; } }} 相关链接： 双指针算法思想 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/22/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"HEXO","text":"HEXO的简单使用 欢迎来到Hexo! 这是您的第一篇文章。查看文档 以获取更多信息。如果在使用Hexo时遇到任何问题，可以在故障排除中 找到答案，也可以在GitHub上问我。 快速开始建立新讯息1$ hexo new \"我的新帖子\" 更多信息：写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/02/HEXO/"},{"title":"93. 复原IP地址","text":"leetcode 93. 复原IP地址 题目：93. 复原IP地址 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效的 IP 地址。 示例1: 输入：s = “25525511135”输出：[“255.255.11.135”,”255.255.111.35”] 示例2: 输入：s = “0000”输出：[“0.0.0.0”] 示例3: 输入：s = “1111”输出：[“1.1.1.1”] 示例4: 输入：s = “010010”输出：[“0.10.0.10”,”0.100.1.0”] 示例5: 输入：s = “101023”输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”] 说明: 0 &lt;= s.length &lt;= 3000 s 仅由数字组成 方法：Backtracking（回溯）思路：Backtracking（回溯），由于IP地址为4段，每一段最多只有3位数，所以回溯的递归层次为4，每层有3钟情况。 运行数据：执行用时：4 ms，内存消耗：40 MB 复杂度分析： 时间复杂度：O(1)，回溯递归的时间复杂度为O(3^4)。 空间复杂度：O(1)，回溯递归的栈开销O(4)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// LeetCode指定调用方法 public List&lt;String&gt; restoreIpAddresses(String s) { List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if (s == null || s.length() == 0) { return result; } restore(0, new StringBuilder(), s, result); return result;}private void restore(int t, StringBuilder prefix, String s, List&lt;String&gt; result) { // 如果IP段4段都找到或者给定字符串s被全部使用则递归结束 if (t == 4 || s.length() == 0) { // 如果IP段4段都找到且给定字符串s被全部使用则将该IP地址计入结果 if (t == 4 &amp;&amp; s.length() == 0) { result.add(prefix.toString()); } return ; } for (int i = 0; i &lt; s.length() &amp;&amp; i &lt;= 2; i++) { // 如果IP段首位数字为0，不符合要求，则直接结束 if (i != 0 &amp;&amp; s.charAt(0) == '0') { break; } // 截取IP段 String tempString = s.substring(0, i + 1); // 判断IP段是否小于255 if (Integer.valueOf(tempString) &lt;= 255) { if (prefix.length() != 0) { tempString = \".\" + tempString; } prefix.append(tempString); restore(t + 1, prefix, s.substring(i + 1), result); // 复原 prefix.delete(prefix.length() - tempString.length(), prefix.length()); } }} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/06/04/93.%20%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"},{"title":"95. 不同的二叉搜索树 II","text":"leetcode 95. 不同的二叉搜索树 II 题目：95. 不同的二叉搜索树 II 给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例1: 输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 提示: 0 &lt;= n &lt;= 8 方法：分治思路：通过分治的思想，枚举可行根节点将其他元素分为左右子树，左右子树都有可能会有不同的树结构，所以求最终的树结构时，要将左右子树不同树结构相组合，才能得出最终所有树结构。 运行数据：执行用时：2 ms，内存消耗：40.3 MB 123456789101112131415161718192021222324252627282930313233343536373839404142// LeetCode指定调用方法public List&lt;TreeNode&gt; generateTrees(int n) { if (n == 0) { return new LinkedList&lt;&gt;(); } else { return generateTrees(1, n); }}private List&lt;TreeNode&gt; generateTrees(int start, int end) { List&lt;TreeNode&gt; result = new LinkedList&lt;&gt;(); // 递归边界条件 if (start &gt; end) { result.add(null); return result; } // 枚举可行根节点 for (int i = start; i &lt;= end; i++) { // 获得所有可行的左子树集合 List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - 1); // 获得所有可行的右子树集合 List&lt;TreeNode&gt; rightTrees = generateTrees(i + 1, end); // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上 for (TreeNode leftTree : leftTrees) { for (TreeNode rightTree : rightTrees) { TreeNode currTree = new TreeNode(i); currTree.left = leftTree; currTree.right = rightTree; result.add(currTree); } } } return result;} 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/05/15/95.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/"},{"title":"Java基础复习一","text":"Java基础复习一 Java基础复习 Java基础复习一 Java基础复习二 1、Java是编译型的还是解释型的定义：编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！ 区别：编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。 个人认为，java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。 附：编译型的语言包括：C、C++、Delphi、Pascal、Fortran解释型的语言包括：Java、Basic、javascript 2、JDK、JRE、JVM三者间的关系JDK（Java Development Kit）即Java开发工具包，是面向开发者的，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。 JDK四个主要的文件夹： bin：最主要的是编译器(javac.exe) include：Java和JVM交互用的头文件 lib：类库 jre：Java运行环境 JRE（Java Runtime Environment）即Java运行时环境，是面向使用者的，是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。 JVM（Java Virtual Machine）即Java虚拟机，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。 三者联系： JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。 注： JDK为开发提供支持负责源代码文件（.java）编译，JRE为运行提供支持负责提供公共类库与字节码文件（.class）解释，JVM为JRE提供支持负责字节码文件（.class）的具体解释与运行。 3、常用的DOS命令 dir ：列出当前目录下的文件以及文件夹md ：创建目录rd ：删除目录cd ：进入指定目录cd.. ：退回到上一级目录cd\\ ：退回到根目录del ：删除文件exit ：退出dos命令行cls：清理屏幕命令Tab键：自动补全上下键：查找敲过的命令 4、标识符命名规则标识符只能以字符、下划线、美元符号$开头，其他部分只能由字符、下划线、美元符号$和数字组成，如”name”、”$name”、”_name$11”。 Java采用的是Unicode编码，所以字符包括中文，标识符可这样命名，如”姓名12”、”_姓名$89” 注：不建议使用中文 驼峰命名法: 变量名、方法名第一个单词首字母小写，其他单词首字母大写，如：”userName”、”selectByPrimaryKey()”。 类名每个单词的首字母大写，如：”UserLogin”、”Admin”。 5、基本数据类型 序号 数据类型 位数 默认值 取值范围 举例说明 1 byte(位) 8 0 -2^7 - 2^7-1（-128 - 127） byte b = 10; 2 short(短整数) 16 0 -2^15 - 2^15-1（-32768 - 32767） short s = 10; 3 int(整数) 32 0 -2^31 - 2^31-1（约21亿） int i = 10; 4 long(长整数) 64 0L -2^63 - 2^63-1 long l = 10L; 5 float(单精度) 32 0.0F -2^31 - 2^31-1 float f = 10.0F; 6 double(双精度) 64 0.0 -2^63 - 2^63-1 double d = 10.0; 7 char(字符) 16 ‘\\u0000’ 0 - 2^16-1 char c = ‘c’; 8 boolean(布尔值) 8 false true、false boolean b = true; 在进行整形的算术运算时，有long类型会自动转换成long类型，没有long类型会转换成int类型 12345678short a = 1;byte b = 2;short c = a + b; // 报错\"Type mismatch: cannot convert from int to short\"int d = a + b; // 无错long e = 1L;int f = a + e; // 报错\"Type mismatch: cannot convert from long to int\"long g = a + e; // 无错 小容量类型会转换成大容量类型，容量并非指字节大小 123456// float：4个字节 long：8个字节float a = 3.14F;long b = 100L;long c = a; // 报错\"Type mismatch: cannot convert from float to long\"float d = b; // 无错 数据类型按容量大小排序为: 浮点数进行运算时会出现精度问题 1234567891011121314double a = 0.2;double b = 0.1;double c = a + b;double d = a * b;System.out.println(c); // 输出为：\"0.30000000000000004\",正确结果应为\"0.3\"System.out.println(d); // 输出为：\"0.020000000000000004\",正确结果应为\"0.02\"// 使用BigDecimal可解决精度问题BigDecimal e = BigDecimal.valueOf(a);BigDecimal f = BigDecimal.valueOf(b);BigDecimal g = e.add(f);BigDecimal h = e.multiply(f);System.out.println(g); // 输出为：\"0.3\",正确结果应为\"0.3\"System.out.println(h); // 输出为：\"0.02\",正确结果应为\"0.02\" 6、运算符位运算符 ~（取反） ： 运算规则：如果位为0，结果是1，如果位为1，结果是0. 比如：~37 在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit. 8转为二进制是100101 补码后为： 00000000 00000000 00000000 00100101 取反为： 11111111 11111111 11111111 11011010 因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。 因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码： 00000000 00000000 00000000 00100110，此时二进制转原码为38 7、Java switch 语句表达式支持的数据类型 在Java5以前，表达式只能是byte，short，char，int类型 byte、short、char类型可以在不损失精度的情况下向上转型成int类型。 从Java5开始，java中引入了枚举类型（enum类型）和byte，short，char，int的包装类 四个包装类的支持是因为java编译器在底层进行了拆箱操作； 枚举类型的支持是因为枚举类有一个ordinal方法,该方法实际上是返回一个int类型的数值。 从Java7开始，exper还可以是String类型 String类中因为有一个hashCode方法,结果也是返回int类型。 总结： 到Java8为止，可以认为switch语句表达式支持byte、short、char、int、enum、Byte、Short、Character、Integer 、String共十种数据类型。底层实现目前只支持整型（int）数据。 注意： switch中可以不能有null。在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。 case语句不能重复。case字句的值是不能重复的。对于字符串类型的也一样，但是字符串中可以包含Unicode转义字符。重复值的检查是在Java编译器对Java源代码进行相关的词法转换之后才进行的。也就是说，有些case字句的值虽然在源代码中看起来是不同的，但是经词法转换之后是一样的，就会在成编译错误。比如：“男”和“\\u7537”就是一个意思。 什么情况下要使用枚举而不是用String类型。在Java 7之前switch中使用String类型的时候只能用枚举类型。而在Java 7 中由于switch语句增加了对字符串类型的支持，很多人就选择直接使用String类型。但是这样有个缺点，就是可读性差、维护麻烦。假如switch语句在多个地方出现的时候，在程序中多次出现字符串常量是一个不好的现象，而用枚举就可以避免这种情况。因此如果代码中多个地方使用swich语句来判断字符串，就考虑用枚举类型进行替换。 8、Java带标签的break 和带标签的continue以及gotolabe： 就是标签 要终止的位置 break label ：终止结束标签处的语句（switch也有效） continue label： 终止本次循环 跳到标签位置进行接下来的循环 goto：在Java中作为保留字，并没有实现它。Java中支持的break和continue虽然能实现goto语句的功能但做了一定的限制。 示例： 1234567891011121314151617181920212223// 假设要在九九乘法表的基础上加上一些限制条件，然后输出被限制后的九九乘法表// 限制条件为只输出奇数行的九九乘法表，当遇到相乘等于49时结束public static void main(String[] args) { /* * \"lable:\" 即为标签用于标识位置，标签可以像注解里这样写分两行标识for循环位置，也可以想代码中那样写一行标识for循环位置，效果是一样的。 * lable: * for (int i = 1; i &lt;= 9; i++) { // 第一层循环 */ lable:for (int i = 1; i &lt;= 9; i++) { // 第一层循环 for (int j = 1; j &lt;= i; j++) { // 第二层循环 if (i % 2 == 0) { // 当遇到奇数行时，跳过这一行的输出，使用break;直接结束第二层循环，可达到同样效果，这里使用的带标签的continue作用终止本次循环跳到标签位置进行该标签位置循环（即第一层循环）接下来的循环 continue lable; } if (i * j == 49) { // 当遇到相乘等于49时结束，结束所有循环，使用普通break;只能结束当前循环（即第二层循环，无法结束第一层循环），而使用带标签的break可以结束标签位置的循环（即可直接结束第一层循环） break lable; } System.out.print(i + \"*\" + j + \"=\" + i * j + \"\\t\"); } System.out.println(); }} 执行结果： 12341*1=1 3*1=3 3*2=6 3*3=9 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 9、Java 堆、栈、方法区的理解堆： 类的对象放在heap（堆）中，所有的类对象都是通过new方法创建，创建后，在stack（栈）会创建类对象的引用（内存地址）。 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 栈：Java栈的区域很小，只有1M，特点是存取速度很快，所以在stack中存放的都是快速执行的任务，基本数据类型的数据，和对象的引用（reference）。 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 方法区：method（方法区）又叫静态区，存放所有的①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法。 JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 学生类class Student{ String name; int age; Computer computer; void study() { System.out.println(\"我在用\" + computer.brand + \"电脑在敲代码！\"); } void play() { System.out.println(\"我在玩游戏！\"); }}// 计算机类class Computer{ String brand;}// 测试类public class Test { // 当程序运行时，首先会运行main方法 public static void main(String[] args) { // 当运行main方法，进入到main方法但没有执行具体语句时，下图中堆里的方法区中的内容已存在，栈中会出现main方法的栈帧 // 当new Student、new Computer 后堆中将会存储student、computer对象，此时成员变量值为默认值 // 当给成员变量赋值时，如赋值常量\"张三\"时，将会去方法区中取 Student student = new Student(); student.name = \"张三\"; student.age = 22; Computer computer = new Computer(); computer.brand = \"联想\"; student.computer = computer; student.study(); student.play(); // 当程序执行到这里时内存区如下图所示，注意此时main方法未结束，栈中仍有main方法的栈帧 }} 参考资料： java 堆栈，方法区(永久代)的理解 10、Java 垃圾回收机制（Garbage Collection）10.1、基本概念垃圾回收（Garbage Collection）：是Java虚拟机（JVM）垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象所占据的内存空间的一种机制。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 引用又分为强引用、软引用、弱引用、虚引用四种： 强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是java中最普遍的，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象，不管内存是否够用。 软引用（Soft Reference）：它用来描述一种可能有用，但不是必须的对象，在系统内存不够用时，这类引用会在垃圾收集器下一次回收垃圾时被回收。 弱引用（Weak Reference）：它是用来描述非必须的对象，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集器回收垃圾之前，不论系统内存是否够用，都会回收掉只被弱引用关联的对象。 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。 10.2、垃圾回收算法10.2.1、垃圾检测算法引用计数法堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“相互引用的无用对象”无法别识别。比如对象有一个对子对象的引用，子对象反过来引用父对象，它们的引用计数永远不可能为 0。因此，Java 里没有采用这样的方案来判定对象的“存活性”。 1234567891011121314151617public class Student { Student friend; public static void main(String[] args) { Student student1 = new Student(); Student student2 = new Student(); // 相互引用 student1.friend = student2; student2.friend = student1; // 虽然将两个对象赋值为null，但两个对象仍然相互引用，导致它们的引用计数器都不为 0 student1 = null; student2 = null; }} 引用可达法(根搜索算法)程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 10.2.2、垃圾收集算法标记-清除（Mark-Sweep）算法 标记-清除算法分为两个阶段： 标记阶段：标记出所有存活的对象。 清除阶段：回收未被标记的可回收对象的内部空间。 小结： 优点：算法实现较容易，不需要移动对象 缺点： 算法过程需要暂停整个应用，效率不高。 标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。 复制（Copying）算法 为了解决标志-清除算法的缺陷，由此有了复制算法。复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。 小结： 优点：实现简单，不易产生内存碎片，每次只需要对半个区进行内存回收。 缺点：内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。 标记-整理（Mark-Compact）算法 为了更充分利用内存空间，提出了标记-整理算法。此算法结合了“标记-清除”和“复制”两个算法的优点。该算法标记阶段和“标志-清除”算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 分代收集（Generational Collection）算法 分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。 年轻代：所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代：在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 Minor GC：用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC：用于清理老年代区域。 Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 垃圾回收过程： 新创建的对象，绝大多数都会存储在Eden中， 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉， ? 然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2， ? 同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中， 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC） 10.2.3、垃圾收集器（GC）不同虚拟机所提供的垃圾收集器可能会有很大差别，下面的例子是 HotSpot。 新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge。 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS。 垃圾收集器图 Serial 收集器（复制算法) 新生代单线程收集器，标记和清理都是单线程，优点是简单高效。 Serial Old收集器(标记-整理算法) 老年代单线程收集器，Serial 收集器的老年代版本。 ParNew 收集器(停止-复制算法) 新生代收集器，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。 Parallel Scavenge 收集器(停止-复制算法) 并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量 = 用户线程时间 / (用户线程时间 + GC线程时间)。适合后台应用等对交互相应要求不高的场景。 Parallel Old 收集器(停止-复制算法) Parallel Scavenge 收集器的老年代版本，并行收集器，吞吐量优先。 CMS(Concurrent Mark Sweep) 收集器（标记-清理算法） 高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。 根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代）， 参考资料： Java 垃圾回收机制整理 通用的分代垃圾回收机制 11、参数传值机制在Java中，所有的方法参数都是“值传递”，即传递的是值的副本。实参为“原件”，形参为“复印件”，改变形参不会改变实参。 基本数据类型参数的传值 传递的是值的副本。 副本改变不会影响原件。 引用数据类型参数的传值 传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。不过，当改变的是副本，即改变的只是传过来的“对象的地址”时，仍满足副本改变不会影响原件。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test { public static void main(String[] args) { Test test = new Test(); // 基本数据类型参数的传值测试 int x = 1; test.Test1(x); System.out.println(\"test1：\" + x); // 引用类型参数的传值 Person person1 = new Person(\"张三\", 18); test.Test2(person1); System.out.println(\"test2：\" + person1.name + \" \" + person1.age); Person person2 = new Person(\"张三\", 18); test.Test3(person2); System.out.println(\"test3：\" + person2.name + \" \" + person2.age); } // 基本数据类型参数的传值 public void Test1(int x) { x = 3; } // 引用类型参数的传值，改变“副本”指向的对象的值 public void Test2(Person person) { person.name = \"李四\"; person.age = 19; } // 引用类型参数的传值，改变“副本”的值 public void Test3(Person person) { person = new Person(\"王老五\", 19); }}class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; }} 运行结果 123test1：1test2：李四 19test3：张三 18 由上可知，当传递的是基本数据类型时，形参改变不会影响实参，即传递过来的“副本”不会影响“原件”（如方法test1）；当传递的是引用数据类型时，如果改变形参指向的对象时，实参指向的对象也会被改变，即改变“副本”指向的对象的值，“原件”也会被改变（如方法test2），如果只改变形参不会影响实参，即只改变“副本”不会影响“原件”（如方法test3）。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E4%B8%80/"},{"title":"Linux基础","text":"Linux基础 1、linux简介 Linux 是一种自由和开放源码的类 UNIX 操作系统。Linux 英文解释为 Linux is not Unix。Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。 Linux的发行版 Linux的发行版说简单点就是将Linux内核与应用软件做一个打包。 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 2、Linux基本目录结构 /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys： 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 3、Linux基本指令在Linux终端（命令行）种输入的内容称之为指令。 一个完整的指令的通用格式： #指令主体 [选项] [操作对象] 一个指令可以包含多个选项和多个操作对象 基础指令 ls：列出目录下的所有文件/文件夹的名称。 ls：列出当前工作目录下的所有文件/文件夹的名称。 ls 路径：列出指定路径下的所有文件/文件夹的名称。 ls 选项 路径：列出指定路径下的所有文件/文件夹的名称，并以指定格式进行显示。 ls -l 路径：列出指定路径下的所有文件/文件夹的名称，以详细列表的形式进行展示。 ls -la 路径：列出指定路径下的所有文件/文件夹的名称，以详细列表的形式进行展示（包含隐藏文件/文件夹）。 ls -lh 路径：列出指定路径下的所有文件/文件夹的名称，以详细列表的形式进行展示，并且在显示文档大小时以可读性高的形式显示。 选项”-l“、”-a“、”-h“可搭配使用，顺序没有限制。 pwd：print working directory，打印当前工作目录。 pwd：打印当前工作目录。 cd：change directory，切换当前工作目录。 cd 路径：切换当前工作目录到指定路径。 mkdir：make directory，创建目录。 mkdir 路径：创建目录（路径可以是文件夹名称也可以是包含名称的一个完整路径）。 mkdir 选项 路径： mkdir -p：当一次性创建多层不存在的目录时，添加选项”-p“，否则会报错。 mkdir 路径1 路径2：一次性创建多个目录。 touch：创建文件。 touch 路径：在指定路径创建文件（路径可以是文件名称也可以是包含名称的一个完整路径）。 touch 路径1 路径2：一次性创建多个文件。 copy：复制文档（文件/文件夹）。 cp 被复制文件路径 文件被复制到的路径：复制文件到指定位置(文件被复制到的路径不指定具体名称，默认会与原名称相同，即不指定下方图片红色框部分)。 cp -r 被复制文件夹路径 文件夹被复制到的路径：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r“（表示递归复制），否则目录将被忽略。 mv：move，移动，剪切。 mv 需要移动的文档路径 需要保存的位置路径：移动文档（文件/文件夹）到新的位置（路径可以是文档名称也可以是包含名称的一个完整路径）。 在Linux中重命名的命令也是mv，语法和移动一样。 rm：remove，移除，删除。 rm 选项 需要移除的文档路径：移除/删除文档（路径可以是文档名称也可以是包含名称的一个完整路径）。 rm 需要移除的文档路径：在删除时如果不带选项，会提示是否删除，如果需要确认输入“y”或“yes”，否则输入”n”或“no”。 rm -f 需要移除的文档路径：如果在删除的时候不想频繁确认，则可在指令中添加选项“-f”，表示force（强制）。 rm -rf 需要移除的文档路径：删除文件夹时需要递归删除，需要在指令中添加选项“-r”。如果不想频繁确认可以配合选项“-f”。 rm 选项 需要移除的文档路径1 需要移除的文档路径2：删除多个文档。 rm -rf 需要移除的文档路径：添加选项“-rf”，递归强制删除多个文档。 rm -rf /root/test*：使用通配符，递归强制删除以“/root/test”路径开头的文档。 vim：编辑文件。 vim 文件路径：使用vim打开文件。退出文件，在没有按下其他命令的时候，按下shift+英文冒号，输入q，按下回车即可。 &gt;/&gt;&gt;：输出重定向。”&gt;“：覆盖输出，”&gt;&gt;“：追加输出。将终端指令输出到指定文件。 正常执行指令 &gt;/&gt;&gt; 输出文件路径：一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 “&gt;”：覆盖输出，会覆盖掉原先的文件内容。 “&gt;&gt;”：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加。 文件可以不存在，不存在则新建。 cat：直接打开文件，输出到终端。 cat 文件路径：直接打开文件，输出到终端显示。 cat 文件路径1 文件路径2 文件路径3：直接打开多个文件，输出到终端显示。 cat 文件路径1 文件路径2 文件路径3 &gt; 合并文件路径：直接打开多个文件，配合输出重定向合并文件。 进阶指令 df：查看磁盘的空间。 df 选项：按选项指定格式查看磁盘的空间。 df：不加任何选项，直接显示磁盘空间。 df -h：添加选项“-h”，以较高可读性显示磁盘空间。 free：查看内存使用情况。 free 选项：按选项指定格式，查看内存使用情况。 free：不加任何选项，显示内存使用情况时使用kb作为单位。 free -m：添加选项“-m”，显示内存使用情况时使用mb作为单位。如果添加选项“-g”，显示内存使用情况时使用g作为单位。 剩余的真实可以用的内存为free + buff/cache。Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。 head：查看一个文件的前n行。 head -数字n：查看一个文件的前n行，如果不指定n，则默认显示前10行。 tail：查看一个文件的未n行。 tail -数字n：查看一个文件的未n行，如果n不指定默认显示后10行。 tail -f 文件路径：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动增加的），通过输出重定向可以看到效果。该命令一般用于查看系统的日志比较多。 less：查看文件，以较少的内容进行输出。 less 文件路径：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车【跳到指定数字行】、空格键【翻页】+上下方向键【上一行、下一行】）查看更多。退出的只需要按下q键即可。 wc：统计文件内容信息（包含行数、单词数、字节数）。 wc 选项 文件路径：统计文件内容信息（包含行数、单词数【根据空格来计算单词数量】、字节数）。不填加选项则输出行数、单词数、字节数。添加选项”-l“则只输出行数。添加选项”-w“则只输出单词数。添加选项”-c“则只输出字节数。选项可组合使用，如添加选项”-lw“则输出显示行数和单词数。 date：表示操作时间日期（读取、设置）。 date：输出当前的系统时间，输出形式：”2020年 10月 27日 星期二 12:54:28“。 date 参数：按指定参数格式输出时间。 date +%F：等价于date “+%Y-%m-%d”，输出形式：”2020-10-27“。 date “+F %T”：等价于date “+%Y-%m-%d %H:%M:%S”，输出形式：”2020-10-27 12:54:28“。 date 选项 参数：获取之前或者之后的某个时间。 date -d “-1 day” “+%Y-%m-%d %H:%M:%S”：按指定参数格式输出前一天的时间，输出形式：“2020-10-26 12:54:28”。 符号的可选值：+（之后） 或者 - （之前）。 单位的可选值：day（天）、month（月份）、year（年） %F：表示完整的年月日 %T：表示完整的时分秒 %Y：表示四位年份 %m：表示两位月份（带前导0） %d：表示日期（带前导0） %H：表示小时（带前导0） %M：表示分钟（带前导0） %S：表示秒数（带前导0） cal：操作日历。 cal：等价于cal -1，直接输出当前月份的日历。 cal -3：输出上一个月+本月+下个月的日历。 cal -y 年份：输出某一个年份的日历。 clear/ctrl + L：清除终端中已经存在的命令和结果（信息）。 clear：或者使用快捷键ctrl + L，清除终端中已经存在的命令和结果（信息）。需要注意的是，该命令并不是真的清除了之前的信息，而是把之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。 |：管道符。管道一般可以用于“过滤”，“特殊”，“扩展处理”。 ls /root | grep “test”：过滤处理，需要通过管道查询出根目录下包含“test”字母的文档名称。 cat /root/initial-setup-ks.cfg | less：特殊处理，等价于less /root/initial-setup-ks.cfg，通过管道的操作方法来实现less的等价效果。 ls /root | wc -l：扩展处理，通过管道，将之前学过的命令进行组合，来统计某个目录下的文档的总个数。 以管道作为分界线，管道前面的输出就是后面指令的输入，”grep“指令主要用于过滤。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/27/Linux%E5%9F%BA%E7%A1%80/"},{"title":"单例模式","text":"设计模式之单例模式 定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。 核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。 优点： 单例模式可以保证内存里只有一个实例，减少了内存的开销。 可以避免对资源的多重占用。 单例模式设置全局访问点，可以优化和共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 常见的五种单例模式实现方式： 主要： 饿汉式（线程安全，调用效率高。但是，不能延迟加载。） 懒汉式（线程安全，调用效率不高。但是，可以延迟加载。） 其他： 双重检测锁式（由于JVM底层内部模式原因，偶尔会出问题。不建议使用。） 静态内部类式（线程安全，调用效率高。但是，可以延迟加载。） 枚举单例（线程安全，调用效率高，不能延迟加载） 模式的结构与实现 单例类：包含一个实例且能自行创建这个实例的类。（如下图“SingletonTest1”） 访问类：使用单例的类。（如下图“Test”） 饿汉式1234567891011121314// 饿汉式单例模式(线程安全、调用效率高、不可延迟加载) public class SingletonTest1 { // 类初始化时，立即创建对象（没有延迟加载的优势）。加载类时，天然的是线程安全的。 private static SingletonTest1 instance = new SingletonTest1(); // 私有化构造器 private SingletonTest1() {} // 方法不需要同步，调用效率高。 public static SingletonTest1 getInstance() { return instance; }} 懒汉式1234567891011121314151617// 懒汉式单例模式(线程安全、调用效率低、可延迟加载) public class SingletonTest2 { // 类初始化时，不立即创建对象（延迟加载，真正用的时候再创建）。 private static SingletonTest2 instance; // 私有化构造器 private SingletonTest2() {} // 方法需要同步，调用效率低。 public static synchronized SingletonTest2 getInstance() { if (instance == null) { instance = new SingletonTest2(); } return instance; }} 双重检测锁式1234567891011121314151617181920212223242526272829303132333435363738// 双重检测锁式单例模式（懒汉式的升级版本，但由于指令重排问题，可能会出现问题，不建议使用）public class SingletonTest3 { // 类初始化时，不立即创建对象（延迟加载，真正用的时候再创建）。 private static SingletonTest3 instance; // 私有化构造器 private SingletonTest3() {} // 方法不一定需要同步，调用相比懒汉式平均效率高。 public static SingletonTest3 getInstance() { //首先判断是否为空 if (instance == null) { //可能多个线程同时进入到这一步进行阻塞等待 synchronized (SingletonTest3.class) { //第一个线程拿到锁，判断不为空进入下一步 if (instance == null) { /** * 由于编译器的优化、JVM的优化、操作系统处理器的优化，可能会导致指令重排（happen-before规则下的指令重排，执行结果不变，指令顺序优化排列） * new Singleton3()这条语句大致会有这三个步骤： * 1.在堆中开辟对象所需空间，分配内存地址 * 2.根据类加载的初始化顺序进行初始化 * 3.将内存地址返回给栈中的引用变量 * * 但是由于指令重排的出现，这三条指令执行顺序会被打乱，可能导致3的顺序和2调换 */ instance = new SingletonTest3(); } } } return instance; } /** * 由于指令重排导致3，2的顺序调换以及处于多线程场景，会导致以下问题的出现首先第一个线程执行到了3号指令(instance变量被分配了地址，不为null了)，但对象未初始化。此时！第一个或者第二个if语句进行判断时结果为true，自然而然在使用instance时会出错。 * 解决的方法便是在instance变量上加上volatile关键字，加上volatile关键字后会禁止该变量的指令重排，从而达到线程安全。 */} 静态内部类式12345678910111213141516// 静态内部类式单例模式(线程安全、调用效率高、可延迟加载) public class SingletonTest4 { private static class SingletonClassInstance { // final可加可不加，加载类时，天然的是线程安全的。 private static final SingletonTest4 INSTANCE = new SingletonTest4(); } // 私有化构造器 private SingletonTest4() {} // 方法不需要同步，调用效率高。 public static SingletonTest4 getInstance() { return SingletonClassInstance.INSTANCE; }} 枚举式12345678910111213141516171819202122232425262728293031323334353637// 枚举式单例模式 (线程安全、调用效率高、不可延迟加载)public enum SingletonTest5 { /** * 可避免反射和反序列漏洞破坏单例特性 */ // 这个枚举元素，本身就是单例对象 INSTANCE; // 添加自己需要的操作 public void singletonOperation() { } /** * 序列化可能会破坏单例模式，比较每次反序列化一个序列化的对象实例时都会创建一个新的实例,枚举类单例可以解决该问题。 * 枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性. */ public static void main(String[] args) throws Exception {// // 测试通过反射创建对象// Class clazz = Class.forName(\"com.crazysky.pattern.singleton.SingletonTest5\");// // 通过反射调用newInstance方法创建实例时，会判断该类是否为枚举类，是枚举类则会抛出如下异常// //java.lang.IllegalArgumentException: Cannot reflectively create enum objects// Object obj = clazz.getDeclaredConstructor(String.class,int.class).newInstance(\"LBJ\",23);// System.out.println(obj == INSTANCE); // 测试通过反序列化创建对象 File file = new File(\"test.txt\"); ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file))); oos.writeObject(INSTANCE); oos.flush(); ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file))); System.out.println(ois.readObject() == INSTANCE); // true } } 除枚举式外其他方式如何防止通过反射和反序列化创建对象，破坏单例性123456789101112131415161718192021222324252627282930313233343536373839// 以饿汉式单例模式为例public class SingletonTest6 implements Serializable{ private static SingletonTest6 instance = new SingletonTest6(); private SingletonTest6() { // 防止反射漏洞通过再次调用私有构造方法实例化新的instance if (instance != null) { throw new RuntimeException(\"禁止破坏单例性\"); } } public static SingletonTest6 getInstance() { return instance; } // 从I/O流读取对象时会调用readResolve接口，在readResolve接口中直接返回instance对象，避免反序列化时重新实例化对象 // 因为反序列化创建对象的时候，调用的是离反序列化类最近的没有序列化的超类的无参构造函数，所以虽然在当前类中的构造方法中进行了异常抛出，还是可以创建对象 private Object readResolve() { return instance; } public static void main(String[] args) throws Exception {// // 测试通过反射创建对象// Class clazz = Class.forName(\"com.crazysky.pattern.singleton.SingletonTest6\");// // java.lang.RuntimeException: 禁止破坏单例性// Object obj = clazz.getDeclaredConstructor(null).newInstance(null);// System.out.println(obj == getInstance()); // 测试通过反序列化创建对象 File file = new File(\"test.txt\"); ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file))); oos.writeObject(getInstance()); oos.flush(); ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file))); System.out.println(ois.readObject() == getInstance()); // true }} 五种实现单例模式的效率对比 实现方式 耗时 饿汉式 41ms 懒汉式 223ms 双重检测锁式 44ms 静态内部类式 40ms 枚举式 35ms 1234567891011121314151617181920212223242526// 五种实现单例模式的效率测试public class SingletonTest7 { public static void main(String[] args) throws InterruptedException { long start = System.currentTimeMillis(); int threadNum = 10; final CountDownLatch countDownLatch = new CountDownLatch(threadNum); for (int i = 0; i &lt; threadNum; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 100000; j++) {// Object obj = SingletonTest1.getInstance(); // 饿汉式 41ms// Object obj = SingletonTest2.getInstance(); // 懒汉式 223ms// Object obj = SingletonTest3.getInstance(); // 双重检测锁式 44ms// Object obj = SingletonTest4.getInstance(); // 静态内部类式 40ms Object obj = SingletonTest5.INSTANCE; // 枚举式 35ms } countDownLatch.countDown(); }).start(); } countDownLatch.await(); // main 线程阻塞，直到计数器变为0，才会往下执行 long end = System.currentTimeMillis(); System.out.println(\"耗时（ms）：\" + (end - start)); }} 相关链接： 设计模式 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/10/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"Java基础复习二","text":"Java基础复习二 Java基础复习 Java基础复习一 Java基础复习二 12、面向对象设计的基本原则 OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。 LSP（里氏替换原则，Liskov Substitution Principle）：继承必须确保超类所拥有的性质在子类中仍然成立。 DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。 SRP（单一职责原则，Single Responsibility Principle）：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。 ISP（接口隔离原则，Interface Segregation Principle）：一个类对另一个类的依赖应该建立在最小的接口上。 CRP（合成复用原则，Composite Reuse Principle）：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。 13、对象与导入（import）对象创建的四步 分配对象空间，并将对象成员变量初始化为0或空。 执行属性值的显示初始化。 执行构造方法。 返回对象的地址给相关的变量。 导入概述 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 导入同名类 当通过“import java.sql.Date;“导入了Date类，如果在同源文件中有自己写的Date类，使用时优先使用自己写的Date类，如果是在同包但不同源文件中自己写的Date类，则优先使用通过“import java.sql.Date;“导入的Date类。 当通过“import java.sql.Date;“导入了Date类，又通过“import java.util.*;”导入了util下的所有类，其中util中也包含Date类，此时使用时优先使用通过“import java.sql.Date;“导入的Date类，即优先使用精确导入的类。 当需要使用非优先使用的同名类时，需要通过“java.util.Date now2 = new java.util.Date();”这样的方式进行初始化。 123456789101112131415161718import java.sql.Date; // 精确导入import java.util.Scanner; // 导入该包下所有的类。会降低编译速度，但不会降低运行速度。public class Test{ public static void main(String[] args) { // 这里指的是java.sql.Date Date now; // java.util.Date因为和java.sql.Date类同名，由于java.util.Date是非优先使用的类，需要完整路径 java.util.Date now2 = new java.util.Date(); System.out.println(now2); // java.util包的非同名类不需要完整路径 Scanner input = new Scanner(System.in); }} 静态导入 静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 1234567891011import static java.lang.Math.*; // 导入Math类的所有静态属性import static java.lang.Math.PI; // 导入Math类的PI属性 public class Test2{ public static void main(String [] args){ System.out.println(PI); System.out.println(random()); }} 14、继承instanceof 运算符 instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。 123456789public class Test{ public static void main(String[] args) { System.out.println(new Object() instanceof Object); // 结果为true System.out.println(new Test() instanceof Object); // 结果为true }} 继承要点 父类也称作超类、基类、派生类等。 Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 Java中类没有多继承，接口有多继承。 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 方法重写要点 “==”：方法名、形参列表相同。 “≤”：返回值类型和声明异常类型，子类小于等于父类。 “≥”： 访问权限，子类大于等于父类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Student extends Person{ public Student(String name) { this.name = name; } public Student() {} // 重写父类study方法，方法名、形参列表相同 @Override public void study() { System.out.println(\"学习编程。。。\"); } // 重写父类getSelf方法，方法名、形参列表相同，返回类型为父类返回类型的子类 @Override public Student getSelf() { return new Student(\"李四\"); } public static void main(String[] args) { Student student = new Student(); student.study(); // 结果为：学习编程。。。 System.out.println(student.getSelf().name);// 结果为：李四 }}class Person { String name; public Person(String name) { this.name = name; } public Person() {} public void study() { System.out.println(\"学习。。。\"); } public Person getSelf() { return new Person(\"张三\"); }} 15、封装需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点： 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 封装的实现—使用访问控制符 Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。 访问权限范围 修饰符 同一个类 同一个包 子类 所有类 private true false false false default true true false false protected true true true false public true true true true private表示私有，只有自己类能访问 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/09/23/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E4%BA%8C/"},{"title":"建造者模式","text":"设计模式之建造者模式 定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 优点： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 缺点： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 与工厂模式的区别 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 模式的结构与实现 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。（如下图“Airship”、“OrbitalModule”、“Engine”、“EscapeTower”） 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 。（如下图“AirshipBuilder”） 具体建造者(Concrete Builder）：实现抽象建造者中的抽象方法，完成复杂产品的各个部件的具体创建。（如下图“ShenzhouAirshipBuilder”） 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。（如下图“AirshipDirector”） 调用者（Caller）：具体产品的使用者。（如下图“Client”） 1234567891011121314151617181920212223242526272829303132333435363738394041// 宇宙飞船类public class Airship { private OrbitalModule orbitalModule; // 轨道舱 private Engine engine; // 发动机 private EscapeTower escapeTower; // 逃逸塔 public void launch() { System.out.println(\"发射前准备，检查各部件：\"); System.out.println(\"轨道舱：\" + orbitalModule.getName()); System.out.println(\"发动机：\" + engine.getName()); System.out.println(\"逃逸塔：\" + escapeTower.getName()); System.out.println(\"发射！\"); } public OrbitalModule getOrbitalModule() { return orbitalModule; } public void setOrbitalModule(OrbitalModule orbitalModule) { this.orbitalModule = orbitalModule; } public Engine getEngine() { return engine; } public void setEngine(Engine engine) { this.engine = engine; } public EscapeTower getEscapeTower() { return escapeTower; } public void setEscapeTower(EscapeTower escapeTower) { this.escapeTower = escapeTower; }} 123456789101112131415161718// 轨道舱类public class OrbitalModule { private String name; public OrbitalModule(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 123456789101112131415161718// 发动机类 public class Engine { private String name; public Engine(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 123456789101112131415161718// 逃逸塔类 public class EscapeTower { private String name; public EscapeTower(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 123456789// 宇宙飞船建造接口 public interface AirshipBuilder { OrbitalModule builderOrbitalModule(); Engine builderEngine(); EscapeTower builderEscapeTower();} 123456789101112131415161718// 神舟宇宙飞船建造类 public class ShenzhouAirshipBuilder implements AirshipBuilder { @Override public OrbitalModule builderOrbitalModule() { return new OrbitalModule(\"神舟轨道舱\"); } @Override public Engine builderEngine() { return new Engine(\"神舟发动机\"); } @Override public EscapeTower builderEscapeTower() { return new EscapeTower(\"神舟逃逸塔\"); }} 1234567891011121314151617// 宇宙飞船装配指挥者类 public class AirshipDirector { private AirshipBuilder airshipBuilder; public AirshipDirector(AirshipBuilder airshipBuilder) { this.airshipBuilder = airshipBuilder; } public Airship getAirship() { Airship airship = new Airship(); airship.setOrbitalModule(airshipBuilder.builderOrbitalModule()); airship.setEngine(airshipBuilder.builderEngine()); airship.setEscapeTower(airshipBuilder.builderEscapeTower()); return airship; }} 12345678910111213141516171819// 调用者类public class Client { public static void main(String[] args) { AirshipDirector airshipDirector = new AirshipDirector(new ShenzhouAirshipBuilder()); Airship airship = airshipDirector.getAirship(); airship.launch(); /** * 输出结果如下： * * 发射前准备，检查各部件： * 轨道舱：神舟轨道舱 * 发动机：神舟发动机 * 逃逸塔：神舟逃逸塔 * 发射！ */ }} 相关链接： 设计模式 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/10/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"双指针","text":"浅谈双指针算法思想 算法思想双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。 （注：这里的指针并非专指c语言中的指针，表达的含义是下标、索引值或者是可进行迭代的对象等） 对撞指针对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。 快慢指针快慢指针是从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等或满足其他条件为止，如fast每次增长两个，slow每次增长一个。 算法总结对撞指针：可以将两重循环O(n^2)的时间复杂度转化为一重循环O(n)的线性复杂度。一般先想一个暴力O(n^2)的做法，然后找i与j之间的单调关系再进行双指针优化。当遇到有序数组时，应该优先想到用双指针来解决问题，因两个指针的同时遍历会减少空间复杂度和时间复杂度。 快慢指针：利用快慢指针创造的差值, 可节省内存空间, 减少计算次数, 常用于链表数据结构和判断循环。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/14/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"原型模式","text":"设计模式之原型模式 定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 优点： Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。 逃避构造函数的约束。 缺点： 需要为每一个类都配置一个 clone 方法。 必须实现 Cloneable 接口。 clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 深拷贝与浅拷贝 浅拷贝：当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。这种情况下，当拷贝出的某一个类修改了引用数据类型的成员变量后，会导致所有拷贝出的类都发生改变。 深拷贝：深拷贝不仅会复制成员变量为基本数据类型的值，给新对象。还会给是引用数据类型的成员变量申请储存空间，并复制引用数据类型成员变量的对象。这样拷贝出的新对象就不怕修改了是引用数据类型的成员变量后，对其它拷贝出的对象造成影响了。 实现深拷贝的方式 重写clone方法。 序列化。： 注意：重写clone方法需要每个引用变量单独调用clone方法，如果引用成员变量多的话，重复性代码多，不便于维护，推荐是使用序列化方式深拷贝。 模式的结构与实现 抽象原型类（Prototype）：规定了具体原型对象必须实现的接口。（如下图“Sheep”） 具体原型类（Concrete Prototype）：实现抽象原型类的 clone() 方法，它是可被复制的对象。（如下图“Goat”） 调用者（Caller）：使用具体原型类中的 clone() 方法来复制新的对象。（如下图“Client”） 1234567891011121314151617181920212223242526272829303132333435// 羊的抽象类public abstract class Sheep implements Cloneable { private String name; private Date birthday; public Sheep(String name, Date birthday) { this.name = name; this.birthday = birthday; } public abstract void show(); @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; }} 1234567891011121314// 山羊类public class Goat extends Sheep { public Goat(String name, Date birthday) { super(name, birthday); } @Override public void show() { System.out.println(\"我是一只山羊\"); System.out.println(getName()); System.out.println(getBirthday()); }} 12345678910111213141516// 调用类public class Client { public static void main(String[] args) throws CloneNotSupportedException { Date date = new Date(12345678901L); Sheep goat1 = new Goat(\"多莉\", date); System.out.println(goat1); goat1.show(); date.setTime(10987654321L); Sheep goat2 = (Sheep) goat1.clone(); System.out.println(goat2); goat2.show(); }} 相关链接： 设计模式 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/10/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"工厂模式","text":"23种设计模式——GOF（Group of four） 设计模式之工厂模式 定义：在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 核心作用：实现创建者和调用者分离。 核心本质： 实例化对象，用工厂方法代替new操作。 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 详细分类： 简单工厂模式 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码） 工厂方法模式 用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂模式 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力，支持增加产品族） 简单工厂模式定义：简单工厂模式也叫静态工厂模式，就是工厂类一般使用静态方法，通过接收的参数不同来返回不同的对象实例。 优点： 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。 客户端无需知道所创建具体产品的类名，只需知道参数即可。 可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。 缺点： 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。 模式的结构与实现 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。（如下图“CarFactory”） 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。（如下图“Car”） 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。（如下图“Audi”、“Byd”） 调用者（Caller）：工厂的调用者。（如下图“Client”） 12345// 车的接口public interface Car { void run();} 12345678// 奥迪车类public class Audi implements Car{ @Override public void run() { System.out.println(\"奥迪在跑》》》\"); }} 12345678// 比亚迪车类public class Byd implements Car{ @Override public void run() { System.out.println(\"比亚迪在跑》》》\"); }} 1234567891011// 车的工厂类public class CarFactory { public static Car createAudi(){ return new Audi(); } public static Car createByd(){ return new Byd(); }} 12345678910// 客户类public class Client { public static void main(String[] args) { Car audi = CarFactory.createAudi(); Car byd = CarFactory.createByd(); audi.run(); // 奥迪在跑》》》 byd.run(); // 比亚迪在跑》》》 }} 工厂方法模式定义：工厂方法模式，又称多态性工厂模式或虚拟构造子模式。通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。 与简单工厂模式的区别： 工厂方法模式避免了简单工厂模式不完全满足OCP的缺点。 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。 缺点： 类的个数容易过多，增加复杂度。 增加了系统的抽象性和理解难度。 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。 模式的结构与实现： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。（如下图“CarFactory”） 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。（如下图“AudiFactory”、“BydFactory”） 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。（如下图“Car”） 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。（如下图“Audi”、“Byd”） 调用者（Caller）：工厂的调用者。（如下图“Client”） 12345// 车的接口public interface Car { void run();} 12345678// 奥迪车类public class Audi implements Car{ @Override public void run() { System.out.println(\"奥迪在跑》》》\"); }} 12345678// 比亚迪车类public class Byd implements Car{ @Override public void run() { System.out.println(\"比亚迪在跑》》》\"); }} 12345// 车的工厂接口类public interface CarFactory { Car createCar();} 12345678// 奥迪工厂类public class AudiFactory implements CarFactory{ @Override public Car createCar() { return new Audi(); }} 12345678// 比亚迪工厂类public class BydFactory implements CarFactory{ @Override public Car createCar() { return new Byd(); }} 12345678910// 客户类public class Client { public static void main(String[] args) { Car audi = CarFactory.createAudi(); Car byd = CarFactory.createByd(); audi.run(); // 奥迪在跑》》》 byd.run(); // 比亚迪在跑》》》 }} 抽象工厂模式定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 为避免简单工厂模式的缺点，不完全满足OCP。 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 优点： 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。 缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。 模式的结构与实现： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法可以创建多个不同等级的产品。（如下图“CarFactory”） 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。（如下图“LuxuryCarFactory”、“LowCarFactory”） 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。（如下图“Engine”、“Seat”、“Tyre”） 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。（如下图“LuxuryEngine”、“LuxurySeat”、“LuxuryTyre”、“LowEngine”、“LowSeat”、“LowTyre”） 调用者（Caller）：工厂的调用者。（如下图“Client”） 12345// 发动机接口public interface Engine { void run();} 12345678// 高端发动机类 public class LuxuryEngine implements Engine { @Override public void run() { System.out.println(\"转的快！\"); }} 12345678// 低端发动机类public class LowEngine implements Engine { @Override public void run() { System.out.println(\"转的慢！\"); }} 12345// 座椅接口public interface Seat { void message();} 12345678// 高端座椅类public class LuxurySeat implements Seat { @Override public void message() { System.out.println(\"可以自动按摩！\"); }} 12345678// 低端座椅类public class LowSeat implements Seat { @Override public void message() { System.out.println(\"不能按摩！\"); }} 12345// 轮胎接口 public interface Tyre { void revolve();} 12345678// 高端轮胎类public class LuxuryTyre implements Tyre { @Override public void revolve() { System.out.println(\"旋转磨损慢！\"); }} 12345678// 低端轮胎类public class LowTyre implements Tyre { @Override public void revolve() { System.out.println(\"旋转磨损快！\"); }} 123456789// 车的工厂接口类public interface CarFactory { Engine createEngine(); Seat createSeat(); Tyre createTyre();} 123456789101112131415161718// 高端汽车工厂类 public class LuxuryCarFactory implements CarFactory { @Override public Engine createEngine() { return new LuxuryEngine(); } @Override public Seat createSeat() { return new LuxurySeat(); } @Override public Tyre createTyre() { return new LuxuryTyre(); }} 123456789101112131415161718// 低端汽车工厂类 public class LowCarFactory implements CarFactory { @Override public Engine createEngine() { return new LowEngine(); } @Override public Seat createSeat() { return new LowSeat(); } @Override public Tyre createTyre() { return new LowTyre(); }} 1234567891011121314151617// 客户类public class Client { public static void main(String[] args) { getCarParts(new LuxuryCarFactory()); // 转的快！ 可以自动按摩！ 旋转磨损慢！ getCarParts(new LowCarFactory()); // 转的慢！ 不能按摩！ 旋转磨损快！ } public static void getCarParts(CarFactory carFactory) { Engine engine = carFactory.createEngine(); Seat seat = carFactory.createSeat(); Tyre tyre = carFactory.createTyre(); engine.run(); seat.message(); tyre.revolve(); }} 相关链接： 设计模式 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/10/05/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"第二部分 结构化分析与设计方法（一）","text":"郑人杰 《软件工程概论》（第2版）第二部分 结构化分析与设计方法（一） 课后习题题解 第三章 软件需求获取与结构化分析方法1、顶层数据流图（或称环境图）的作用是什么？ 顶层数据流图（或称环境图）仅包括一个数据处理过程，也就是要开发的目标系统。其作用如下： 确定系统在其环境中的位置，与系统有联系的外部实体（包括硬件、软件、组织机构及人）有哪些。 通过确定系统的输入和输出与外部实体的关系确定系统的边界，也就是要确定哪些功能或处理属于系统范围之内，哪些属于系统范围之外，需要由其他系统处理或人工处理。 2、简述使用数据流图进行需求分析的过程。 （1）确定系统的输入输出由于系统究竟包括哪些功能可能一时难于弄清楚，可使范围尽量大一些，把可能有的内容全部都包括进去。此时，应该向用户了解“系统从外界接受什么数据”、“系统向外界送出什么数据”等信息，然后，根据用户的答复画出数据流图的外围。（2）由外向里画系统的顶层数据流图首先，将系统的输入数据和输出数据用一连串的加工连接起来。在数据流的值发生变化的地方就是一个加工。接着，给各个加工命名。然后，给加工之间的数据命名。最后，给文件命名。（3）自顶向下逐层分解，绘出分层数据流图对于大型的系统，为了控制复杂性，便于理解，需要采用自顶向下逐层分解的方法进行，即用分层的方法将一个数据流图分解成几个数据流图来分别表示 [1] 。 3、在对数据流图进行分解时需要注意哪些问题？ 在对数据流图进行分解时，需要注意以下两个问题： 当对数据流图分层细化时必须保持信息连续性，也就是说，当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。 注意分层细化时对编号的处理方法。 4、请根据以下描述画出某库存管理系统的数据流图。该系统的数据流描述如下：（1）根据计划部门转来的收货通知单和已存在的物资编码文件，建立物资采购单流水账。（2）根据技术部门的物资验收报告和物资采购单流水账，更新物资台账文件。（3）对物资台账分类汇总，将结果存储于物资总账文件中。（4）物资出库，物资使用部门填写物资出库单，包括物资编号、物资名称、物资数量、物资使用部分、负责人、经手人。系统根据物资总账文件的库存情况判断是否能够出库，如果能够出库，则记录出库单，并更新物资总账文件。 5、分析院系、专业、班级、课程、教师、学生、成绩之间的数据关系，画出ER图。 若以选课系统为基础，可做如下分析： 一个院系设置多个专业 一个院系拥有多个教师 一个专业由多个班级组成 一个专业开设多门课程，一门课程可由多个专业开设 一个教师教授多门课程，一门课程可由多个教师教授 一个学生选修多门课程，一门课程可让多个学生选修，每个学生选修的每一门课程都会产生一个成绩 一个班级属于多个学生 依据上述分析得出如下ER图： 6、一家书店计划开发图书管理系统对书店的业务进行管理，以提高管理人员及书店工作人员的工作效率，并方便顾客对图书进行检索，书店管理系统的基本功能需求如下：（1）采购管理：实现与供货商的图书采购、退货及结算管理，提供月统计报表及任意时间段的统计报表。（2）图书信息管理：记录每种图书的信息（包括ISBN号、书名、作者、出版社、出版日期、单价、版次、印次等）、折扣及库存量，并提供简单的图书查询功能。（3）销售管理：实现图书销售功能，记录顾客购买的图书种类、数量，计算总价，打印销售小票，并付款。提供日/月统计报表及任意时间段的统计报表。（4）用户管理：提供用户组（角色）及用户管理功能。针对上面的需求建立需求分析模型，包括数据流图（至少画出两层）和ER图。 7、试题库管理系统的相关人员包括题库维护人员、教师及学生。系统的基本功能需求描述如下：（1）题库维护人员负责试题的添加、修改、删除工作。试题信息包括试题编号、试题内容、试题类型、参考答案、分值等。其中，试题类型包括选择题、判断题、填空题、应用题。（2）给教师提供自动组卷、手动组卷及打印试卷功能，教师可以指定试卷分值，并选择是否保存试卷。（3）给学生提供随机组卷，在线练习、在线评价功能。针对上面的需求建立需求分析模型，包括数据流图、ER图。针对为学生提供的功能，画出系统的状态图。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/05/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"第一部分 软件工程概述（一）","text":"郑人杰 《软件工程概论》（第2版）第一部分 软件工程概述（一） 课后习题题解 第一章 软件与软件工程的概念1、举出你所知道的传统应用软件的例子。 办公软件、游戏软件、财务软件、银行软件、人事管理软件、学籍管理软件等。 2、“软件就是程序，软件开发就是编程序。”这种观点是否正确？为什么？ 认为“软件就是程序，软件开发就是编程序。”这种观点是错误的。 首先，软件是计算机系统中与硬件相互依存的另一部分，它包括程序、数据、及其相关文档的完整集合，程序只是软件的组成部分之一；其次，在软件开发中，编程只是软件开发过程中的一个阶段。 3、如果将软件开发比作高楼大厦的建造，可以将软件设计比做什么？ 可以将软件的设计比作建筑设计，软件设计的成果相当于建筑设计的图纸。 4、简述软件的分类，并举例说明。 在《软件工程概论》第2版中，按照软件的作用，将软件分为系统软件、应用软件、支撑软件、可复用软件4类。 系统软件：系统软件居于计算机系统中最靠近硬件的一层，其他软件一般通过系统软件发挥作用。系统软件与具体的应用领域无关。例如：操作系统、设备驱动程序、通信和网络处理程序。 应用软件：应用软件是特定应用领域专用的软件。例如：工程、科学计算软件、Web应用软件、人工智能软件。 支撑软件：支撑软件是支撑软件开发和维护的软件。例如：网络软件、软件工具、软件开发环境。 可复用软件：在开发新的软件时，可以对已有的可复用构件稍加修改或不加修改，复用所需的属性或服务。例如：各种标准函数库。 5、请给出你所知道的互联网应用软件的例子。传统应用软件与互联网应用软件有哪些不同之处？ 与传统软件较长的软件生存周期相比，互联网软件的软件生存周期更短，要求开发者想办法在较短的时间内完成计划、分析、设计、编码、测试，及时向用户发布； 与传统软件不同，一个互联网软件一般都有许多许多用户在同一时间访问，要求互联网软件能应对数量不明确的用户的访问和请求，支持并发； 传统软件可能需要针对不同的应用平台发布不同的软件版本让不同平台上的用户能够使用，而互联网软件则能让不同平台用户能够通过Web浏览器方便地使用； 不同于传统的、按一系列规划的时间间隔发布并进行演化的应用软件，互联网软件应不断地进行演化； 互联网软件依赖于网络而存在，需要服务变化多样的客户群。它需要一定程度上的互联网的支持才能够正常运行，而且网络状况的好坏也对互联网软件的运行有着较大的影响； 互联网软件是通过网络访问可达的，因此要限制终端用户的使用就比较困难。要保护软件的安全和稳定就必须采取有效的安全措施。 6、什么是软件危机？它有哪些典型表现？为什么会出现软件危机？ 软件危机是指计算机软件开发、使用与维护过程中所遇到的一系列严重问题和难题。 典型表现有： 对软件开发成本和进度的估计常常很不准确； 软件产品的质量往往靠不住； 用户对已完成的软件系统不满意的现象经常发生； 软件常常是不可维护的； 软件中没有适当的文档资料； 软件成本在计算机系统总成本所占的比例逐年上升； 软件开发生产率提高的速度，往往跟不上计算机应用迅速普及深入的趋势。 原因： 软件本身独有的特点确实给开发和维护带来了困难； 与软件开发和维护的许多错误认识和做法的形成有关； 面对日益增长的软件需求，人们显得力不从心。 7、什么是软件工程？软件工程要解决核心问题是什么？ 应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、发布和维护的工程或进行研究的学科。 以较短的周期、较低的成本生产出高质量的软件产品，并最终实现软件的工业化生产。 8、简述软件生存期有哪些主要阶段组成，每个阶段的主要任务是什么？ 问题定义与可行性研究：问题定义必须回答的关键问题是：“要解决的问题是什么”。可行性研究要回答的关键问题是：“在成本和时间的限制条件下能否解决问题？是否值得做？”。需求分析：这个阶段的任务仍然不是具体地解决客户的问题，而是准确的回答“目标系统必须做什么”这个问题。软件设计：本阶段要回答的关键问题是“目标系统如何做？”为此，必须在设计阶段中制定设计方案，把已确定的各项需求转换成相应的软件体系架构。结构中的每一组成部分都是有意义明确的构件，此即所谓概要设计。进而具体描述每个构件所要完成的工作，为源程序编写打下基础，此即所谓详细设计。程序编码和单元测试：本阶段要解决的问题是“正确地实现已做的设计”，为此，需要选择合适的编程语言，把软件设计转换成计算机可以接受的程序代码，并对程序结构中的各个模块进行单元测试，然后运用调试的手段排除测试中发现的错误。集成测试和系统测试：集成测试的任务是将已测试过的模块按设计规定的顺序组装起来，在组装的过程中检查程序连接的问题。系统测试的任务是根据需求规格说明的要求，对必须实现的各项需求，逐项进行确认，判定已开发的软件是否符合用户需求，能否交付用户使用。运行维护：已交付的软件投入正式使用，便进入运行维护阶段。这一阶段可能持续若干年。软件在运行中可能由于多方面的原因，需要对它进行维护。通常有四种类型的维护：改正性维护、适应性维护、完善性维护和预防性维护。 9、区分单元测试、集成测试和系统测试。 10、软件工程的三种基本要素是什么？各自什么作用？ 方法、工具和过程。 软件工程方法为建造软件提供技术上的解决方法； 工具为方法的运用提供自动或半自动的软件支撑环境； 过程是获得高质量软件所需完成的一系列人物的框架，它规定了完成各项任务的工作步骤。 11、简述传统方法和面向对象方法的特点。 传统方法： 传统方法也称为生命周期方法或结构化范型。 它采用结构化技术来完成软件开发的各项任务。每一个阶段的开始和结束都有严格的标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段开始的标准。 传统方法的主要缺点是在适应需求变化方面不够灵活，另外，结构化方法要么面向行为，要么面向数据，缺乏使两者有机结合的机制。 面向对象方法的特点： 面向对象方法把数据和行为看成同等重要，是将数据核对数据的操作紧密地结合起来的方法，这也是面向对象方法与传统方法的重要区别。 面向对象方法的出发点和原则，是尽量模拟人类西噶UN的思维方式，是开发软件的方法和过程尽可能接近人类认识问题和解决问题的方法与过程，从而使描述问题空间与其解空间在结构上尽可能一致。 对于大型、复杂及交互操作比较强的系统，使用面向对象方法更具优势。 12、形式化方法的特点是什么？ 形式化方法的特点： 软件需求规格说明被细化为用数学记号表达的详细的形式化规格说明。 设计、实现和单元测试等开发过程由一个变换开发过程代替。通过一系列变换将形式的规格说明细化成为程序。 13、软件开发过程中的常用软件有哪些？ 需求分析和设计工具。如：Rational Rose、Microsoft Office Visio等。 编码工具与排错工具。如：Visual C++ 6.0、Eclipse等。 测试工具。如：xUnit、IBM Rational Functional Tester、IBM Rational Robot等。 14、在软件工程知识体系中，将软件工程划分划分为哪些知识域？ SWEBOK指南将软件工程体系划分为15个知识域，这些知识域又划分为三类： 软件工程基础类：软件工程经济学、计算基础、工程基础、数学基础。 软件生存期过程类：软件工程模型和方法、软件需求、软件设计、软件构造、软件测试、软件维护。 软件工程管理类：软件工程过程、软件工程管理、软件配置管理、软件质量、软件工程专业实践。 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/03/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"23种设计模式——GOF（Group of four）","text":"23种设计模式——GOF（Group of four） 创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。（5种） 结构型模式：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式。（7种） 行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。（11种） 23种设计模式——GOF（Group of four） 创建型模式 单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式 结构型模式 行为型模式 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"第一部分 软件工程概述（二）","text":"郑人杰 《软件工程概论》（第2版）第一部分 软件工程概述（二） 课后习题题解 第二章 软件生存期模型1、瀑布模型、快速原型模型、增量模型及螺旋模型都是传统的软件设计过程模型，请给出各个模型的特点。每种模型的优点和缺点是什么？适合于哪些场合？ 瀑布模型： 特点： 阶段间具有顺序性和依赖性； 具有推迟实现的观点； 具有质量保证的观点。优点： 符合软件开发的思维过程，并容易理解和运用; 通过设置里程碑，可以明确每个阶段的任务和目标； 支持结构化软件开发，可为各阶段制定开发计划，进行成本预算。 通过阶段审核，将开发过程纳入正轨； 严格的计划性保证软件产品的按时交付。缺点： 缺乏灵活性，不能适应用户需求的变化； 开始阶段的小错误会被逐级放大，可能最终导致软件产品报废； 缺乏演化性，返回上一级的开发需要十分昂贵的代价； 随着软件规模和复杂性的增加，软件产品成功的几率大幅下降。适用场合： 用户的需求非常清楚全面，且在开发过程中没有或很少变化； 规模较小的软件开发。 快速原型模型： 特点： 不要求需求预先完备定义； 支持需求的渐进式完善和确认； 支持用户参与，能够适应用户需求的变化。优点： 用户参与软件系统的所有阶段，可以得到比较良好的需求定义，容易适应需求的变化； 用户较早的接触和使用未来的系统，有利于系统后期的使用和维护； 开发费用低、开发周期短且对用户更友好。缺点： 客户与开发者对原型理解不同； 准确的原型设计比较困难； 不利于开发人员的创新。适用场合： 对所开发的领域比较熟悉而且有快速的原型开发工具； 项目招投标时，可以以原型模型作为软件的开发模型； 进行产品移植或升级时，或对已有产品原型进行客户化工作时，原型模型是非常适合的。 增量模型： 特点： 软件产品是被增量式地一块块开发的； 允许开发活动并行和重叠。 采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源； 如果核心产品很受欢迎，则可增加人力实现下一个增量； 可先发布部分功能给客户，对客户起到镇静剂的作用。缺点： 并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构； 增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。适用场合： 进行已有产品升级或新版本开发，增量模型是非常适合的； 对完成期限严格要求的产品，可以使用增量模型； 对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。 螺旋模型： 特点：结合瀑布模型、快速原型模型和迭代模型的思想，并引进了风险分析活动。优点： 设计上的灵活性,可以在项目的各个阶段进行变更； 以小的分段来构建大型系统,使成本计算变得简单容易； 客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性； 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。缺点： 采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失； 过多的迭代次数会增加开发成本，延迟提交时间。适用场合：螺旋模型只适合于大规模的软件项目。 2、如果在要求的期限内软件产品的所有功能都能够开发完成，上述四种模型中应选择哪种模型？如果只能完成一部分功能，又应该选择哪种模型？ 瀑布模型。严格的计划性保证软件产品的按时交付。 快速原型模型。用户参与软件系统的所有阶段，可以得到比较良好的需求定义，容易适应需求的变化。 3、可以合用几种模型吗？如果可以，举例说明。 过程模型可以合用，每个模型都有个有点不同的处理流程，但都执行相同的通用框架活动集：沟通，规划，建模，施工和交付/反馈。例如线性顺序模型可以作为一个有用的过程模型，沟通，规划，建模，施工和交付/反馈。例如线性顺序模型可以作为一个有用的过程模型，在被固定的情况下，要求工作以线性的方式继续进行，直至完成。在这情况下，开发者可能无法确定一种算法的效率，一个操作系统的适应性或应采取的人机交互的形式。在这之中，以及许多其他场合原型模型可以提供最好的办法。在其他情况下，以渐进的方式可能是有意义的和螺旋模型的流动可能是有效率，特殊过程模型具有许多的一个或多个传统的特性。 4、解释喷泉模型的特点及其适用的场合。 特点： 各阶段相互重叠，它反映了软件过程并行性的特点； 体现认识事物的往返过程； 强调增量开发，整个过程是一个迭代的逐步提炼的过程； 开发活动之间的无间隙性和循环迭代性； 适用于面向对象的开发过程。 强调无明显的活动阶段划分。适用场景：主要用于面向对象技术的软件开发项目，它克服了瀑布模型不支持软件重用和多项目开发活动集成的局限性，喷泉模型使开发过程具有迭代性和无间隙性。 5、统一过程与UML是同一概念吗？请给出解释。 统一过程与UML不是同一概念。 UML是一种语言，统一过程是用UML进行面向对象软件工程对的框架。 6、统一过程的6个核心过程工作流是什么？ 业务建模工作流； 需求工作流； 分析与设计工作流； 实现工作流； 测试工作流； 部署工作流。 7、给出两个核心支持工作流。 配置与变更管理； 项目管理。 8、统一过程的4个阶段是什么？ 初始阶段； 细化阶段； 构造阶段； 移交阶段。 9、请解释为什么基于构件的软件开发能够极大地提高软件开发的生产率和软件质量。 软件的复用是提高软件生产效率及软件质量的最有效途径，而基于构件的软件开发比面向对象的软件开发实现了更大粒度的软件复用，能够最大限度地减少重复劳动、缩短开发周期、降低开发成本，从而使软件生存率得到提高。由于已有的构件大都经过了很长时间的运行和测试，在质量方面比新开发的软件更有保证，同事软件架构技术有助于软件设计的标准化和设计风格的改进和统一，进而提高系统间的互操作性，软件可靠性和可维护性可以得到增强。 10、敏捷软件开发的特点是什么？ 迭代式开发。整个开发过程被分为几个迭代周期，每个迭代期是一个定长或不定长的时间块，每个迭代周期持续的时间一般较短，通常为1~6周。 增量交付。产品在每个迭代周期结束时被逐步交付使用，而不是在整个开发过程结束时一次性交付。每次交付的都是可被部署到用户应用环境中的、能给用户带来即时效益和价值的产品。 开发团队和用户反馈推动产品开发。敏捷开发方法主张用户能够全程参与整个开发过程。这使需求变化和用户反馈能动态管理并及时集成到产品中。同时，团队也能及时对用户的需求提供反馈意见。 持续集成。新的功能或需求变化总是尽可能频繁地被整合到产品中。一些项目是在每个迭代周期结束的时候集成，有些项目则每天都在集成。 开发团队自我管理。拥有一个积极的、自我管理的、具备自由交流风格的开发团队，是每个敏捷项目的必要条件。敏捷开发总是以人为中心建立开发的过程和机制，而非把过程和机制强加给人。 11、简述敏捷软件开发的原则。 持续、尽早交付有价值的软件以满足用户，是我们优先要做的首要任务。 拥抱需求变更，甚至是在开发的后期。敏捷过程利用变更为客户带来竞争优势。 频繁交付可执行的软件，从几周到几个月，交付时间越短越好。 在整个项目过程中，业务人员和开发人员必须每天一起工作。 激发每个团队成员的积极性来打造项目。为他们提供环境与支持，并且信任他们可以完成工作。 在一个开发团队内部最有效的传递信息的方式是面对面交流。 可执行的软件是进度的首要检验对象。 敏捷过程倡导可持续发展。赞助商、开发人员和用户用该尽可能保持一致的步伐。 不断地关注优秀技能和好的设计会增强敏捷能力。 尽量用艺术化来简单阐述未完成的工作是很有必要的。 最好的架构、需求和设计出自于自我组织管理的团队。 每隔一段时间，回顾反思如何让团队变得更高效，并相应地调整其行为。 12、用自己的语言描述XP的重构和结对编程的概念。 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。这是一种净化代码以尽可能减少引入错误的严格方法。实质上，重构就是在编码完成之后改进代码设计。 结对编程是这样一种程序设计实践：两名程序员并肩同坐在同一台计算机前，共同探讨设计方案、共同设计算法、共同编写程序代码、共同完成各种测试。 13、你认为本书所讲的哪种过程模型适合互联网软件的开发及维护？还是都不合适？ 学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/04/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"第一章 Java语言概述","text":"Java语言概述 1、基础常识 软件，及一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 人机交互方式 图形化界面 命令行方式 常用Dos命令 dir ：列出当前目录下的文件以及文件夹md ：创建目录rd ：删除目录cd ：进入指定目录cd.. ：退回到上一级目录cd\\ ：退回到根目录del ：删除文件exit ：退出dos命令行 2、Java语言概述 计算机语言：人与计算机交流的方式。 第一代语言 打孔机–纯机器语言 第二代语言 汇编 第三代语言平台 C、Pascal、Fortran面向过程的语言 C++面向过程/面向对象 Java跨平台的纯面向对象的语言 .NET跨语言的 面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 Java语言的诞生、特点 java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了 C++语言面向对象技术的核心。Java舍弃了C语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承（以接口取代）等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程（Generic Programming）、类型安全的枚举、不定长参数和自动装/拆箱 Java语言概述 是SUN(Stanford University Network，斯坦福大学网络公司)1995年推出的一门高级编程语言。 95年，SUN发布JDK 1.0，98年，JDK1.2，后续JDK1.3， 1.4，1.5（更名为Java5.0）最新为JDK13。 是一种面向Internet的编程语言。 随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 java语言的主要特性 Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。 Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。 Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。 Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。 Java语言是跨平台的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的跨平台的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。 Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。 Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。 Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 Java的应用领域 企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。 Android平台应用：Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。 嵌入式应用：是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。 3、Java语言运行机制及运行过程Java两种核心机制 Java虚拟机（Java Virtal Machine），JVM 垃圾收集机制（Garbage Collection），GC Java虚拟机 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 对于不同的平台，有不同的虚拟机。 Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 垃圾回收 不再使用的内存空间应回收—— 垃圾回收。 在C/C++等语言中，由程序员负责回收无用内存。 Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 4、Java语言的环境搭建下载、安装JDK 官方网址： https://www.oracle.com/technetwork/java/javase/downloads/index.html 安装JDK 傻瓜式安装，下一步即可。 建议：安装路径不要有中文或者特殊符号如空格等。 当提示安装 JRE 时，可以选择不安装。 推荐安装 链接：https://pan.baidu.com/s/1Yo0TmmvqcPAg3RTUPrY75g 提取码：d6zc 直接下载需要的对应版本压缩包，方便在需要使用多个版本jdk时的切换。 配置环境变量 新建系统变量JAVA_HOME 解压jdk的目录（如“D:\\Learn\\java\\jdk1.8.0_102”） 在系统变量Path中新建 %JAVA_HOME%\\bin 验证是否成功 命令行输入命令：java -version 什么是JDK，JRE JDK(Java Development Kit Java开发工具包) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JRE(Java Runtime Environment Java运行环境) 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。 JVM、JRE、JDK 关系 5、HelloWorld步骤： 将 Java 代码编写到扩展名为 .java 的文件中。 通过 javac 命令对该 java 文件进行编译。 通过 java 命令对生成的 class 文件进行运行。 步骤一：编写 选择最简单的编辑器：记事本。 敲入代码 将文件保存成HelloWorld.java，这个文件是存放java代码的文件，称为源文件。 12345public class HelloWorld{ public static void main(String args[]){ System.out.println(\"Hello World\"); }} 步骤二：编译 有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。 在该源文件目录下，通过javac编译工具对HelloWorld.java文件进行编译。 如果程序没有错误，没有任何提示，但在当前目录下会出现一个HelloWorld.class文件，该文件称为字节码文件，也是可以执行的java的程序。 步骤三：运行 有了可执行的java程序(HelloWorld.class字节码文件) 通过运行工具java.exe对字节码文件进行执行。 6、小结第一个程序 Java源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本类中的HelloWorld类。 Java应用程序的执行入口是main()方法。它有固定的书写格式：public static void main(String[] args) {…} Java语言严格区分大小写。 Java方法由一条条语句构成，每个语句以“;”结束。 括号都是成对出现的，缺一不可。 7、常见问题及解决方法 源文件名不存在或者写错，或者当前路径错误。 类文件名写错，或者类文件不在当前路径下，或者环境变量没有配置好。 声明为public的主类应与文件名一致，否知编译失败 编译失败，注意错误出现的行数，再到源代码中指定位置改错 8、注 释 用于注解说明解释程序的文字就是注释。 提高了代码的阅读性；调试程序的重要方法。 注释是一个程序员必须要具有的良好编程习惯。 将自己的思想通过注释先整理出来，再用代码去体现 Java中的注释类型： 单行注释 // 多行注释/* */ 文档注释（java特有） 单行注释1//注释文字 多行注释1/* 注释文字 */ 文档注释（java特有）12345/** * @author 指定java程序的作者 * @version 指定源文件的版本 * @param 方法的参数说明信息 */ 注： 对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。 多行注释里面不允许有多行注释嵌套。 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 来自b站 求知讲堂小龙https://www.bilibili.com/video/av76235341?p=1学习所得，资料参考其所讲内容，图片部分来源于网络，如有侵权，请联系本人删除。 才疏学浅，若有错误或不当之处，可批评指正，还请见谅！","link":"/2020/03/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"}],"tags":[{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"逆元","slug":"逆元","link":"/tags/%E9%80%86%E5%85%83/"},{"name":"异或","slug":"异或","link":"/tags/%E5%BC%82%E6%88%96/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"2019 年百度之星·程序设计大赛 - 初赛二","slug":"2019-年百度之星·程序设计大赛-初赛二","link":"/tags/2019-%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%88%9D%E8%B5%9B%E4%BA%8C/"},{"name":"2020 年百度之星·程序设计大赛 - 初赛三","slug":"2020-年百度之星·程序设计大赛-初赛三","link":"/tags/2020-%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%88%9D%E8%B5%9B%E4%B8%89/"},{"name":"博弈","slug":"博弈","link":"/tags/%E5%8D%9A%E5%BC%88/"},{"name":"概率","slug":"概率","link":"/tags/%E6%A6%82%E7%8E%87/"},{"name":"2020 年百度之星·程序设计大赛 - 复赛","slug":"2020-年百度之星·程序设计大赛-复赛","link":"/tags/2020-%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%A4%8D%E8%B5%9B/"},{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"Java SE","slug":"Java-SE","link":"/tags/Java-SE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"建造者模式","slug":"建造者模式","link":"/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","link":"/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","link":"/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"XMOJ","slug":"XMOJ","link":"/categories/XMOJ/"},{"name":"HDOJ","slug":"HDOJ","link":"/categories/HDOJ/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法思想","slug":"算法思想","link":"/categories/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"},{"name":"软件工程","slug":"软件工程","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]}